"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/employees/page",{

/***/ "(app-pages-browser)/./lib/store-factory.ts":
/*!******************************!*\
  !*** ./lib/store-factory.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCrudStore: () => (/* binding */ createCrudStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _smart_prefix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./smart-prefix */ \"(app-pages-browser)/./lib/smart-prefix.ts\");\n/* harmony import */ var _id_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./id-config */ \"(app-pages-browser)/./lib/id-config.ts\");\n\n// persist, createJSONStorage removed - database is now source of truth\n\n\n\nconst SYSTEM_FALLBACK_ID = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)('SYS000000');\nconst asSystemIdFallback = ()=>SYSTEM_FALLBACK_ID;\n// ✅ API Sync helper for store-factory\nasync function syncToAPI(apiEndpoint, action, data, systemId) {\n    try {\n        const endpoint = action === 'create' ? apiEndpoint : `${apiEndpoint}/${systemId || data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : action === 'delete' ? 'DELETE' : 'PATCH'; // restore uses PATCH\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            credentials: 'include',\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.warn(`[Store Factory API] ${action} failed for ${apiEndpoint}:`, response.status);\n        }\n        return response.ok;\n    } catch (error) {\n        console.error(`[Store Factory API] ${action} error for ${apiEndpoint}:`, error);\n        return false;\n    }\n}\nconst createCrudStore = (_initialData, entityType, options)=>{\n    const businessPrefix = (0,_smart_prefix__WEBPACK_IMPORTED_MODULE_1__.getPrefix)(entityType); // Vietnamese prefix for Business ID (NV, KH, DH)\n    const config = _id_config__WEBPACK_IMPORTED_MODULE_2__.ID_CONFIG[entityType];\n    const systemIdPrefix = config?.systemIdPrefix || entityType.toUpperCase(); // English prefix for SystemId (EMP, CUSTOMER, ORDER)\n    const businessIdField = options?.businessIdField ?? 'id';\n    // const persistKey = options?.persistKey; // @deprecated - No longer used\n    const getCurrentUser = options?.getCurrentUser;\n    const apiEndpoint = options?.apiEndpoint;\n    // ✅ CHANGED: Start with empty array - database is source of truth\n    // Mock data files (data.ts) are NO LONGER USED for runtime\n    const normalizedInitialData = [];\n    const storeConfig = (set, get)=>({\n            data: normalizedInitialData,\n            // ✅ Persist counters in state (will be saved to localStorage)\n            _counters: {\n                systemId: (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(normalizedInitialData, systemIdPrefix),\n                businessId: options?.businessIdField ? (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(normalizedInitialData, businessPrefix) : 0\n            },\n            _initialized: false,\n            add: (item)=>{\n                // ✅ Get counters from state (persisted)\n                const currentCounters = get()._counters;\n                const newSystemIdCounter = currentCounters.systemId + 1;\n                const newSystemId = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)((0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(entityType, newSystemIdCounter));\n                // Generate or validate Business ID (if field exists)\n                let finalItem = {\n                    ...item\n                };\n                let newBusinessIdCounter = currentCounters.businessId;\n                if (businessIdField in item) {\n                    const customId = item[businessIdField];\n                    const existingIds = get().data.map((d)=>d[businessIdField]);\n                    // ✅ If customId provided, validate uniqueness\n                    if (customId && customId.trim()) {\n                        if (!(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(customId, existingIds)) {\n                            throw new Error(`Mã \"${customId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                        }\n                        finalItem[businessIdField] = customId.trim().toUpperCase();\n                    } else {\n                        // ✅ Auto-generate with findNextAvailableBusinessId\n                        const digitCount = 6; // All entities use 6 digits\n                        const result = (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(businessPrefix, existingIds, newBusinessIdCounter, digitCount);\n                        finalItem[businessIdField] = result.nextId;\n                        newBusinessIdCounter = result.updatedCounter;\n                    }\n                }\n                const now = new Date().toISOString();\n                const currentUser = getCurrentUser?.();\n                const newItem = {\n                    ...finalItem,\n                    systemId: newSystemId,\n                    createdAt: finalItem.createdAt || now,\n                    updatedAt: now,\n                    createdBy: finalItem.createdBy || currentUser,\n                    updatedBy: currentUser\n                };\n                // ✅ Update both data and counters atomically\n                set((state)=>({\n                        data: [\n                            ...state.data,\n                            newItem\n                        ],\n                        _counters: {\n                            systemId: newSystemIdCounter,\n                            businessId: newBusinessIdCounter\n                        }\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    syncToAPI(apiEndpoint, 'create', newItem).catch(console.error);\n                }\n                return newItem;\n            },\n            addMultiple: (items)=>set((state)=>{\n                    const now = new Date().toISOString();\n                    const currentUser = getCurrentUser?.();\n                    const newItems = [];\n                    const digitCount = 6; // All entities use 6 digits\n                    // ✅ Start from current counters\n                    let currentSystemIdCounter = state._counters.systemId;\n                    let currentBusinessIdCounter = state._counters.businessId;\n                    items.forEach((item)=>{\n                        // ✅ Generate SystemId from current counter\n                        currentSystemIdCounter++;\n                        const newSystemId = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)((0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(entityType, currentSystemIdCounter));\n                        // Generate or validate Business ID (if field exists)\n                        let finalItem = {\n                            ...item\n                        };\n                        if (businessIdField in item) {\n                            const customId = item[businessIdField];\n                            // Collect existing IDs (from state + already added in this batch)\n                            const existingIds = [\n                                ...state.data.map((d)=>d[businessIdField]),\n                                ...newItems.map((d)=>d[businessIdField])\n                            ];\n                            // ✅ If customId provided, validate uniqueness\n                            if (customId && customId.trim()) {\n                                if (!(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(customId, existingIds)) {\n                                    throw new Error(`Mã \"${customId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                                }\n                                finalItem[businessIdField] = customId.trim().toUpperCase();\n                            } else {\n                                // ✅ Auto-generate with findNextAvailableBusinessId\n                                const result = (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(businessPrefix, existingIds, currentBusinessIdCounter, digitCount);\n                                finalItem[businessIdField] = result.nextId;\n                                currentBusinessIdCounter = result.updatedCounter;\n                            }\n                        }\n                        newItems.push({\n                            ...finalItem,\n                            systemId: newSystemId,\n                            createdAt: now,\n                            updatedAt: now,\n                            createdBy: currentUser,\n                            updatedBy: currentUser\n                        });\n                    });\n                    // ✅ Update both data and counters\n                    const result = {\n                        data: [\n                            ...state.data,\n                            ...newItems\n                        ],\n                        _counters: {\n                            systemId: currentSystemIdCounter,\n                            businessId: currentBusinessIdCounter\n                        }\n                    };\n                    // ✅ Sync to API in background (batch)\n                    if (apiEndpoint) {\n                        newItems.forEach((item)=>{\n                            syncToAPI(apiEndpoint, 'create', item).catch(console.error);\n                        });\n                    }\n                    return result;\n                }),\n            update: (systemId, updatedItem)=>{\n                // Validate unique business ID (case-insensitive, skip self)\n                if (businessIdField in updatedItem) {\n                    const businessId = updatedItem[businessIdField];\n                    const existingIds = get().data.filter((d)=>d.systemId !== systemId).map((d)=>d[businessIdField]);\n                    if (businessId && !(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(businessId, existingIds)) {\n                        throw new Error(`Mã \"${businessId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                    }\n                }\n                const now = new Date().toISOString();\n                const currentUser = getCurrentUser?.();\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                ...updatedItem,\n                                updatedAt: now,\n                                updatedBy: currentUser\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const fullItem = get().data.find((item)=>item.systemId === systemId);\n                    if (fullItem) {\n                        syncToAPI(apiEndpoint, 'update', fullItem, systemId).catch(console.error);\n                    }\n                }\n            },\n            remove: (systemId)=>{\n                // Soft delete - mark as deleted\n                const now = new Date().toISOString();\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                isDeleted: true,\n                                deletedAt: now\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const item = get().data.find((item)=>item.systemId === systemId);\n                    if (item) {\n                        syncToAPI(apiEndpoint, 'update', {\n                            ...item,\n                            isDeleted: true,\n                            deletedAt: now\n                        }, systemId).catch(console.error);\n                    }\n                }\n            },\n            hardDelete: (systemId)=>{\n                // Permanent delete - remove from array\n                set((state)=>({\n                        data: state.data.filter((item)=>item.systemId !== systemId)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    syncToAPI(apiEndpoint, 'delete', {\n                        systemId\n                    }, systemId).catch(console.error);\n                }\n            },\n            restore: (systemId)=>{\n                // Restore soft-deleted item\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                isDeleted: false,\n                                deletedAt: null\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const item = get().data.find((item)=>item.systemId === systemId);\n                    if (item) {\n                        syncToAPI(apiEndpoint, 'restore', {\n                            ...item,\n                            isDeleted: false,\n                            deletedAt: null\n                        }, systemId).catch(console.error);\n                    }\n                }\n            },\n            getActive: ()=>get().data.filter((item)=>!item.isDeleted),\n            getDeleted: ()=>get().data.filter((item)=>item.isDeleted),\n            findById: (id)=>get().data.find((item)=>item.systemId === id || item.id === id),\n            // ✅ Load data from database API - OPTIMIZED: No more limit=10000!\n            // This is now only used for counter initialization, NOT for loading all data\n            // Use React Query hooks for data fetching with proper pagination\n            loadFromAPI: async ()=>{\n                if (!apiEndpoint) return;\n                if (get()._initialized) return;\n                try {\n                    // Only fetch minimal data needed to initialize counters\n                    // Actual data loading should be done via React Query hooks\n                    const response = await fetch(`${apiEndpoint}?limit=1&sortBy=systemId&sortOrder=desc`, {\n                        credentials: 'include'\n                    });\n                    if (response.ok) {\n                        const json = await response.json();\n                        const pagination = json.pagination || {};\n                        const lastItem = json.data?.[0];\n                        // Initialize counters from the latest item (highest IDs)\n                        const newCounters = {\n                            systemId: lastItem ? (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)([\n                                lastItem\n                            ], systemIdPrefix) : 0,\n                            businessId: lastItem && options?.businessIdField ? (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)([\n                                lastItem\n                            ], businessPrefix) : 0\n                        };\n                        set({\n                            data: [],\n                            _counters: newCounters,\n                            _initialized: true\n                        });\n                        console.log(`[Store Factory] ${apiEndpoint} initialized. Total records: ${pagination.total || 'unknown'}`);\n                    }\n                } catch (error) {\n                    console.error(`[Store Factory] loadFromAPI error for ${apiEndpoint}:`, error);\n                    // Still mark as initialized to prevent infinite retry\n                    set({\n                        _initialized: true\n                    });\n                }\n            }\n        });\n    // ✅ SIMPLIFIED: No localStorage persistence, database is source of truth\n    // Data is loaded via ApiSyncProvider on app init\n    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__.create)(storeConfig);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdG9yZS1mYWN0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBQ2pDLHVFQUF1RTtBQVNuRDtBQUN1QjtBQUNrRjtBQUU3SCxNQUFNUyxxQkFBK0JELDBEQUFjQSxDQUFDO0FBRXBELE1BQU1FLHFCQUFxQixJQUFnQkQ7QUFFM0Msc0NBQXNDO0FBQ3RDLGVBQWVFLFVBQ2JDLFdBQW1CLEVBQ25CQyxNQUFrRCxFQUNsREMsSUFBZ0MsRUFDaENDLFFBQW1CO0lBRW5CLElBQUk7UUFDRixNQUFNQyxXQUFXSCxXQUFXLFdBQ3hCRCxjQUNBLEdBQUdBLFlBQVksQ0FBQyxFQUFFRyxZQUFZLEtBQWNBLFFBQVEsRUFBRTtRQUUxRCxNQUFNRSxTQUFTSixXQUFXLFdBQVcsU0FDakNBLFdBQVcsV0FBVyxVQUN0QkEsV0FBVyxXQUFXLFdBQ3RCLFNBQVMscUJBQXFCO1FBRWxDLE1BQU1LLFdBQVcsTUFBTUMsTUFBTUgsVUFBVTtZQUNyQ0M7WUFDQUcsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLGFBQWE7WUFDYkMsTUFBTVQsV0FBVyxXQUFXVSxLQUFLQyxTQUFTLENBQUNWLFFBQVFXO1FBQ3JEO1FBRUEsSUFBSSxDQUFDUCxTQUFTUSxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLElBQUksQ0FBQyxDQUFDLG9CQUFvQixFQUFFZixPQUFPLFlBQVksRUFBRUQsWUFBWSxDQUFDLENBQUMsRUFBRU0sU0FBU1csTUFBTTtRQUMxRjtRQUNBLE9BQU9YLFNBQVNRLEVBQUU7SUFDcEIsRUFBRSxPQUFPSSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixFQUFFakIsT0FBTyxXQUFXLEVBQUVELFlBQVksQ0FBQyxDQUFDLEVBQUVrQjtRQUN6RSxPQUFPO0lBQ1Q7QUFDRjtBQTJCTyxNQUFNQyxrQkFBa0IsQ0FDN0JDLGNBQ0FDLFlBQ0FDO0lBT0EsTUFBTUMsaUJBQWlCN0Isd0RBQVNBLENBQUMy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RSxpREFBaUQ7SUFDakQsT0FBTy9DLCtDQUFNQSxDQUFlMEM7QUFDOUIsRUFBRSIsInNvdXJjZXMiOlsiRDpcXGhybTJcXGxpYlxcc3RvcmUtZmFjdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuLy8gcGVyc2lzdCwgY3JlYXRlSlNPTlN0b3JhZ2UgcmVtb3ZlZCAtIGRhdGFiYXNlIGlzIG5vdyBzb3VyY2Ugb2YgdHJ1dGhcclxuaW1wb3J0IHsgXHJcbiAgZ2VuZXJhdGVTeXN0ZW1JZCwgXHJcbiAgZ2VuZXJhdGVCdXNpbmVzc0lkLCBcclxuICBpc0J1c2luZXNzSWRVbmlxdWUsXHJcbiAgZ2V0TWF4U3lzdGVtSWRDb3VudGVyLFxyXG4gIGdldE1heEJ1c2luZXNzSWRDb3VudGVyLFxyXG4gIGZpbmROZXh0QXZhaWxhYmxlQnVzaW5lc3NJZCxcclxuICB0eXBlIEVudGl0eVR5cGUgXHJcbn0gZnJvbSAnLi9pZC11dGlscyc7XHJcbmltcG9ydCB7IGdldFByZWZpeCB9IGZyb20gJy4vc21hcnQtcHJlZml4JztcclxuaW1wb3J0IHsgSURfQ09ORklHLCB0eXBlIFN5c3RlbUlkLCB0eXBlIEJ1c2luZXNzSWQsIGNyZWF0ZVN5c3RlbUlkLCBjcmVhdGVCdXNpbmVzc0lkIGFzIGJyYW5kQnVzaW5lc3NJZCB9IGZyb20gJy4vaWQtY29uZmlnJztcclxuXHJcbmNvbnN0IFNZU1RFTV9GQUxMQkFDS19JRDogU3lzdGVtSWQgPSBjcmVhdGVTeXN0ZW1JZCgnU1lTMDAwMDAwJyk7XHJcblxyXG5jb25zdCBhc1N5c3RlbUlkRmFsbGJhY2sgPSAoKTogU3lzdGVtSWQgPT4gU1lTVEVNX0ZBTExCQUNLX0lEO1xyXG5cclxuLy8g4pyFIEFQSSBTeW5jIGhlbHBlciBmb3Igc3RvcmUtZmFjdG9yeVxyXG5hc3luYyBmdW5jdGlvbiBzeW5jVG9BUEk8VD4oXHJcbiAgYXBpRW5kcG9pbnQ6IHN0cmluZyxcclxuICBhY3Rpb246ICdjcmVhdGUnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJyB8ICdyZXN0b3JlJyxcclxuICBkYXRhOiBUIHwgeyBzeXN0ZW1JZDogU3lzdGVtSWQgfSxcclxuICBzeXN0ZW1JZD86IFN5c3RlbUlkXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgXHJcbiAgICAgID8gYXBpRW5kcG9pbnQgXHJcbiAgICAgIDogYCR7YXBpRW5kcG9pbnR9LyR7c3lzdGVtSWQgfHwgKGRhdGEgYXMgYW55KS5zeXN0ZW1JZH1gO1xyXG4gICAgXHJcbiAgICBjb25zdCBtZXRob2QgPSBhY3Rpb24gPT09ICdjcmVhdGUnID8gJ1BPU1QnIFxyXG4gICAgICA6IGFjdGlvbiA9PT0gJ3VwZGF0ZScgPyAnUEFUQ0gnIFxyXG4gICAgICA6IGFjdGlvbiA9PT0gJ2RlbGV0ZScgPyAnREVMRVRFJ1xyXG4gICAgICA6ICdQQVRDSCc7IC8vIHJlc3RvcmUgdXNlcyBQQVRDSFxyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XHJcbiAgICAgIG1ldGhvZCxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgIGJvZHk6IGFjdGlvbiAhPT0gJ2RlbGV0ZScgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgW1N0b3JlIEZhY3RvcnkgQVBJXSAke2FjdGlvbn0gZmFpbGVkIGZvciAke2FwaUVuZHBvaW50fTpgLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLm9rO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBbU3RvcmUgRmFjdG9yeSBBUEldICR7YWN0aW9ufSBlcnJvciBmb3IgJHthcGlFbmRwb2ludH06YCwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSXRlbSB3aXRoIFN5c3RlbUlkIChicmFuZGVkIHR5cGUpXHJcbmV4cG9ydCB0eXBlIEl0ZW1XaXRoU3lzdGVtSWQgPSB7IHN5c3RlbUlkOiBTeXN0ZW1JZDsgW2tleTogc3RyaW5nXTogYW55IH07XHJcblxyXG4vLyDinIUgQ291bnRlciBzdGF0ZSBmb3IgSUQgZ2VuZXJhdGlvblxyXG5leHBvcnQgdHlwZSBDb3VudGVyU3RhdGUgPSB7XHJcbiAgc3lzdGVtSWQ6IG51bWJlcjtcclxuICBidXNpbmVzc0lkOiBudW1iZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDcnVkU3RhdGU8VCBleHRlbmRzIEl0ZW1XaXRoU3lzdGVtSWQ+ID0ge1xyXG4gIGRhdGE6IFRbXTtcclxuICBfY291bnRlcnM6IENvdW50ZXJTdGF0ZTsgLy8g4pyFIFBlcnNpc3RlZCBjb3VudGVyc1xyXG4gIF9pbml0aWFsaXplZDogYm9vbGVhbjsgLy8g4pyFIFRyYWNrIGlmIGxvYWRlZCBmcm9tIEFQSVxyXG4gIGFkZDogKGl0ZW06IE9taXQ8VCwgJ3N5c3RlbUlkJz4pID0+IFQ7XHJcbiAgYWRkTXVsdGlwbGU6IChpdGVtczogT21pdDxULCAnc3lzdGVtSWQnPltdKSA9PiB2b2lkO1xyXG4gIHVwZGF0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgaXRlbTogUGFydGlhbDxUPikgPT4gdm9pZDsgLy8g4pyFIEFjY2VwdCBwYXJ0aWFsIHVwZGF0ZXNcclxuICByZW1vdmU6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHZvaWQ7IC8vIOKchSBCcmFuZGVkIHR5cGVcclxuICBoYXJkRGVsZXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB2b2lkOyAvLyDinIUgQnJhbmRlZCB0eXBlXHJcbiAgcmVzdG9yZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gdm9pZDsgLy8g4pyFIEJyYW5kZWQgdHlwZVxyXG4gIGZpbmRCeUlkOiAoc3lzdGVtSWQ6IFN5c3RlbUlkIHwgc3RyaW5nKSA9PiBUIHwgdW5kZWZpbmVkOyAvLyDinIUgQnJhbmRlZCB0eXBlXHJcbiAgZ2V0QWN0aXZlOiAoKSA9PiBUW107XHJcbiAgZ2V0RGVsZXRlZDogKCkgPT4gVFtdO1xyXG4gIGxvYWRGcm9tQVBJOiAoKSA9PiBQcm9taXNlPHZvaWQ+OyAvLyDinIUgTG9hZCBkYXRhIGZyb20gZGF0YWJhc2VcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDcnVkU3RvcmUgPSA8VCBleHRlbmRzIEl0ZW1XaXRoU3lzdGVtSWQ+KFxyXG4gIF9pbml0aWFsRGF0YTogVFtdLCAvLyBAZGVwcmVjYXRlZCAtIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYnV0IE5PIExPTkdFUiBVU0VEXHJcbiAgZW50aXR5VHlwZTogRW50aXR5VHlwZSwgLy8gQ2hhbmdlZCBmcm9tIGlkUHJlZml4IHRvIGVudGl0eVR5cGVcclxuICBvcHRpb25zPzoge1xyXG4gICAgYnVzaW5lc3NJZEZpZWxkPzoga2V5b2YgVDsgLy8gRmllbGQgbmFtZSBmb3IgYnVzaW5lc3MgSUQgKGRlZmF1bHQ6ICdpZCcpXHJcbiAgICBwZXJzaXN0S2V5Pzogc3RyaW5nOyAvLyBAZGVwcmVjYXRlZCAtIE5vIGxvbmdlciB1c2VkLCBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbiAgICBnZXRDdXJyZW50VXNlcj86ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDsgLy8gRnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgdXNlciBzeXN0ZW1JZFxyXG4gICAgYXBpRW5kcG9pbnQ/OiBzdHJpbmc7IC8vIOKchSBBUEkgZW5kcG9pbnQgZm9yIGRhdGFiYXNlIHN5bmMgKGUuZy4sICcvYXBpL2VtcGxveWVlcycpXHJcbiAgfVxyXG4pID0+IHtcclxuICBjb25zdCBidXNpbmVzc1ByZWZpeCA9IGdldFByZWZpeChlbnRpdHlUeXBlKTsgLy8gVmlldG5hbWVzZSBwcmVmaXggZm9yIEJ1c2luZXNzIElEIChOViwgS0gsIERIKVxyXG4gIGNvbnN0IGNvbmZpZyA9IElEX0NPTkZJR1tlbnRpdHlUeXBlXTtcclxuICBjb25zdCBzeXN0ZW1JZFByZWZpeCA9IGNvbmZpZz8uc3lzdGVtSWRQcmVmaXggfHwgZW50aXR5VHlwZS50b1VwcGVyQ2FzZSgpOyAvLyBFbmdsaXNoIHByZWZpeCBmb3IgU3lzdGVtSWQgKEVNUCwgQ1VTVE9NRVIsIE9SREVSKVxyXG4gIFxyXG4gIGNvbnN0IGJ1c2luZXNzSWRGaWVsZCA9IG9wdGlvbnM/LmJ1c2luZXNzSWRGaWVsZCA/PyAnaWQnO1xyXG4gIC8vIGNvbnN0IHBlcnNpc3RLZXkgPSBvcHRpb25zPy5wZXJzaXN0S2V5OyAvLyBAZGVwcmVjYXRlZCAtIE5vIGxvbmdlciB1c2VkXHJcbiAgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBvcHRpb25zPy5nZXRDdXJyZW50VXNlcjtcclxuICBjb25zdCBhcGlFbmRwb2ludCA9IG9wdGlvbnM/LmFwaUVuZHBvaW50O1xyXG5cclxuICAvLyDinIUgQ0hBTkdFRDogU3RhcnQgd2l0aCBlbXB0eSBhcnJheSAtIGRhdGFiYXNlIGlzIHNvdXJjZSBvZiB0cnV0aFxyXG4gIC8vIE1vY2sgZGF0YSBmaWxlcyAoZGF0YS50cykgYXJlIE5PIExPTkdFUiBVU0VEIGZvciBydW50aW1lXHJcbiAgY29uc3Qgbm9ybWFsaXplZEluaXRpYWxEYXRhOiBUW10gPSBbXTtcclxuXHJcbiAgY29uc3Qgc3RvcmVDb25maWcgPSAoc2V0OiBhbnksIGdldDogYW55KSA9PiAoe1xyXG4gICAgZGF0YTogbm9ybWFsaXplZEluaXRpYWxEYXRhLCAvLyDinIUgU3RhcnQgZW1wdHkgLSBkYXRhIGxvYWRlZCB2aWEgUmVhY3QgUXVlcnlcclxuICAgIC8vIOKchSBQZXJzaXN0IGNvdW50ZXJzIGluIHN0YXRlICh3aWxsIGJlIHNhdmVkIHRvIGxvY2FsU3RvcmFnZSlcclxuICAgICAgX2NvdW50ZXJzOiB7XHJcbiAgICAgICAgc3lzdGVtSWQ6IGdldE1heFN5c3RlbUlkQ291bnRlcihub3JtYWxpemVkSW5pdGlhbERhdGEsIHN5c3RlbUlkUHJlZml4KSxcclxuICAgICAgICBidXNpbmVzc0lkOiBvcHRpb25zPy5idXNpbmVzc0lkRmllbGQgXHJcbiAgICAgICAgICA/IGdldE1heEJ1c2luZXNzSWRDb3VudGVyKG5vcm1hbGl6ZWRJbml0aWFsRGF0YSBhcyBhbnlbXSwgYnVzaW5lc3NQcmVmaXgpXHJcbiAgICAgICAgICA6IDBcclxuICAgIH0sXHJcbiAgICBfaW5pdGlhbGl6ZWQ6IGZhbHNlLCAvLyDinIUgVHJhY2sgQVBJIGluaXRpYWxpemF0aW9uXHJcbiAgICBhZGQ6IChpdGVtOiBPbWl0PFQsICdzeXN0ZW1JZCc+KTogVCA9PiB7XHJcbiAgICAgICAgLy8g4pyFIEdldCBjb3VudGVycyBmcm9tIHN0YXRlIChwZXJzaXN0ZWQpXHJcbiAgICAgICAgY29uc3QgY3VycmVudENvdW50ZXJzID0gZ2V0KCkuX2NvdW50ZXJzO1xyXG4gICAgICAgIGNvbnN0IG5ld1N5c3RlbUlkQ291bnRlciA9IGN1cnJlbnRDb3VudGVycy5zeXN0ZW1JZCArIDE7XHJcbiAgICAgICAgY29uc3QgbmV3U3lzdGVtSWQgPSBjcmVhdGVTeXN0ZW1JZChnZW5lcmF0ZVN5c3RlbUlkKGVudGl0eVR5cGUsIG5ld1N5c3RlbUlkQ291bnRlcikpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEdlbmVyYXRlIG9yIHZhbGlkYXRlIEJ1c2luZXNzIElEIChpZiBmaWVsZCBleGlzdHMpXHJcbiAgICAgICAgbGV0IGZpbmFsSXRlbSA9IHsgLi4uaXRlbSB9IGFzIGFueTtcclxuICAgICAgICBsZXQgbmV3QnVzaW5lc3NJZENvdW50ZXIgPSBjdXJyZW50Q291bnRlcnMuYnVzaW5lc3NJZDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYnVzaW5lc3NJZEZpZWxkIGluIGl0ZW0pIHtcclxuICAgICAgICAgIGNvbnN0IGN1c3RvbUlkID0gKGl0ZW0gYXMgYW55KVtidXNpbmVzc0lkRmllbGRdO1xyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBnZXQoKS5kYXRhLm1hcCgoZDogYW55KSA9PiBkW2J1c2luZXNzSWRGaWVsZF0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyDinIUgSWYgY3VzdG9tSWQgcHJvdmlkZWQsIHZhbGlkYXRlIHVuaXF1ZW5lc3NcclxuICAgICAgICAgIGlmIChjdXN0b21JZCAmJiBjdXN0b21JZC50cmltKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0J1c2luZXNzSWRVbmlxdWUoY3VzdG9tSWQsIGV4aXN0aW5nSWRzKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTcOjIFwiJHtjdXN0b21JZH1cIiDEkcOjIHThu5NuIHThuqFpISBWdWkgbMOybmcgc+G7rSBk4bulbmcgbcOjIGtow6FjLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gY3VzdG9tSWQudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDinIUgQXV0by1nZW5lcmF0ZSB3aXRoIGZpbmROZXh0QXZhaWxhYmxlQnVzaW5lc3NJZFxyXG4gICAgICAgICAgICBjb25zdCBkaWdpdENvdW50ID0gNjsgLy8gQWxsIGVudGl0aWVzIHVzZSA2IGRpZ2l0c1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQoYnVzaW5lc3NQcmVmaXgsIGV4aXN0aW5nSWRzLCBuZXdCdXNpbmVzc0lkQ291bnRlciwgZGlnaXRDb3VudCk7XHJcbiAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gcmVzdWx0Lm5leHRJZDtcclxuICAgICAgICAgICAgbmV3QnVzaW5lc3NJZENvdW50ZXIgPSByZXN1bHQudXBkYXRlZENvdW50ZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGdldEN1cnJlbnRVc2VyPy4oKTtcclxuICAgICAgICBjb25zdCBuZXdJdGVtID0geyBcclxuICAgICAgICAgIC4uLmZpbmFsSXRlbSwgXHJcbiAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWQsIC8vIOKchSBCcmFuZGVkIFN5c3RlbUlkXHJcbiAgICAgICAgICBjcmVhdGVkQXQ6IGZpbmFsSXRlbS5jcmVhdGVkQXQgfHwgbm93LFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBub3csXHJcbiAgICAgICAgICBjcmVhdGVkQnk6IGZpbmFsSXRlbS5jcmVhdGVkQnkgfHwgY3VycmVudFVzZXIsXHJcbiAgICAgICAgICB1cGRhdGVkQnk6IGN1cnJlbnRVc2VyLFxyXG4gICAgICAgIH0gYXMgdW5rbm93biBhcyBUO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIOKchSBVcGRhdGUgYm90aCBkYXRhIGFuZCBjb3VudGVycyBhdG9taWNhbGx5XHJcbiAgICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoeyBcclxuICAgICAgICAgIGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCBuZXdJdGVtXSxcclxuICAgICAgICAgIF9jb3VudGVyczoge1xyXG4gICAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICAgICAgICBidXNpbmVzc0lkOiBuZXdCdXNpbmVzc0lkQ291bnRlclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDinIUgU3luYyB0byBBUEkgaW4gYmFja2dyb3VuZFxyXG4gICAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAnY3JlYXRlJywgbmV3SXRlbSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBuZXdJdGVtO1xyXG4gICAgfSxcclxuICAgIGFkZE11bHRpcGxlOiAoaXRlbXM6IE9taXQ8VCwgJ3N5c3RlbUlkJz5bXSkgPT4gXHJcbiAgICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFVzZXIgPSBnZXRDdXJyZW50VXNlcj8uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zOiBUW10gPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZGlnaXRDb3VudCA9IDY7IC8vIEFsbCBlbnRpdGllcyB1c2UgNiBkaWdpdHNcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBTdGFydCBmcm9tIGN1cnJlbnQgY291bnRlcnNcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIgPSBzdGF0ZS5fY291bnRlcnMuc3lzdGVtSWQ7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIgPSBzdGF0ZS5fY291bnRlcnMuYnVzaW5lc3NJZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyDinIUgR2VuZXJhdGUgU3lzdGVtSWQgZnJvbSBjdXJyZW50IGNvdW50ZXJcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N5c3RlbUlkID0gY3JlYXRlU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZChlbnRpdHlUeXBlLCBjdXJyZW50U3lzdGVtSWRDb3VudGVyKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG9yIHZhbGlkYXRlIEJ1c2luZXNzIElEIChpZiBmaWVsZCBleGlzdHMpXHJcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxJdGVtID0geyAuLi5pdGVtIH0gYXMgYW55O1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1c2luZXNzSWRGaWVsZCBpbiBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbUlkID0gKGl0ZW0gYXMgYW55KVtidXNpbmVzc0lkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBleGlzdGluZyBJRHMgKGZyb20gc3RhdGUgKyBhbHJlYWR5IGFkZGVkIGluIHRoaXMgYmF0Y2gpXHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmRhdGEubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SXRlbXMubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSlcclxuICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIOKchSBJZiBjdXN0b21JZCBwcm92aWRlZCwgdmFsaWRhdGUgdW5pcXVlbmVzc1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tSWQgJiYgY3VzdG9tSWQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0J1c2luZXNzSWRVbmlxdWUoY3VzdG9tSWQsIGV4aXN0aW5nSWRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNw6MgXCIke2N1c3RvbUlkfVwiIMSRw6MgdOG7k24gdOG6oWkhIFZ1aSBsw7JuZyBz4butIGThu6VuZyBtw6Mga2jDoWMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gY3VzdG9tSWQudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g4pyFIEF1dG8tZ2VuZXJhdGUgd2l0aCBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQoYnVzaW5lc3NQcmVmaXgsIGV4aXN0aW5nSWRzLCBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIsIGRpZ2l0Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gcmVzdWx0Lm5leHRJZDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIgPSByZXN1bHQudXBkYXRlZENvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaCh7IFxyXG4gICAgICAgICAgICAgICAgICAuLi5maW5hbEl0ZW0sIFxyXG4gICAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5vdyxcclxuICAgICAgICAgICAgICAgICAgY3JlYXRlZEJ5OiBjdXJyZW50VXNlcixcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlZEJ5OiBjdXJyZW50VXNlcixcclxuICAgICAgICAgICAgICAgIH0gYXMgdW5rbm93biBhcyBUKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGJvdGggZGF0YSBhbmQgY291bnRlcnNcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBcclxuICAgICAgICAgICAgICBkYXRhOiBbLi4uc3RhdGUuZGF0YSwgLi4ubmV3SXRlbXNdLFxyXG4gICAgICAgICAgICAgIF9jb3VudGVyczoge1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtSWQ6IGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0lkOiBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgU3luYyB0byBBUEkgaW4gYmFja2dyb3VuZCAoYmF0Y2gpXHJcbiAgICAgICAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgICAgICAgIG5ld0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jVG9BUEkoYXBpRW5kcG9pbnQsICdjcmVhdGUnLCBpdGVtKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KSxcclxuICAgIHVwZGF0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdXBkYXRlZEl0ZW06IFBhcnRpYWw8VD4pID0+IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdW5pcXVlIGJ1c2luZXNzIElEIChjYXNlLWluc2Vuc2l0aXZlLCBza2lwIHNlbGYpXHJcbiAgICAgIGlmIChidXNpbmVzc0lkRmllbGQgaW4gdXBkYXRlZEl0ZW0pIHtcclxuICAgICAgICBjb25zdCBidXNpbmVzc0lkID0gKHVwZGF0ZWRJdGVtIGFzIGFueSlbYnVzaW5lc3NJZEZpZWxkXTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IGdldCgpLmRhdGFcclxuICAgICAgICAgIC5maWx0ZXIoKGQ6IGFueSkgPT4gZC5zeXN0ZW1JZCAhPT0gc3lzdGVtSWQpXHJcbiAgICAgICAgICAubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJ1c2luZXNzSWQgJiYgIWlzQnVzaW5lc3NJZFVuaXF1ZShidXNpbmVzc0lkLCBleGlzdGluZ0lkcykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTcOjIFwiJHtidXNpbmVzc0lkfVwiIMSRw6MgdOG7k24gdOG6oWkhIFZ1aSBsw7JuZyBz4butIGThu6VuZyBtw6Mga2jDoWMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gZ2V0Q3VycmVudFVzZXI/LigpO1xyXG4gICAgICBzZXQoKHN0YXRlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoKGl0ZW06IFQpID0+XHJcbiAgICAgICAgICBpdGVtLnN5c3RlbUlkID09PSBzeXN0ZW1JZCBcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIC4uLnVwZGF0ZWRJdGVtLCB1cGRhdGVkQXQ6IG5vdywgdXBkYXRlZEJ5OiBjdXJyZW50VXNlciB9IGFzIFRcclxuICAgICAgICAgICAgOiBpdGVtXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgZnVsbEl0ZW0gPSBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IHN5c3RlbUlkKTtcclxuICAgICAgICBpZiAoZnVsbEl0ZW0pIHtcclxuICAgICAgICAgIHN5bmNUb0FQSShhcGlFbmRwb2ludCwgJ3VwZGF0ZScsIGZ1bGxJdGVtLCBzeXN0ZW1JZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFNvZnQgZGVsZXRlIC0gbWFyayBhcyBkZWxldGVkXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKChpdGVtOiBUKSA9PlxyXG4gICAgICAgICAgaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWRcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIGlzRGVsZXRlZDogdHJ1ZSwgZGVsZXRlZEF0OiBub3cgfSBhcyBUXHJcbiAgICAgICAgICAgIDogaXRlbVxyXG4gICAgICAgICksXHJcbiAgICAgIH0pKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOKchSBTeW5jIHRvIEFQSSBpbiBiYWNrZ3JvdW5kXHJcbiAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IHN5c3RlbUlkKTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAndXBkYXRlJywgeyAuLi5pdGVtLCBpc0RlbGV0ZWQ6IHRydWUsIGRlbGV0ZWRBdDogbm93IH0sIHN5c3RlbUlkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoYXJkRGVsZXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFBlcm1hbmVudCBkZWxldGUgLSByZW1vdmUgZnJvbSBhcnJheVxyXG4gICAgICBzZXQoKHN0YXRlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5maWx0ZXIoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgIT09IHN5c3RlbUlkKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAnZGVsZXRlJywgeyBzeXN0ZW1JZCB9LCBzeXN0ZW1JZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZXN0b3JlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFJlc3RvcmUgc29mdC1kZWxldGVkIGl0ZW1cclxuICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKChpdGVtOiBUKSA9PlxyXG4gICAgICAgICAgaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWRcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIGlzRGVsZXRlZDogZmFsc2UsIGRlbGV0ZWRBdDogbnVsbCB9IGFzIFRcclxuICAgICAgICAgICAgOiBpdGVtXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldCgpLmRhdGEuZmluZCgoaXRlbTogVCkgPT4gaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpO1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoYXBpRW5kcG9pbnQsICdyZXN0b3JlJywgeyAuLi5pdGVtLCBpc0RlbGV0ZWQ6IGZhbHNlLCBkZWxldGVkQXQ6IG51bGwgfSwgc3lzdGVtSWQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldEFjdGl2ZTogKCkgPT4gZ2V0KCkuZGF0YS5maWx0ZXIoKGl0ZW06IGFueSkgPT4gIWl0ZW0uaXNEZWxldGVkKSxcclxuICAgIGdldERlbGV0ZWQ6ICgpID0+IGdldCgpLmRhdGEuZmlsdGVyKChpdGVtOiBhbnkpID0+IGl0ZW0uaXNEZWxldGVkKSxcclxuICAgIGZpbmRCeUlkOiAoaWQ6IFN5c3RlbUlkIHwgc3RyaW5nKSA9PiBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IGlkIHx8IChpdGVtIGFzIGFueSkuaWQgPT09IGlkKSxcclxuICAgIFxyXG4gICAgLy8g4pyFIExvYWQgZGF0YSBmcm9tIGRhdGFiYXNlIEFQSSAtIE9QVElNSVpFRDogTm8gbW9yZSBsaW1pdD0xMDAwMCFcclxuICAgIC8vIFRoaXMgaXMgbm93IG9ubHkgdXNlZCBmb3IgY291bnRlciBpbml0aWFsaXphdGlvbiwgTk9UIGZvciBsb2FkaW5nIGFsbCBkYXRhXHJcbiAgICAvLyBVc2UgUmVhY3QgUXVlcnkgaG9va3MgZm9yIGRhdGEgZmV0Y2hpbmcgd2l0aCBwcm9wZXIgcGFnaW5hdGlvblxyXG4gICAgbG9hZEZyb21BUEk6IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKCFhcGlFbmRwb2ludCkgcmV0dXJuO1xyXG4gICAgICBpZiAoZ2V0KCkuX2luaXRpYWxpemVkKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIE9ubHkgZmV0Y2ggbWluaW1hbCBkYXRhIG5lZWRlZCB0byBpbml0aWFsaXplIGNvdW50ZXJzXHJcbiAgICAgICAgLy8gQWN0dWFsIGRhdGEgbG9hZGluZyBzaG91bGQgYmUgZG9uZSB2aWEgUmVhY3QgUXVlcnkgaG9va3NcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2FwaUVuZHBvaW50fT9saW1pdD0xJnNvcnRCeT1zeXN0ZW1JZCZzb3J0T3JkZXI9ZGVzY2AsIHtcclxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IGpzb24ucGFnaW5hdGlvbiB8fCB7fTtcclxuICAgICAgICAgIGNvbnN0IGxhc3RJdGVtID0ganNvbi5kYXRhPy5bMF07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEluaXRpYWxpemUgY291bnRlcnMgZnJvbSB0aGUgbGF0ZXN0IGl0ZW0gKGhpZ2hlc3QgSURzKVxyXG4gICAgICAgICAgY29uc3QgbmV3Q291bnRlcnMgPSB7XHJcbiAgICAgICAgICAgIHN5c3RlbUlkOiBsYXN0SXRlbSA/IGdldE1heFN5c3RlbUlkQ291bnRlcihbbGFzdEl0ZW1dLCBzeXN0ZW1JZFByZWZpeCkgOiAwLFxyXG4gICAgICAgICAgICBidXNpbmVzc0lkOiAobGFzdEl0ZW0gJiYgb3B0aW9ucz8uYnVzaW5lc3NJZEZpZWxkKVxyXG4gICAgICAgICAgICAgID8gZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIoW2xhc3RJdGVtXSBhcyBhbnlbXSwgYnVzaW5lc3NQcmVmaXgpXHJcbiAgICAgICAgICAgICAgOiAwXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzZXQoeyBcclxuICAgICAgICAgICAgZGF0YTogW10sIC8vIERvbid0IHN0b3JlIGRhdGEgaW4gWnVzdGFuZCBhbnltb3JlIC0gdXNlIFJlYWN0IFF1ZXJ5XHJcbiAgICAgICAgICAgIF9jb3VudGVyczogbmV3Q291bnRlcnMsXHJcbiAgICAgICAgICAgIF9pbml0aWFsaXplZDogdHJ1ZSBcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1N0b3JlIEZhY3RvcnldICR7YXBpRW5kcG9pbnR9IGluaXRpYWxpemVkLiBUb3RhbCByZWNvcmRzOiAke3BhZ2luYXRpb24udG90YWwgfHwgJ3Vua25vd24nfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBbU3RvcmUgRmFjdG9yeV0gbG9hZEZyb21BUEkgZXJyb3IgZm9yICR7YXBpRW5kcG9pbnR9OmAsIGVycm9yKTtcclxuICAgICAgICAvLyBTdGlsbCBtYXJrIGFzIGluaXRpYWxpemVkIHRvIHByZXZlbnQgaW5maW5pdGUgcmV0cnlcclxuICAgICAgICBzZXQoeyBfaW5pdGlhbGl6ZWQ6IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIOKchSBTSU1QTElGSUVEOiBObyBsb2NhbFN0b3JhZ2UgcGVyc2lzdGVuY2UsIGRhdGFiYXNlIGlzIHNvdXJjZSBvZiB0cnV0aFxyXG4gIC8vIERhdGEgaXMgbG9hZGVkIHZpYSBBcGlTeW5jUHJvdmlkZXIgb24gYXBwIGluaXRcclxuICByZXR1cm4gY3JlYXRlPENydWRTdGF0ZTxUPj4oc3RvcmVDb25maWcpO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiZ2VuZXJhdGVTeXN0ZW1JZCIsImlzQnVzaW5lc3NJZFVuaXF1ZSIsImdldE1heFN5c3RlbUlkQ291bnRlciIsImdldE1heEJ1c2luZXNzSWRDb3VudGVyIiwiZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkIiwiZ2V0UHJlZml4IiwiSURfQ09ORklHIiwiY3JlYXRlU3lzdGVtSWQiLCJTWVNURU1fRkFMTEJBQ0tfSUQiLCJhc1N5c3RlbUlkRmFsbGJhY2siLCJzeW5jVG9BUEkiLCJhcGlFbmRwb2ludCIsImFjdGlvbiIsImRhdGEiLCJzeXN0ZW1JZCIsImVuZHBvaW50IiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJjcmVkZW50aWFscyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwib2siLCJjb25zb2xlIiwid2FybiIsInN0YXR1cyIsImVycm9yIiwiY3JlYXRlQ3J1ZFN0b3JlIiwiX2luaXRpYWxEYXRhIiwiZW50aXR5VHlwZSIsIm9wdGlvbnMiLCJidXNpbmVzc1ByZWZpeCIsImNvbmZpZyIsInN5c3RlbUlkUHJlZml4IiwidG9VcHBlckNhc2UiLCJidXNpbmVzc0lkRmllbGQiLCJnZXRDdXJyZW50VXNlciIsIm5vcm1hbGl6ZWRJbml0aWFsRGF0YSIsInN0b3JlQ29uZmlnIiwic2V0IiwiZ2V0IiwiX2NvdW50ZXJzIiwiYnVzaW5lc3NJZCIsIl9pbml0aWFsaXplZCIsImFkZCIsIml0ZW0iLCJjdXJyZW50Q291bnRlcnMiLCJuZXdTeXN0ZW1JZENvdW50ZXIiLCJuZXdTeXN0ZW1JZCIsImZpbmFsSXRlbSIsIm5ld0J1c2luZXNzSWRDb3VudGVyIiwiY3VzdG9tSWQiLCJleGlzdGluZ0lkcyIsIm1hcCIsImQiLCJ0cmltIiwiRXJyb3IiLCJkaWdpdENvdW50IiwicmVzdWx0IiwibmV4dElkIiwidXBkYXRlZENvdW50ZXIiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJjdXJyZW50VXNlciIsIm5ld0l0ZW0iLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJjcmVhdGVkQnkiLCJ1cGRhdGVkQnkiLCJzdGF0ZSIsImNhdGNoIiwiYWRkTXVsdGlwbGUiLCJpdGVtcyIsIm5ld0l0ZW1zIiwiY3VycmVudFN5c3RlbUlkQ291bnRlciIsImN1cnJlbnRCdXNpbmVzc0lkQ291bnRlciIsImZvckVhY2giLCJwdXNoIiwidXBkYXRlIiwidXBkYXRlZEl0ZW0iLCJmaWx0ZXIiLCJmdWxsSXRlbSIsImZpbmQiLCJyZW1vdmUiLCJpc0RlbGV0ZWQiLCJkZWxldGVkQXQiLCJoYXJkRGVsZXRlIiwicmVzdG9yZSIsImdldEFjdGl2ZSIsImdldERlbGV0ZWQiLCJmaW5kQnlJZCIsImlkIiwibG9hZEZyb21BUEkiLCJqc29uIiwicGFnaW5hdGlvbiIsImxhc3RJdGVtIiwibmV3Q291bnRlcnMiLCJsb2ciLCJ0b3RhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/store-factory.ts\n"));

/***/ })

});