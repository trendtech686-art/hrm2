"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/employees/page",{

/***/ "(app-pages-browser)/./features/customers/store.ts":
/*!*************************************!*\
  !*** ./features/customers/store.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCustomerStore: () => (/* binding */ useCustomerStore)\n/* harmony export */ });\n/* harmony import */ var _lib_store_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/store-factory */ \"(app-pages-browser)/./lib/store-factory.ts\");\n/* harmony import */ var _lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle-utils */ \"(app-pages-browser)/./features/customers/lifecycle-utils.ts\");\n/* harmony import */ var _credit_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./credit-utils */ \"(app-pages-browser)/./features/customers/credit-utils.ts\");\n/* harmony import */ var _intelligence_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./intelligence-utils */ \"(app-pages-browser)/./features/customers/intelligence-utils.ts\");\n/* harmony import */ var _debt_tracking_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debt-tracking-utils */ \"(app-pages-browser)/./features/customers/debt-tracking-utils.ts\");\n/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fuse.js */ \"(app-pages-browser)/./node_modules/fuse.js/dist/fuse.mjs\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n/* harmony import */ var _lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/activity-history-helper */ \"(app-pages-browser)/./lib/activity-history-helper.ts\");\n\n\n\n\n\n\n\n\nconst baseStore = (0,_lib_store_factory__WEBPACK_IMPORTED_MODULE_0__.createCrudStore)([], 'customers', {\n    businessIdField: 'id',\n    getCurrentUser: _contexts_auth_context__WEBPACK_IMPORTED_MODULE_5__.getCurrentUserSystemId,\n    apiEndpoint: '/api/customers'\n});\n// ✅ API Sync helpers\nconst API_ENDPOINT = '/api/customers';\nconst syncToApi = {\n    create: async (customer)=>{\n        try {\n            const response = await fetch(API_ENDPOINT, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(customer)\n            });\n            if (!response.ok) console.warn('[Customer API] Create sync failed');\n            else console.log('[Customer API] Created:', customer.systemId);\n        } catch (e) {\n            console.warn('[Customer API] Create sync error:', e);\n        }\n    },\n    update: async (systemId, updates)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'PATCH',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(updates)\n            });\n            if (!response.ok) console.warn('[Customer API] Update sync failed');\n            else console.log('[Customer API] Updated:', systemId);\n        } catch (e) {\n            console.warn('[Customer API] Update sync error:', e);\n        }\n    },\n    delete: async (systemId, hard = false)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'DELETE',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    hard\n                })\n            });\n            if (!response.ok) console.warn('[Customer API] Delete sync failed');\n            else console.log('[Customer API] Deleted:', systemId);\n        } catch (e) {\n            console.warn('[Customer API] Delete sync error:', e);\n        }\n    },\n    restore: async (systemId)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}/restore`, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) console.warn('[Customer API] Restore sync failed');\n            else console.log('[Customer API] Restored:', systemId);\n        } catch (e) {\n            console.warn('[Customer API] Restore sync error:', e);\n        }\n    }\n};\n// ✅ Wrap base store methods with API sync\nconst originalAdd = baseStore.getState().add;\nconst originalUpdate = baseStore.getState().update;\nconst originalRemove = baseStore.getState().remove;\nconst originalHardDelete = baseStore.getState().hardDelete;\nconst originalRestore = baseStore.getState().restore;\nbaseStore.setState({\n    add: (item)=>{\n        const result = originalAdd(item);\n        syncToApi.create(result);\n        return result;\n    },\n    update: (systemId, updates)=>{\n        originalUpdate(systemId, updates);\n        syncToApi.update(systemId, updates);\n    },\n    remove: (systemId)=>{\n        originalRemove(systemId);\n        syncToApi.delete(systemId, false);\n    },\n    hardDelete: (systemId)=>{\n        originalHardDelete(systemId);\n        syncToApi.delete(systemId, true);\n    },\n    restore: (systemId)=>{\n        originalRestore(systemId);\n        syncToApi.restore(systemId);\n    }\n});\n// Augmented methods\nconst augmentedMethods = {\n    searchCustomers: async (query, page, limit = 20)=>{\n        return new Promise((resolve)=>{\n            setTimeout(()=>{\n                const allCustomers = baseStore.getState().data;\n                // Create fresh Fuse instance with current data (avoid stale data)\n                const fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](allCustomers, {\n                    keys: [\n                        'name',\n                        'id',\n                        'phone'\n                    ],\n                    threshold: 0.3\n                });\n                const results = query ? fuse.search(query).map((r)=>r.item) : allCustomers;\n                const start = (page - 1) * limit;\n                const end = start + limit;\n                const paginatedItems = results.slice(start, end);\n                resolve({\n                    items: paginatedItems.map((c)=>({\n                            value: c.systemId,\n                            label: c.name\n                        })),\n                    hasNextPage: end < results.length\n                });\n            }, 300);\n        });\n    },\n    updateDebt: (systemId, amountChange)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        const newDebt = (customer.currentDebt || 0) + amountChange;\n                        // Sync to API\n                        syncToApi.update(systemId, {\n                            currentDebt: newDebt\n                        });\n                        return {\n                            ...customer,\n                            currentDebt: newDebt\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    incrementOrderStats: (systemId, orderValue)=>{\n        const allCustomers = baseStore.getState().getActive();\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        const updatedCustomer = {\n                            ...customer,\n                            totalOrders: (customer.totalOrders || 0) + 1,\n                            totalSpent: (customer.totalSpent || 0) + orderValue,\n                            lastPurchaseDate: new Date().toISOString().split('T')[0]\n                        };\n                        // Auto-update intelligence after order stats change\n                        const rfmScores = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateRFMScores)(updatedCustomer, allCustomers);\n                        const segment = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.getCustomerSegment)(rfmScores);\n                        const healthScore = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateHealthScore)(updatedCustomer);\n                        const churnRisk = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateChurnRisk)(updatedCustomer).risk;\n                        const lifecycleStage = (0,_lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__.calculateLifecycleStage)(updatedCustomer);\n                        return {\n                            ...updatedCustomer,\n                            rfmScores,\n                            segment,\n                            healthScore,\n                            churnRisk,\n                            lifecycleStage\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    decrementOrderStats: (systemId, orderValue)=>{\n        const allCustomers = baseStore.getState().getActive();\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        const updatedCustomer = {\n                            ...customer,\n                            totalOrders: Math.max(0, (customer.totalOrders || 0) - 1),\n                            totalSpent: Math.max(0, (customer.totalSpent || 0) - orderValue)\n                        };\n                        // Auto-update intelligence after order stats change\n                        const rfmScores = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateRFMScores)(updatedCustomer, allCustomers);\n                        const segment = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.getCustomerSegment)(rfmScores);\n                        const healthScore = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateHealthScore)(updatedCustomer);\n                        const churnRisk = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateChurnRisk)(updatedCustomer).risk;\n                        const lifecycleStage = (0,_lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__.calculateLifecycleStage)(updatedCustomer);\n                        return {\n                            ...updatedCustomer,\n                            rfmScores,\n                            segment,\n                            healthScore,\n                            churnRisk,\n                            lifecycleStage\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    incrementReturnStats: (systemId, quantity)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        return {\n                            ...customer,\n                            totalQuantityReturned: (customer.totalQuantityReturned || 0) + quantity\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    incrementFailedDeliveryStats: (systemId)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        return {\n                            ...customer,\n                            failedDeliveries: (customer.failedDeliveries || 0) + 1\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    addDebtTransaction: (systemId, transaction)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        const currentTransactions = customer.debtTransactions || [];\n                        // Avoid duplicates\n                        if (currentTransactions.some((t)=>t.orderId === transaction.orderId)) {\n                            return customer;\n                        }\n                        const outstandingAmount = Math.max(transaction.remainingAmount ?? transaction.amount ?? 0, 0);\n                        return {\n                            ...customer,\n                            currentDebt: Math.max(0, (customer.currentDebt || 0) + outstandingAmount),\n                            debtTransactions: [\n                                ...currentTransactions,\n                                transaction\n                            ]\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    updateDebtTransactionPayment: (systemId, orderId, amountPaid)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId && customer.debtTransactions) {\n                        let debtDelta = 0;\n                        const updatedTransactions = customer.debtTransactions.map((t)=>{\n                            if (t.orderId !== orderId) {\n                                return t;\n                            }\n                            const currentPaid = t.paidAmount || 0;\n                            const currentRemaining = t.remainingAmount ?? Math.max(t.amount - currentPaid, 0);\n                            let appliedAmount = amountPaid;\n                            if (appliedAmount > 0) {\n                                appliedAmount = Math.min(appliedAmount, currentRemaining);\n                            } else if (appliedAmount < 0) {\n                                appliedAmount = Math.max(appliedAmount, -currentPaid);\n                            }\n                            const newPaidAmount = currentPaid + appliedAmount;\n                            const recalculatedRemaining = Math.max(t.amount - newPaidAmount, 0);\n                            debtDelta -= appliedAmount;\n                            return {\n                                ...t,\n                                paidAmount: newPaidAmount,\n                                remainingAmount: recalculatedRemaining,\n                                isPaid: recalculatedRemaining <= 0,\n                                paidDate: recalculatedRemaining <= 0 ? new Date().toISOString().split('T')[0] : t.paidDate\n                            };\n                        });\n                        return {\n                            ...customer,\n                            currentDebt: Math.max(0, (customer.currentDebt || 0) + debtDelta),\n                            debtTransactions: updatedTransactions\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    removeDebtTransaction: (systemId, orderId)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId && customer.debtTransactions) {\n                        const transaction = customer.debtTransactions.find((t)=>t.orderId === orderId);\n                        const outstanding = transaction ? Math.max(transaction.remainingAmount ?? transaction.amount - (transaction.paidAmount || 0), 0) : 0;\n                        return {\n                            ...customer,\n                            currentDebt: Math.max(0, (customer.currentDebt || 0) - outstanding),\n                            debtTransactions: customer.debtTransactions.filter((t)=>t.orderId !== orderId)\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    // Add debt reminder (3.3)\n    addDebtReminder: (systemId, reminder)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId) {\n                        const currentReminders = customer.debtReminders || [];\n                        return {\n                            ...customer,\n                            debtReminders: [\n                                ...currentReminders,\n                                reminder\n                            ]\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    // Update debt reminder (3.3)\n    updateDebtReminder: (systemId, reminderId, updates)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId && customer.debtReminders) {\n                        return {\n                            ...customer,\n                            debtReminders: customer.debtReminders.map((r)=>r.systemId === reminderId ? {\n                                    ...r,\n                                    ...updates\n                                } : r)\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    // Remove debt reminder (3.3)\n    removeDebtReminder: (systemId, reminderId)=>{\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.systemId === systemId && customer.debtReminders) {\n                        return {\n                            ...customer,\n                            debtReminders: customer.debtReminders.filter((r)=>r.systemId !== reminderId)\n                        };\n                    }\n                    return customer;\n                })\n            }));\n    },\n    // Override add to auto-calculate lifecycle stage and log activity\n    add: (customer)=>{\n        const userInfo = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.getCurrentUserInfo)();\n        const customerWithLifecycle = {\n            ...customer,\n            lifecycleStage: (0,_lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__.calculateLifecycleStage)(customer)\n        };\n        const newCustomer = baseStore.getState().add(customerWithLifecycle);\n        // Add activity history entry\n        const historyEntry = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.createCreatedEntry)(userInfo, `${userInfo.name} đã tạo khách hàng ${newCustomer.name} (${newCustomer.id})`);\n        baseStore.getState().update(newCustomer.systemId, {\n            ...newCustomer,\n            activityHistory: [\n                historyEntry\n            ]\n        });\n        return newCustomer;\n    },\n    // Override update to auto-calculate lifecycle stage and log activity\n    update: (systemId, updatedCustomer)=>{\n        console.log('[CustomerStore] update called:', {\n            systemId,\n            updatedCustomer\n        });\n        const userInfo = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.getCurrentUserInfo)();\n        const existingCustomer = baseStore.getState().data.find((c)=>c.systemId === systemId);\n        const historyEntries = [];\n        if (existingCustomer) {\n            // Track status changes\n            if (existingCustomer.status !== updatedCustomer.status) {\n                historyEntries.push((0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.createStatusChangedEntry)(userInfo, existingCustomer.status, updatedCustomer.status, `${userInfo.name} đã đổi trạng thái từ \"${existingCustomer.status}\" sang \"${updatedCustomer.status}\"`));\n            }\n            // Track field changes\n            const fieldsToTrack = [\n                {\n                    key: 'name',\n                    label: 'Tên khách hàng'\n                },\n                {\n                    key: 'email',\n                    label: 'Email'\n                },\n                {\n                    key: 'phone',\n                    label: 'Số điện thoại'\n                },\n                {\n                    key: 'company',\n                    label: 'Công ty'\n                },\n                {\n                    key: 'taxCode',\n                    label: 'Mã số thuế'\n                },\n                {\n                    key: 'representative',\n                    label: 'Người đại diện'\n                },\n                {\n                    key: 'type',\n                    label: 'Loại khách hàng'\n                },\n                {\n                    key: 'customerGroup',\n                    label: 'Nhóm khách hàng'\n                },\n                {\n                    key: 'lifecycleStage',\n                    label: 'Giai đoạn vòng đời'\n                },\n                {\n                    key: 'maxDebt',\n                    label: 'Hạn mức công nợ'\n                },\n                {\n                    key: 'paymentTerms',\n                    label: 'Điều khoản thanh toán'\n                },\n                {\n                    key: 'creditRating',\n                    label: 'Xếp hạng tín dụng'\n                },\n                {\n                    key: 'pricingLevel',\n                    label: 'Mức giá'\n                },\n                {\n                    key: 'defaultDiscount',\n                    label: 'Chiết khấu mặc định'\n                },\n                {\n                    key: 'accountManagerId',\n                    label: 'Nhân viên phụ trách'\n                }\n            ];\n            const changes = [];\n            for (const field of fieldsToTrack){\n                const oldVal = existingCustomer[field.key];\n                const newVal = updatedCustomer[field.key];\n                if (oldVal !== newVal && !(oldVal === undefined && newVal === undefined)) {\n                    // Skip if it's the status field (already tracked above)\n                    if (field.key === 'status') continue;\n                    const oldDisplay = oldVal !== undefined && oldVal !== null && oldVal !== '' ? String(oldVal) : '(trống)';\n                    const newDisplay = newVal !== undefined && newVal !== null && newVal !== '' ? String(newVal) : '(trống)';\n                    changes.push(`${field.label}: ${oldDisplay} → ${newDisplay}`);\n                }\n            }\n            if (changes.length > 0) {\n                historyEntries.push((0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.createUpdatedEntry)(userInfo, `${userInfo.name} đã cập nhật: ${changes.join(', ')}`));\n            }\n        }\n        const customerWithLifecycle = {\n            ...updatedCustomer,\n            lifecycleStage: (0,_lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__.calculateLifecycleStage)(updatedCustomer),\n            activityHistory: (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_6__.appendHistoryEntry)(existingCustomer?.activityHistory, ...historyEntries)\n        };\n        console.log('[CustomerStore] Calling baseStore.update with:', customerWithLifecycle);\n        // Call the update function from baseStore directly\n        baseStore.getState().update(systemId, customerWithLifecycle);\n        console.log('[CustomerStore] State after update:', baseStore.getState().data.find((c)=>c.systemId === systemId));\n    },\n    // Get customers with high debt risk\n    getHighRiskDebtCustomers: ()=>{\n        const activeCustomers = baseStore.getState().getActive();\n        return (0,_credit_utils__WEBPACK_IMPORTED_MODULE_2__.getHighRiskDebtCustomers)(activeCustomers);\n    },\n    // Batch update customer intelligence (RFM, health score, churn risk)\n    updateCustomerIntelligence: ()=>{\n        const allCustomers = baseStore.getState().getActive();\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>{\n                    if (customer.isDeleted) return customer;\n                    // Calculate RFM\n                    const rfmScores = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateRFMScores)(customer, allCustomers);\n                    const segment = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.getCustomerSegment)(rfmScores);\n                    // Calculate health score\n                    const healthScore = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateHealthScore)(customer);\n                    // Calculate churn risk\n                    const churnRisk = (0,_intelligence_utils__WEBPACK_IMPORTED_MODULE_3__.calculateChurnRisk)(customer).risk;\n                    // Calculate lifecycle stage\n                    const lifecycleStage = (0,_lifecycle_utils__WEBPACK_IMPORTED_MODULE_1__.calculateLifecycleStage)(customer);\n                    return {\n                        ...customer,\n                        rfmScores,\n                        segment,\n                        healthScore,\n                        churnRisk,\n                        lifecycleStage\n                    };\n                })\n            }));\n    },\n    // Get customers by segment\n    getCustomersBySegment: (segment)=>{\n        return baseStore.getState().getActive().filter((c)=>c.segment === segment);\n    },\n    // Get customers with overdue debt\n    getOverdueDebtCustomers: ()=>{\n        const activeCustomers = baseStore.getState().getActive();\n        return (0,_debt_tracking_utils__WEBPACK_IMPORTED_MODULE_4__.getOverdueDebtCustomers)(activeCustomers);\n    },\n    // Get customers with debt due soon\n    getDueSoonCustomers: ()=>{\n        const activeCustomers = baseStore.getState().getActive();\n        return (0,_debt_tracking_utils__WEBPACK_IMPORTED_MODULE_4__.getDueSoonCustomers)(activeCustomers);\n    },\n    removeMany: (systemIds)=>{\n        if (!systemIds.length) return;\n        const deletedAtTimestamp = new Date().toISOString();\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>systemIds.includes(customer.systemId) ? {\n                        ...customer,\n                        isDeleted: true,\n                        deletedAt: deletedAtTimestamp\n                    } : customer)\n            }));\n    },\n    updateManyStatus: (systemIds, status)=>{\n        if (!systemIds.length) return;\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>systemIds.includes(customer.systemId) ? {\n                        ...customer,\n                        status\n                    } : customer)\n            }));\n    },\n    restoreMany: (systemIds)=>{\n        if (!systemIds.length) return;\n        baseStore.setState((state)=>({\n                data: state.data.map((customer)=>systemIds.includes(customer.systemId) ? {\n                        ...customer,\n                        isDeleted: false,\n                        deletedAt: null\n                    } : customer)\n            }));\n    }\n};\nlet cachedBaseState = null;\nlet cachedCombinedState = null;\nconst getCombinedState = (state)=>{\n    if (cachedBaseState !== state || !cachedCombinedState) {\n        cachedBaseState = state;\n        cachedCombinedState = {\n            ...state,\n            ...augmentedMethods\n        };\n    }\n    return cachedCombinedState;\n};\nconst boundStore = baseStore;\nconst useCustomerStore = (selector, equalityFn)=>{\n    if (selector) {\n        if (equalityFn) {\n            return boundStore((state)=>selector(getCombinedState(state)), equalityFn);\n        }\n        return boundStore((state)=>selector(getCombinedState(state)));\n    }\n    return boundStore((state)=>getCombinedState(state));\n};\nuseCustomerStore.getState = ()=>{\n    return getCombinedState(baseStore.getState());\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL2N1c3RvbWVycy9zdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDcUU7QUFJVDtBQUNGO0FBTTVCO0FBQ3VEO0FBQzFEO0FBQzBDO0FBUTFCO0FBRTNDLE1BQU1nQixZQUFZaEIsbUVBQWVBLENBQVcsRUFBRSxFQUFFLGFBQWE7SUFDM0RpQixpQkFBaUI7SUFDakJDLGdCQUFnQlIsMEVBQXNCQTtJQUN0Q1MsYUFBYTtBQUNmO0FBRUEscUJBQXFCO0FBQ3JCLE1BQU1DLGVBQWU7QUFFckIsTUFBTUMsWUFBWTtJQUNoQkMsUUFBUSxPQUFPQztRQUNiLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU1MLGNBQWM7Z0JBQ3pDTSxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNSO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDQyxTQUFTUSxFQUFFLEVBQUVDLFFBQVFDLElBQUksQ0FBQztpQkFDMUJELFFBQVFFLEdBQUcsQ0FBQywyQkFBMkJaLFNBQVNhLFFBQVE7UUFDL0QsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZKLFFBQVFDLElBQUksQ0FBQyxxQ0FBcUNHO1FBQ3BEO0lBQ0Y7SUFDQUMsUUFBUSxPQUFPRixVQUFvQkc7UUFDakMsSUFBSTtZQUNGLE1BQU1mLFdBQVcsTUFBTUMsTUFBTSxHQUFHTCxhQUFhLENBQUMsRUFBRWdCLFVBQVUsRUFBRTtnQkFDMURWLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ1E7WUFDdkI7WUFDQSxJQUFJLENBQUNmLFNBQVNRLEVBQUUsRUFBRUMsUUFBUUMsSUFBSSxDQUFDO2lCQUMxQkQsUUFBUUUsR0FBRyxDQUFDLDJCQUEyQkM7UUFDOUMsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZKLFFBQVFDLElBQUksQ0FBQyxxQ0FBcUNHO1FBQ3BEO0lBQ0Y7SUFDQUcsUUFBUSxPQUFPSixVQUFvQkssT0FBTyxLQUFLO1FBQzdDLElBQUk7WUFDRixNQUFNakIsV0FBVyxNQUFNQyxNQUFNLEdBQUdMLGFBQWEsQ0FBQyxFQUFFZ0IsVUFBVSxFQUFFO2dCQUMxRFYsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFVTtnQkFBSztZQUM5QjtZQUNBLElBQUksQ0FBQ2pCLFNBQVNRLEVBQUUsRUFBRUMsUUFBUUMsSUFBSSxDQUFDO2lCQUMxQkQsUUFBUUUsR0FBRyxDQUFDLDJCQUEyQkM7UUFDOUMsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZKLFFBQVFDLElBQUksQ0FBQyxxQ0FBcUNHO1FBQ3BEO0lBQ0Y7SUFDQUssU0FBUyxPQUFPTjtRQUNkLElBQUk7WUFDRixNQUFNWixXQUFXLE1BQU1DLE1BQU0sR0FBR0wsYUFBYSxDQUFDLEVBQUVnQixTQUFTLFFBQVEsQ0FBQyxFQUFFO2dCQUNsRVYsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2hEO1lBQ0EsSUFBSSxDQUFDSixTQUFTUSxFQUFFLEVBQUVDLFFBQVFDLElBQUksQ0FBQztpQkFDMUJELFFBQVFFLEdBQUcsQ0FBQyw0QkFBNEJDO1FBQy9DLEVBQUUsT0FBT0MsR0FBRztZQUNWSixRQUFRQyxJQUFJLENBQUMsc0NBQXNDRztRQUNyRDtJQUNGO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDMUMsTUFBTU0sY0FBYzNCLFVBQVU0QixRQUFRLEdBQUdDLEdBQUc7QUFDNUMsTUFBTUMsaUJBQWlCOUIsVUFBVTRCLFFBQVEsR0FBR04sTUFBTTtBQUNsRCxNQUFNUyxpQkFBaUIvQixVQUFVNEIsUUFBUSxHQUFHSSxNQUFNO0FBQ2xELE1BQU1DLHFCQUFxQmpDLFVBQVU0QixRQUFRLEdBQUdNLFVBQVU7QUFDMUQsTUFBTUMsa0JBQWtCbkMsVUFBVTRCLFFBQVEsR0FBR0YsT0FBTztBQUVwRDFCLFVBQVVvQyxRQUFRLENBQUM7SUFDakJQLEtBQUssQ0FBQ1E7UUFDSixNQUFNQyxTQUFTWCxZQUFZVTtRQUMzQmhDLFVBQVVDLE1BQU0sQ0FBQ2dDO1FBQ2pCLE9BQU9BO0lBQ1Q7SUFDQWhCLFFBQVEsQ0FBQ0YsVUFBb0JHO1FBQzNCTyxlQUFlVixVQUFVRztRQUN6QmxCLFVBQVVpQixNQUFNLENBQUNGLFVBQVVHO0lBQzdCO0lBQ0FTLFFBQVEsQ0FBQ1o7UUFDUFcsZUFBZVg7UUFDZmYsVUFBVW1CLE1BQU0sQ0FBQ0osVUFBVTtJQUM3QjtJQUNBYyxZQUFZLENBQUNkO1FBQ1hhLG1CQUFtQmI7UUFDbkJmLFVBQVVtQixNQUFNLENBQUNKLFVBQVU7SUFDN0I7SUFDQU0sU0FBUyxDQUFDTjtRQUNSZSxnQkFBZ0JmO1FBQ2hCZixVQUFVcUIsT0FBTyxDQUFDTjtJQUNwQjtBQUNGO0FBMEJBLG9CQUFvQjtBQUNwQixNQUFNbUIsbUJBQW1CO0lBQ3JCQyxpQkFBaUIsT0FBT0MsT0FBZUMsTUFBY0MsUUFBZ0IsRUFBRTtRQUNuRSxPQUFPLElBQUlDLFFBQTZFQyxDQUFBQTtZQUNwRkMsV0FBVztnQkFDUCxNQUFNQyxlQUFlL0MsVUFBVTRCLFFBQVEsR0FBR29CLElBQUk7Z0JBRTlDLGtFQUFrRTtnQkFDbEUsTUFBTUMsT0FBTyxJQUFJeEQsK0NBQUlBLENBQUNzRCxjQUFjO29CQUNoQ0csTUFBTTt3QkFBQzt3QkFBUTt3QkFBTTtxQkFBUTtvQkFDN0JDLFdBQVc7Z0JBQ2Y7Z0JBRUEsTUFBTUMsVUFBVVgsUUFBUVEsS0FBS0ksTUFBTSxDQUFDWixPQUFPYSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVsQixJQUFJLElBQUlVO2dCQUU5RCxNQUFNUyxRQUFRLENBQUNkLE9BQU8sS0FBS0M7Z0JBQzNCLE1BQU1jLE1BQU1ELFFBQVFiO2dCQUNwQixNQUFNZSxpQkFBaUJOLFFBQVFPLEtBQUssQ0FBQ0gsT0FBT0M7Z0JBRTVDWixRQUFRO29CQUNKZSxPQUFPRixlQUFlSixHQUFHLENBQUNPLENBQUFBLElBQU07NEJBQUVDLE9BQU9ELEVBQUV6QyxRQUFROzRCQUFFMkMsT0FBT0YsRUFBRUcsSUFBSTt3QkFBQztvQkFDbkVDLGFBQWFSLE1BQU1MLFFBQVFjLE1BQU07Z0JBQ3JDO1lBQ0osR0FBRztRQUNQO0lBQ0o7SUFDQUMsWUFBWSxDQUFDL0MsVUFBb0JnRDtRQUM3QnBFLFVBQVVvQyxRQUFRLENBQUNpQyxDQUFBQSxRQUFVO2dCQUN6QnJCLE1BQU1xQixNQUFNckIsSUFBSSxDQUFDTSxHQUFHLENBQUMvQyxDQUFBQTtvQkFDakIsSUFBSUEsU0FBU2EsUUFBUSxLQUFLQSxVQUFVO3dCQUNoQyxNQUFNa0QsVUFBVSxDQUFDL0QsU0FBU2dFLFdBQVcsSUFBSSxLQUFLSDt3QkFDOUMsY0FBYzt3QkFDZC9ELFVBQVVpQixNQUFNLENBQUNGLFVBQVU7NEJBQUVtRCxhQUFhRDt3QkFBUTt3QkFDbEQsT0FBTzs0QkFDSCxHQUFHL0QsUUFBUTs0QkFDWGdFLGFBQWFEO3dCQUNqQjtvQkFDSjtvQkFDQSxPQUFPL0Q7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0FpRSxxQkFBcUIsQ0FBQ3BELFVBQW9CcUQ7UUFDdEMsTUFBTTFCLGVBQWUvQyxVQUFVNEIsUUFBUSxHQUFHOEMsU0FBUztRQUVuRDFFLFVBQVVvQyxRQUFRLENBQUNpQyxDQUFBQSxRQUFVO2dCQUN6QnJCLE1BQU1xQixNQUFNckIsSUFBSSxDQUFDTSxHQUFHLENBQUMvQyxDQUFBQTtvQkFDakIsSUFBSUEsU0FBU2EsUUFBUSxLQUFLQSxVQUFVO3dCQUNoQyxNQUFNdUQsa0JBQWtCOzRCQUNwQixHQUFHcEUsUUFBUTs0QkFDWHFFLGFBQWEsQ0FBQ3JFLFNBQVNxRSxXQUFXLElBQUksS0FBSzs0QkFDM0NDLFlBQVksQ0FBQ3RFLFNBQVNzRSxVQUFVLElBQUksS0FBS0o7NEJBQ3pDSyxrQkFBa0IsSUFBSUMsT0FBT0MsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQzVEO3dCQUVBLG9EQUFvRDt3QkFDcEQsTUFBTUMsWUFBWS9GLHVFQUFrQkEsQ0FBQ3dGLGlCQUFpQjVCO3dCQUN0RCxNQUFNb0MsVUFBVS9GLHVFQUFrQkEsQ0FBQzhGO3dCQUNuQyxNQUFNRSxjQUFjL0YseUVBQW9CQSxDQUFDc0Y7d0JBQ3pDLE1BQU1VLFlBQVkvRix1RUFBa0JBLENBQUNxRixpQkFBaUJXLElBQUk7d0JBQzFELE1BQU1DLGlCQUFpQnRHLHlFQUF1QkEsQ0FBQzBGO3dCQUUvQyxPQUFPOzRCQUNILEdBQUdBLGVBQWU7NEJBQ2xCTzs0QkFDQUM7NEJBQ0FDOzRCQUNBQzs0QkFDQUU7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBT2hGO2dCQUNYO1lBQ0o7SUFDSjtJQUNBaUYscUJBQXFCLENBQUNwRSxVQUFvQnFEO1FBQ3RDLE1BQU0xQixlQUFlL0MsVUFBVTRCLFFBQVEsR0FBRzhDLFNBQVM7UUFFbkQxRSxVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUE7b0JBQ2pCLElBQUlBLFNBQVNhLFFBQVEsS0FBS0EsVUFBVTt3QkFDaEMsTUFBTXVELGtCQUFrQjs0QkFDcEIsR0FBR3BFLFFBQVE7NEJBQ1hxRSxhQUFhYSxLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDbkYsU0FBU3FFLFdBQVcsSUFBSSxLQUFLOzRCQUN2REMsWUFBWVksS0FBS0MsR0FBRyxDQUFDLEdBQUcsQ0FBQ25GLFNBQVNzRSxVQUFVLElBQUksS0FBS0o7d0JBQ3pEO3dCQUVBLG9EQUFvRDt3QkFDcEQsTUFBTVMsWUFBWS9GLHVFQUFrQkEsQ0FBQ3dGLGlCQUFpQjVCO3dCQUN0RCxNQUFNb0MsVUFBVS9GLHVFQUFrQkEsQ0FBQzhGO3dCQUNuQyxNQUFNRSxjQUFjL0YseUVBQW9CQSxDQUFDc0Y7d0JBQ3pDLE1BQU1VLFlBQVkvRix1RUFBa0JBLENBQUNxRixpQkFBaUJXLElBQUk7d0JBQzFELE1BQU1DLGlCQUFpQnRHLHlFQUF1QkEsQ0FBQzBGO3dCQUUvQyxPQUFPOzRCQUNILEdBQUdBLGVBQWU7NEJBQ2xCTzs0QkFDQUM7NEJBQ0FDOzRCQUNBQzs0QkFDQUU7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBT2hGO2dCQUNYO1lBQ0o7SUFDSjtJQUNBb0Ysc0JBQXNCLENBQUN2RSxVQUFvQndFO1FBQ3ZDNUYsVUFBVW9DLFFBQVEsQ0FBQ2lDLENBQUFBLFFBQVU7Z0JBQ3pCckIsTUFBTXFCLE1BQU1yQixJQUFJLENBQUNNLEdBQUcsQ0FBQy9DLENBQUFBO29CQUNqQixJQUFJQSxTQUFTYSxRQUFRLEtBQUtBLFVBQVU7d0JBQ2hDLE9BQU87NEJBQ0gsR0FBR2IsUUFBUTs0QkFDWHNGLHVCQUF1QixDQUFDdEYsU0FBU3NGLHFCQUFxQixJQUFJLEtBQUtEO3dCQUNuRTtvQkFDSjtvQkFDQSxPQUFPckY7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0F1Riw4QkFBOEIsQ0FBQzFFO1FBQzNCcEIsVUFBVW9DLFFBQVEsQ0FBQ2lDLENBQUFBLFFBQVU7Z0JBQ3pCckIsTUFBTXFCLE1BQU1yQixJQUFJLENBQUNNLEdBQUcsQ0FBQy9DLENBQUFBO29CQUNqQixJQUFJQSxTQUFTYSxRQUFRLEtBQUtBLFVBQVU7d0JBQ2hDLE9BQU87NEJBQ0gsR0FBR2IsUUFBUTs0QkFDWHdGLGtCQUFrQixDQUFDeEYsU0FBU3dGLGdCQUFnQixJQUFJLEtBQUs7d0JBQ3pEO29CQUNKO29CQUNBLE9BQU94RjtnQkFDWDtZQUNKO0lBQ0o7SUFDQXlGLG9CQUFvQixDQUFDNUUsVUFBb0I2RTtRQUNyQ2pHLFVBQVVvQyxRQUFRLENBQUNpQyxDQUFBQSxRQUFVO2dCQUN6QnJCLE1BQU1xQixNQUFNckIsSUFBSSxDQUFDTSxHQUFHLENBQUMvQyxDQUFBQTtvQkFDakIsSUFBSUEsU0FBU2EsUUFBUSxLQUFLQSxVQUFVO3dCQUNoQyxNQUFNOEUsc0JBQXNCM0YsU0FBUzRGLGdCQUFnQixJQUFJLEVBQUU7d0JBQzNELG1CQUFtQjt3QkFDbkIsSUFBSUQsb0JBQW9CRSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE9BQU8sS0FBS0wsWUFBWUssT0FBTyxHQUFHOzRCQUNsRSxPQUFPL0Y7d0JBQ1g7d0JBRUEsTUFBTWdHLG9CQUFvQmQsS0FBS0MsR0FBRyxDQUFDTyxZQUFZTyxlQUFlLElBQUlQLFlBQVlRLE1BQU0sSUFBSSxHQUFHO3dCQUMzRixPQUFPOzRCQUNILEdBQUdsRyxRQUFROzRCQUNYZ0UsYUFBYWtCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNuRixTQUFTZ0UsV0FBVyxJQUFJLEtBQUtnQzs0QkFDdkRKLGtCQUFrQjttQ0FBSUQ7Z0NBQXFCRDs2QkFBWTt3QkFDM0Q7b0JBQ0o7b0JBQ0EsT0FBTzFGO2dCQUNYO1lBQ0o7SUFDSjtJQUNBbUcsOEJBQThCLENBQUN0RixVQUFvQmtGLFNBQXFCSztRQUNwRTNHLFVBQVVvQyxRQUFRLENBQUNpQyxDQUFBQSxRQUFVO2dCQUN6QnJCLE1BQU1xQixNQUFNckIsSUFBSSxDQUFDTSxHQUFHLENBQUMvQyxDQUFBQTtvQkFDakIsSUFBSUEsU0FBU2EsUUFBUSxLQUFLQSxZQUFZYixTQUFTNEYsZ0JBQWdCLEVBQUU7d0JBQzdELElBQUlTLFlBQVk7d0JBQ2hCLE1BQU1DLHNCQUFzQnRHLFNBQVM0RixnQkFBZ0IsQ0FBQzdDLEdBQUcsQ0FBQytDLENBQUFBOzRCQUN0RCxJQUFJQSxFQUFFQyxPQUFPLEtBQUtBLFNBQVM7Z0NBQ3ZCLE9BQU9EOzRCQUNYOzRCQUVBLE1BQU1TLGNBQWNULEVBQUVVLFVBQVUsSUFBSTs0QkFDcEMsTUFBTUMsbUJBQW1CWCxFQUFFRyxlQUFlLElBQUlmLEtBQUtDLEdBQUcsQ0FBQ1csRUFBRUksTUFBTSxHQUFHSyxhQUFhOzRCQUMvRSxJQUFJRyxnQkFBZ0JOOzRCQUVwQixJQUFJTSxnQkFBZ0IsR0FBRztnQ0FDbkJBLGdCQUFnQnhCLEtBQUt5QixHQUFHLENBQUNELGVBQWVEOzRCQUM1QyxPQUFPLElBQUlDLGdCQUFnQixHQUFHO2dDQUMxQkEsZ0JBQWdCeEIsS0FBS0MsR0FBRyxDQUFDdUIsZUFBZSxDQUFDSDs0QkFDN0M7NEJBRUEsTUFBTUssZ0JBQWdCTCxjQUFjRzs0QkFDcEMsTUFBTUcsd0JBQXdCM0IsS0FBS0MsR0FBRyxDQUFDVyxFQUFFSSxNQUFNLEdBQUdVLGVBQWU7NEJBQ2pFUCxhQUFhSzs0QkFFYixPQUFPO2dDQUNILEdBQUdaLENBQUM7Z0NBQ0pVLFlBQVlJO2dDQUNaWCxpQkFBaUJZO2dDQUNqQkMsUUFBUUQseUJBQXlCO2dDQUNqQ0UsVUFBVUYseUJBQXlCLElBQUksSUFBSXJDLE9BQU9DLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUdvQixFQUFFaUIsUUFBUTs0QkFDOUY7d0JBQ0o7d0JBRUEsT0FBTzs0QkFDSCxHQUFHL0csUUFBUTs0QkFDWGdFLGFBQWFrQixLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDbkYsU0FBU2dFLFdBQVcsSUFBSSxLQUFLcUM7NEJBQ3ZEVCxrQkFBa0JVO3dCQUN0QjtvQkFDSjtvQkFDQSxPQUFPdEc7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0FnSCx1QkFBdUIsQ0FBQ25HLFVBQW9Ca0Y7UUFDeEN0RyxVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUE7b0JBQ2pCLElBQUlBLFNBQVNhLFFBQVEsS0FBS0EsWUFBWWIsU0FBUzRGLGdCQUFnQixFQUFFO3dCQUM3RCxNQUFNRixjQUFjMUYsU0FBUzRGLGdCQUFnQixDQUFDcUIsSUFBSSxDQUFDbkIsQ0FBQUEsSUFBS0EsRUFBRUMsT0FBTyxLQUFLQTt3QkFDdEUsTUFBTW1CLGNBQWN4QixjQUNkUixLQUFLQyxHQUFHLENBQUNPLFlBQVlPLGVBQWUsSUFBS1AsWUFBWVEsTUFBTSxHQUFJUixDQUFBQSxZQUFZYyxVQUFVLElBQUksSUFBSyxLQUM5Rjt3QkFDTixPQUFPOzRCQUNILEdBQUd4RyxRQUFROzRCQUNYZ0UsYUFBYWtCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNuRixTQUFTZ0UsV0FBVyxJQUFJLEtBQUtrRDs0QkFDdkR0QixrQkFBa0I1RixTQUFTNEYsZ0JBQWdCLENBQUN1QixNQUFNLENBQUNyQixDQUFBQSxJQUFLQSxFQUFFQyxPQUFPLEtBQUtBO3dCQUMxRTtvQkFDSjtvQkFDQSxPQUFPL0Y7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0EsMEJBQTBCO0lBQzFCb0gsaUJBQWlCLENBQUN2RyxVQUFvQndHO1FBQ2xDNUgsVUFBVW9DLFFBQVEsQ0FBQ2lDLENBQUFBLFFBQVU7Z0JBQ3pCckIsTUFBTXFCLE1BQU1yQixJQUFJLENBQUNNLEdBQUcsQ0FBQy9DLENBQUFBO29CQUNqQixJQUFJQSxTQUFTYSxRQUFRLEtBQUtBLFVBQVU7d0JBQ2hDLE1BQU15RyxtQkFBbUJ0SCxTQUFTdUgsYUFBYSxJQUFJLEVBQUU7d0JBQ3JELE9BQU87NEJBQ0gsR0FBR3ZILFFBQVE7NEJBQ1h1SCxlQUFlO21DQUFJRDtnQ0FBa0JEOzZCQUFTO3dCQUNsRDtvQkFDSjtvQkFDQSxPQUFPckg7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0EsNkJBQTZCO0lBQzdCd0gsb0JBQW9CLENBQUMzRyxVQUFvQjRHLFlBQXNCekc7UUFDM0R2QixVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUE7b0JBQ2pCLElBQUlBLFNBQVNhLFFBQVEsS0FBS0EsWUFBWWIsU0FBU3VILGFBQWEsRUFBRTt3QkFDMUQsT0FBTzs0QkFDSCxHQUFHdkgsUUFBUTs0QkFDWHVILGVBQWV2SCxTQUFTdUgsYUFBYSxDQUFDeEUsR0FBRyxDQUFDQyxDQUFBQSxJQUN0Q0EsRUFBRW5DLFFBQVEsS0FBSzRHLGFBQWE7b0NBQUUsR0FBR3pFLENBQUM7b0NBQUUsR0FBR2hDLE9BQU87Z0NBQUMsSUFBSWdDO3dCQUUzRDtvQkFDSjtvQkFDQSxPQUFPaEQ7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0EsNkJBQTZCO0lBQzdCMEgsb0JBQW9CLENBQUM3RyxVQUFvQjRHO1FBQ3JDaEksVUFBVW9DLFFBQVEsQ0FBQ2lDLENBQUFBLFFBQVU7Z0JBQ3pCckIsTUFBTXFCLE1BQU1yQixJQUFJLENBQUNNLEdBQUcsQ0FBQy9DLENBQUFBO29CQUNqQixJQUFJQSxTQUFTYSxRQUFRLEtBQUtBLFlBQVliLFNBQVN1SCxhQUFhLEVBQUU7d0JBQzFELE9BQU87NEJBQ0gsR0FBR3ZILFFBQVE7NEJBQ1h1SCxlQUFldkgsU0FBU3VILGFBQWEsQ0FBQ0osTUFBTSxDQUFDbkUsQ0FBQUEsSUFBS0EsRUFBRW5DLFFBQVEsS0FBSzRHO3dCQUNyRTtvQkFDSjtvQkFDQSxPQUFPekg7Z0JBQ1g7WUFDSjtJQUNKO0lBQ0Esa0VBQWtFO0lBQ2xFc0IsS0FBSyxDQUFDdEI7UUFDRixNQUFNMkgsV0FBV3ZJLGdGQUFrQkE7UUFDbkMsTUFBTXdJLHdCQUF3QjtZQUMxQixHQUFHNUgsUUFBUTtZQUNYZ0YsZ0JBQWdCdEcseUVBQXVCQSxDQUFDc0I7UUFDNUM7UUFDQSxNQUFNNkgsY0FBY3BJLFVBQVU0QixRQUFRLEdBQUdDLEdBQUcsQ0FBQ3NHO1FBRTdDLDZCQUE2QjtRQUM3QixNQUFNRSxlQUFlekksZ0ZBQWtCQSxDQUNuQ3NJLFVBQ0EsR0FBR0EsU0FBU2xFLElBQUksQ0FBQyxtQkFBbUIsRUFBRW9FLFlBQVlwRSxJQUFJLENBQUMsRUFBRSxFQUFFb0UsWUFBWUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVoRnRJLFVBQVU0QixRQUFRLEdBQUdOLE1BQU0sQ0FBQzhHLFlBQVloSCxRQUFRLEVBQUU7WUFDOUMsR0FBR2dILFdBQVc7WUFDZEcsaUJBQWlCO2dCQUFDRjthQUFhO1FBQ25DO1FBRUEsT0FBT0Q7SUFDWDtJQUNBLHFFQUFxRTtJQUNyRTlHLFFBQVEsQ0FBQ0YsVUFBb0J1RDtRQUN6QjFELFFBQVFFLEdBQUcsQ0FBQyxrQ0FBa0M7WUFBRUM7WUFBVXVEO1FBQWdCO1FBRTFFLE1BQU11RCxXQUFXdkksZ0ZBQWtCQTtRQUNuQyxNQUFNNkksbUJBQW1CeEksVUFBVTRCLFFBQVEsR0FBR29CLElBQUksQ0FBQ3dFLElBQUksQ0FBQzNELENBQUFBLElBQUtBLEVBQUV6QyxRQUFRLEtBQUtBO1FBQzVFLE1BQU1xSCxpQkFBaUMsRUFBRTtRQUV6QyxJQUFJRCxrQkFBa0I7WUFDbEIsdUJBQXVCO1lBQ3ZCLElBQUlBLGlCQUFpQkUsTUFBTSxLQUFLL0QsZ0JBQWdCK0QsTUFBTSxFQUFFO2dCQUNwREQsZUFBZUUsSUFBSSxDQUFDN0ksc0ZBQXdCQSxDQUN4Q29JLFVBQ0FNLGlCQUFpQkUsTUFBTSxFQUN2Qi9ELGdCQUFnQitELE1BQU0sRUFDdEIsR0FBR1IsU0FBU2xFLElBQUksQ0FBQyx1QkFBdUIsRUFBRXdFLGlCQUFpQkUsTUFBTSxDQUFDLFFBQVEsRUFBRS9ELGdCQUFnQitELE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFFN0c7WUFFQSxzQkFBc0I7WUFDdEIsTUFBTUUsZ0JBQStEO2dCQUNqRTtvQkFBRUMsS0FBSztvQkFBUTlFLE9BQU87Z0JBQWlCO2dCQUN2QztvQkFBRThFLEtBQUs7b0JBQVM5RSxPQUFPO2dCQUFRO2dCQUMvQjtvQkFBRThFLEtBQUs7b0JBQVM5RSxPQUFPO2dCQUFnQjtnQkFDdkM7b0JBQUU4RSxLQUFLO29CQUFXOUUsT0FBTztnQkFBVTtnQkFDbkM7b0JBQUU4RSxLQUFLO29CQUFXOUUsT0FBTztnQkFBYTtnQkFDdEM7b0JBQUU4RSxLQUFLO29CQUFrQjlFLE9BQU87Z0JBQWlCO2dCQUNqRDtvQkFBRThFLEtBQUs7b0JBQVE5RSxPQUFPO2dCQUFrQjtnQkFDeEM7b0JBQUU4RSxLQUFLO29CQUFpQjlFLE9BQU87Z0JBQWtCO2dCQUNqRDtvQkFBRThFLEtBQUs7b0JBQWtCOUUsT0FBTztnQkFBcUI7Z0JBQ3JEO29CQUFFOEUsS0FBSztvQkFBVzlFLE9BQU87Z0JBQWtCO2dCQUMzQztvQkFBRThFLEtBQUs7b0JBQWdCOUUsT0FBTztnQkFBd0I7Z0JBQ3REO29CQUFFOEUsS0FBSztvQkFBZ0I5RSxPQUFPO2dCQUFvQjtnQkFDbEQ7b0JBQUU4RSxLQUFLO29CQUFnQjlFLE9BQU87Z0JBQVU7Z0JBQ3hDO29CQUFFOEUsS0FBSztvQkFBbUI5RSxPQUFPO2dCQUFzQjtnQkFDdkQ7b0JBQUU4RSxLQUFLO29CQUFvQjlFLE9BQU87Z0JBQXNCO2FBQzNEO1lBRUQsTUFBTStFLFVBQW9CLEVBQUU7WUFDNUIsS0FBSyxNQUFNQyxTQUFTSCxjQUFlO2dCQUMvQixNQUFNSSxTQUFTUixnQkFBZ0IsQ0FBQ08sTUFBTUYsR0FBRyxDQUFDO2dCQUMxQyxNQUFNSSxTQUFTdEUsZUFBZSxDQUFDb0UsTUFBTUYsR0FBRyxDQUFDO2dCQUN6QyxJQUFJRyxXQUFXQyxVQUFVLENBQUVELENBQUFBLFdBQVdFLGFBQWFELFdBQVdDLFNBQVEsR0FBSTtvQkFDdEUsd0RBQXdEO29CQUN4RCxJQUFJSCxNQUFNRixHQUFHLEtBQUssVUFBVTtvQkFDNUIsTUFBTU0sYUFBYUgsV0FBV0UsYUFBYUYsV0FBVyxRQUFRQSxXQUFXLEtBQUtJLE9BQU9KLFVBQVU7b0JBQy9GLE1BQU1LLGFBQWFKLFdBQVdDLGFBQWFELFdBQVcsUUFBUUEsV0FBVyxLQUFLRyxPQUFPSCxVQUFVO29CQUMvRkgsUUFBUUgsSUFBSSxDQUFDLEdBQUdJLE1BQU1oRixLQUFLLENBQUMsRUFBRSxFQUFFb0YsV0FBVyxHQUFHLEVBQUVFLFlBQVk7Z0JBQ2hFO1lBQ0o7WUFFQSxJQUFJUCxRQUFRNUUsTUFBTSxHQUFHLEdBQUc7Z0JBQ3BCdUUsZUFBZUUsSUFBSSxDQUFDOUksZ0ZBQWtCQSxDQUNsQ3FJLFVBQ0EsR0FBR0EsU0FBU2xFLElBQUksQ0FBQyxjQUFjLEVBQUU4RSxRQUFRUSxJQUFJLENBQUMsT0FBTztZQUU3RDtRQUNKO1FBRUEsTUFBTW5CLHdCQUF3QjtZQUMxQixHQUFHeEQsZUFBZTtZQUNsQlksZ0JBQWdCdEcseUVBQXVCQSxDQUFDMEY7WUFDeEM0RCxpQkFBaUJ4SSxnRkFBa0JBLENBQUN5SSxrQkFBa0JELG9CQUFvQkU7UUFDOUU7UUFDQXhILFFBQVFFLEdBQUcsQ0FBQyxrREFBa0RnSDtRQUU5RCxtREFBbUQ7UUFDbkRuSSxVQUFVNEIsUUFBUSxHQUFHTixNQUFNLENBQUNGLFVBQVUrRztRQUV0Q2xILFFBQVFFLEdBQUcsQ0FBQyx1Q0FBdUNuQixVQUFVNEIsUUFBUSxHQUFHb0IsSUFBSSxDQUFDd0UsSUFBSSxDQUFDM0QsQ0FBQUEsSUFBS0EsRUFBRXpDLFFBQVEsS0FBS0E7SUFDMUc7SUFDQSxvQ0FBb0M7SUFDcENsQywwQkFBMEI7UUFDdEIsTUFBTXFLLGtCQUFrQnZKLFVBQVU0QixRQUFRLEdBQUc4QyxTQUFTO1FBQ3RELE9BQU94Rix1RUFBd0JBLENBQUNxSztJQUNwQztJQUNBLHFFQUFxRTtJQUNyRUMsNEJBQTRCO1FBQ3hCLE1BQU16RyxlQUFlL0MsVUFBVTRCLFFBQVEsR0FBRzhDLFNBQVM7UUFFbkQxRSxVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUE7b0JBQ2pCLElBQUlBLFNBQVNrSixTQUFTLEVBQUUsT0FBT2xKO29CQUUvQixnQkFBZ0I7b0JBQ2hCLE1BQU0yRSxZQUFZL0YsdUVBQWtCQSxDQUFDb0IsVUFBVXdDO29CQUMvQyxNQUFNb0MsVUFBVS9GLHVFQUFrQkEsQ0FBQzhGO29CQUVuQyx5QkFBeUI7b0JBQ3pCLE1BQU1FLGNBQWMvRix5RUFBb0JBLENBQUNrQjtvQkFFekMsdUJBQXVCO29CQUN2QixNQUFNOEUsWUFBWS9GLHVFQUFrQkEsQ0FBQ2lCLFVBQVUrRSxJQUFJO29CQUVuRCw0QkFBNEI7b0JBQzVCLE1BQU1DLGlCQUFpQnRHLHlFQUF1QkEsQ0FBQ3NCO29CQUUvQyxPQUFPO3dCQUNILEdBQUdBLFFBQVE7d0JBQ1gyRTt3QkFDQUM7d0JBQ0FDO3dCQUNBQzt3QkFDQUU7b0JBQ0o7Z0JBQ0o7WUFDSjtJQUNKO0lBQ0EsMkJBQTJCO0lBQzNCbUUsdUJBQXVCLENBQUN2RTtRQUNwQixPQUFPbkYsVUFBVTRCLFFBQVEsR0FBRzhDLFNBQVMsR0FBR2dELE1BQU0sQ0FBQzdELENBQUFBLElBQUtBLEVBQUVzQixPQUFPLEtBQUtBO0lBQ3RFO0lBQ0Esa0NBQWtDO0lBQ2xDNUYseUJBQXlCO1FBQ3JCLE1BQU1nSyxrQkFBa0J2SixVQUFVNEIsUUFBUSxHQUFHOEMsU0FBUztRQUN0RCxPQUFPbkYsNkVBQXVCQSxDQUFDZ0s7SUFDbkM7SUFDQSxtQ0FBbUM7SUFDbkMvSixxQkFBcUI7UUFDakIsTUFBTStKLGtCQUFrQnZKLFVBQVU0QixRQUFRLEdBQUc4QyxTQUFTO1FBQ3RELE9BQU9sRix5RUFBbUJBLENBQUMrSjtJQUMvQjtJQUNBSSxZQUFZLENBQUNDO1FBQ1QsSUFBSSxDQUFDQSxVQUFVMUYsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0yRixxQkFBcUIsSUFBSTlFLE9BQU9DLFdBQVc7UUFDakRoRixVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUEsV0FDakJxSixVQUFVRSxRQUFRLENBQUN2SixTQUFTYSxRQUFRLElBQzlCO3dCQUFFLEdBQUdiLFFBQVE7d0JBQUVrSixXQUFXO3dCQUFNTSxXQUFXRjtvQkFBbUIsSUFDOUR0SjtZQUVkO0lBQ0o7SUFDQXlKLGtCQUFrQixDQUFDSixXQUF1QmxCO1FBQ3RDLElBQUksQ0FBQ2tCLFVBQVUxRixNQUFNLEVBQUU7UUFDdkJsRSxVQUFVb0MsUUFBUSxDQUFDaUMsQ0FBQUEsUUFBVTtnQkFDekJyQixNQUFNcUIsTUFBTXJCLElBQUksQ0FBQ00sR0FBRyxDQUFDL0MsQ0FBQUEsV0FDakJxSixVQUFVRSxRQUFRLENBQUN2SixTQUFTYSxRQUFRLElBQzlCO3dCQUFFLEdBQUdiLFFBQVE7d0JBQUVtSTtvQkFBTyxJQUN0Qm5JO1lBRWQ7SUFDSjtJQUNBMEosYUFBYSxDQUFDTDtRQUNWLElBQUksQ0FBQ0EsVUFBVTFGLE1BQU0sRUFBRTtRQUN2QmxFLFVBQVVvQyxRQUFRLENBQUNpQyxDQUFBQSxRQUFVO2dCQUN6QnJCLE1BQU1xQixNQUFNckIsSUFBSSxDQUFDTSxHQUFHLENBQUMvQyxDQUFBQSxXQUNqQnFKLFVBQVVFLFFBQVEsQ0FBQ3ZKLFNBQVNhLFFBQVEsSUFDOUI7d0JBQUUsR0FBR2IsUUFBUTt3QkFBRWtKLFdBQVc7d0JBQU9NLFdBQVc7b0JBQUssSUFDakR4SjtZQUVkO0lBQ0o7QUFDSjtBQUlBLElBQUkySixrQkFBOEM7QUFDbEQsSUFBSUMsc0JBQWlEO0FBRXJELE1BQU1DLG1CQUFtQixDQUFDL0Y7SUFDdEIsSUFBSTZGLG9CQUFvQjdGLFNBQVMsQ0FBQzhGLHFCQUFxQjtRQUNuREQsa0JBQWtCN0Y7UUFDbEI4RixzQkFBc0I7WUFBRSxHQUFHOUYsS0FBSztZQUFFLEdBQUc5QixnQkFBZ0I7UUFBQztJQUMxRDtJQUNBLE9BQU80SDtBQUNYO0FBRUEsTUFBTUUsYUFBYXJLO0FBS1osTUFBTXNLLG1CQUFtQixDQUM1QkMsVUFDQUM7SUFFQSxJQUFJRCxVQUFVO1FBQ1YsSUFBSUMsWUFBWTtZQUNaLE9BQU9ILFdBQVcsQ0FBQ2hHLFFBQVVrRyxTQUFTSCxpQkFBaUIvRixTQUFTbUc7UUFDcEU7UUFDQSxPQUFPSCxXQUFXLENBQUNoRyxRQUFVa0csU0FBU0gsaUJBQWlCL0Y7SUFDM0Q7SUFDQSxPQUFPZ0csV0FBVyxDQUFDaEcsUUFBVStGLGlCQUFpQi9GO0FBQ2xELEVBQUU7QUFFRmlHLGlCQUFpQjFJLFFBQVEsR0FBRztJQUN4QixPQUFPd0ksaUJBQWlCcEssVUFBVTRCLFFBQVE7QUFDOUMiLCJzb3VyY2VzIjpbIkQ6XFxocm0yXFxmZWF0dXJlc1xcY3VzdG9tZXJzXFxzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuaW1wb3J0IHsgY3JlYXRlQ3J1ZFN0b3JlLCBDcnVkU3RhdGUgfSBmcm9tICcuLi8uLi9saWIvc3RvcmUtZmFjdG9yeSc7XHJcbi8vIFJFTU9WRUQ6IGltcG9ydCB7IGRhdGEgYXMgaW5pdGlhbERhdGEgfSBmcm9tICcuL2RhdGEnOyAvLyBNb2NrIGRhdGEgbm8gbG9uZ2VyIHVzZWQgLSBkYXRhYmFzZSBpcyBzb3VyY2Ugb2YgdHJ1dGhcclxuaW1wb3J0IHR5cGUgeyBDdXN0b21lciB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBTeXN0ZW1JZCwgQnVzaW5lc3NJZCB9IGZyb20gJy4uLy4uL2xpYi9pZC10eXBlcyc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUxpZmVjeWNsZVN0YWdlIH0gZnJvbSAnLi9saWZlY3ljbGUtdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRIaWdoUmlza0RlYnRDdXN0b21lcnMgfSBmcm9tICcuL2NyZWRpdC11dGlscyc7XHJcbmltcG9ydCB7IFxyXG4gIGNhbGN1bGF0ZVJGTVNjb3JlcywgXHJcbiAgZ2V0Q3VzdG9tZXJTZWdtZW50LCBcclxuICBjYWxjdWxhdGVIZWFsdGhTY29yZSxcclxuICBjYWxjdWxhdGVDaHVyblJpc2sgXHJcbn0gZnJvbSAnLi9pbnRlbGxpZ2VuY2UtdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRPdmVyZHVlRGVidEN1c3RvbWVycywgZ2V0RHVlU29vbkN1c3RvbWVycyB9IGZyb20gJy4vZGVidC10cmFja2luZy11dGlscyc7XHJcbmltcG9ydCBGdXNlIGZyb20gJ2Z1c2UuanMnO1xyXG5pbXBvcnQgeyBnZXRDdXJyZW50VXNlclN5c3RlbUlkIH0gZnJvbSAnLi4vLi4vY29udGV4dHMvYXV0aC1jb250ZXh0JztcclxuaW1wb3J0IHtcclxuICBnZXRDdXJyZW50VXNlckluZm8sXHJcbiAgY3JlYXRlQ3JlYXRlZEVudHJ5LFxyXG4gIGNyZWF0ZVVwZGF0ZWRFbnRyeSxcclxuICBjcmVhdGVTdGF0dXNDaGFuZ2VkRW50cnksXHJcbiAgYXBwZW5kSGlzdG9yeUVudHJ5LFxyXG4gIHR5cGUgSGlzdG9yeUVudHJ5XHJcbn0gZnJvbSAnLi4vLi4vbGliL2FjdGl2aXR5LWhpc3RvcnktaGVscGVyJztcclxuXHJcbmNvbnN0IGJhc2VTdG9yZSA9IGNyZWF0ZUNydWRTdG9yZTxDdXN0b21lcj4oW10sICdjdXN0b21lcnMnLCB7XHJcbiAgYnVzaW5lc3NJZEZpZWxkOiAnaWQnLFxyXG4gIGdldEN1cnJlbnRVc2VyOiBnZXRDdXJyZW50VXNlclN5c3RlbUlkLCAvLyBUcmFjayB3aG8gY3JlYXRlcy91cGRhdGVzXHJcbiAgYXBpRW5kcG9pbnQ6ICcvYXBpL2N1c3RvbWVycycsXHJcbn0pO1xyXG5cclxuLy8g4pyFIEFQSSBTeW5jIGhlbHBlcnNcclxuY29uc3QgQVBJX0VORFBPSU5UID0gJy9hcGkvY3VzdG9tZXJzJztcclxuXHJcbmNvbnN0IHN5bmNUb0FwaSA9IHtcclxuICBjcmVhdGU6IGFzeW5jIChjdXN0b21lcjogQ3VzdG9tZXIpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goQVBJX0VORFBPSU5ULCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjdXN0b21lciksXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSBjb25zb2xlLndhcm4oJ1tDdXN0b21lciBBUEldIENyZWF0ZSBzeW5jIGZhaWxlZCcpO1xyXG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdbQ3VzdG9tZXIgQVBJXSBDcmVhdGVkOicsIGN1c3RvbWVyLnN5c3RlbUlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbQ3VzdG9tZXIgQVBJXSBDcmVhdGUgc3luYyBlcnJvcjonLCBlKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHVwZGF0ZTogYXN5bmMgKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdXBkYXRlczogUGFydGlhbDxDdXN0b21lcj4pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0VORFBPSU5UfS8ke3N5c3RlbUlkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVzKSxcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIGNvbnNvbGUud2FybignW0N1c3RvbWVyIEFQSV0gVXBkYXRlIHN5bmMgZmFpbGVkJyk7XHJcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ1tDdXN0b21lciBBUEldIFVwZGF0ZWQ6Jywgc3lzdGVtSWQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tDdXN0b21lciBBUEldIFVwZGF0ZSBzeW5jIGVycm9yOicsIGUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVsZXRlOiBhc3luYyAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBoYXJkID0gZmFsc2UpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0VORFBPSU5UfS8ke3N5c3RlbUlkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBoYXJkIH0pLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbQ3VzdG9tZXIgQVBJXSBEZWxldGUgc3luYyBmYWlsZWQnKTtcclxuICAgICAgZWxzZSBjb25zb2xlLmxvZygnW0N1c3RvbWVyIEFQSV0gRGVsZXRlZDonLCBzeXN0ZW1JZCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW0N1c3RvbWVyIEFQSV0gRGVsZXRlIHN5bmMgZXJyb3I6JywgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZXN0b3JlOiBhc3luYyAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9FTkRQT0lOVH0vJHtzeXN0ZW1JZH0vcmVzdG9yZWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbQ3VzdG9tZXIgQVBJXSBSZXN0b3JlIHN5bmMgZmFpbGVkJyk7XHJcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ1tDdXN0b21lciBBUEldIFJlc3RvcmVkOicsIHN5c3RlbUlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbQ3VzdG9tZXIgQVBJXSBSZXN0b3JlIHN5bmMgZXJyb3I6JywgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIOKchSBXcmFwIGJhc2Ugc3RvcmUgbWV0aG9kcyB3aXRoIEFQSSBzeW5jXHJcbmNvbnN0IG9yaWdpbmFsQWRkID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuYWRkO1xyXG5jb25zdCBvcmlnaW5hbFVwZGF0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZTtcclxuY29uc3Qgb3JpZ2luYWxSZW1vdmUgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5yZW1vdmU7XHJcbmNvbnN0IG9yaWdpbmFsSGFyZERlbGV0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmhhcmREZWxldGU7XHJcbmNvbnN0IG9yaWdpbmFsUmVzdG9yZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnJlc3RvcmU7XHJcblxyXG5iYXNlU3RvcmUuc2V0U3RhdGUoe1xyXG4gIGFkZDogKGl0ZW06IE9taXQ8Q3VzdG9tZXIsICdzeXN0ZW1JZCc+KSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbEFkZChpdGVtKTtcclxuICAgIHN5bmNUb0FwaS5jcmVhdGUocmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSxcclxuICB1cGRhdGU6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHVwZGF0ZXM6IFBhcnRpYWw8Q3VzdG9tZXI+KSA9PiB7XHJcbiAgICBvcmlnaW5hbFVwZGF0ZShzeXN0ZW1JZCwgdXBkYXRlcyk7XHJcbiAgICBzeW5jVG9BcGkudXBkYXRlKHN5c3RlbUlkLCB1cGRhdGVzKTtcclxuICB9LFxyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZW1vdmUoc3lzdGVtSWQpO1xyXG4gICAgc3luY1RvQXBpLmRlbGV0ZShzeXN0ZW1JZCwgZmFsc2UpO1xyXG4gIH0sXHJcbiAgaGFyZERlbGV0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxIYXJkRGVsZXRlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5kZWxldGUoc3lzdGVtSWQsIHRydWUpO1xyXG4gIH0sXHJcbiAgcmVzdG9yZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZXN0b3JlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5yZXN0b3JlKHN5c3RlbUlkKTtcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIERlZmluZSBlbmhhbmNlZCBpbnRlcmZhY2VcclxuaW50ZXJmYWNlIEN1c3RvbWVyU3RvcmVTdGF0ZSBleHRlbmRzIENydWRTdGF0ZTxDdXN0b21lcj4ge1xyXG4gIHNlYXJjaEN1c3RvbWVyczogKHF1ZXJ5OiBzdHJpbmcsIHBhZ2U6IG51bWJlciwgbGltaXQ/OiBudW1iZXIpID0+IFByb21pc2U8eyBpdGVtczogeyB2YWx1ZTogc3RyaW5nOyBsYWJlbDogc3RyaW5nIH1bXSwgaGFzTmV4dFBhZ2U6IGJvb2xlYW4gfT47XHJcbiAgdXBkYXRlRGVidDogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgYW1vdW50Q2hhbmdlOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgaW5jcmVtZW50T3JkZXJTdGF0czogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgb3JkZXJWYWx1ZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIGRlY3JlbWVudE9yZGVyU3RhdHM6IChzeXN0ZW1JZDogU3lzdGVtSWQsIG9yZGVyVmFsdWU6IG51bWJlcikgPT4gdm9pZDtcclxuICBpbmNyZW1lbnRSZXR1cm5TdGF0czogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcXVhbnRpdHk6IG51bWJlcikgPT4gdm9pZDtcclxuICBpbmNyZW1lbnRGYWlsZWREZWxpdmVyeVN0YXRzOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB2b2lkO1xyXG4gIGFkZERlYnRUcmFuc2FjdGlvbjogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdHJhbnNhY3Rpb246IGltcG9ydCgnLi90eXBlcycpLkRlYnRUcmFuc2FjdGlvbikgPT4gdm9pZDtcclxuICBhZGREZWJ0UmVtaW5kZXI6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlbWluZGVyOiBpbXBvcnQoJy4vdHlwZXMnKS5EZWJ0UmVtaW5kZXIpID0+IHZvaWQ7XHJcbiAgdXBkYXRlRGVidFJlbWluZGVyOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCByZW1pbmRlcklkOiBTeXN0ZW1JZCwgdXBkYXRlczogUGFydGlhbDxpbXBvcnQoJy4vdHlwZXMnKS5EZWJ0UmVtaW5kZXI+KSA9PiB2b2lkO1xyXG4gIHJlbW92ZURlYnRSZW1pbmRlcjogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcmVtaW5kZXJJZDogU3lzdGVtSWQpID0+IHZvaWQ7XHJcbiAgdXBkYXRlRGVidFRyYW5zYWN0aW9uUGF5bWVudDogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgb3JkZXJJZDogQnVzaW5lc3NJZCwgYW1vdW50UGFpZDogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIHJlbW92ZURlYnRUcmFuc2FjdGlvbjogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgb3JkZXJJZDogQnVzaW5lc3NJZCkgPT4gdm9pZDtcclxuICBnZXRIaWdoUmlza0RlYnRDdXN0b21lcnM6ICgpID0+IEN1c3RvbWVyW107XHJcbiAgdXBkYXRlQ3VzdG9tZXJJbnRlbGxpZ2VuY2U6ICgpID0+IHZvaWQ7IC8vIEJhdGNoIHVwZGF0ZSBSRk0sIGhlYWx0aCBzY29yZSwgY2h1cm4gcmlza1xyXG4gIGdldEN1c3RvbWVyc0J5U2VnbWVudDogKHNlZ21lbnQ6IHN0cmluZykgPT4gQ3VzdG9tZXJbXTtcclxuICBnZXRPdmVyZHVlRGVidEN1c3RvbWVyczogKCkgPT4gQ3VzdG9tZXJbXTtcclxuICBnZXREdWVTb29uQ3VzdG9tZXJzOiAoKSA9PiBDdXN0b21lcltdO1xyXG4gICAgcmVtb3ZlTWFueTogKHN5c3RlbUlkczogU3lzdGVtSWRbXSkgPT4gdm9pZDtcclxuICAgIHVwZGF0ZU1hbnlTdGF0dXM6IChzeXN0ZW1JZHM6IFN5c3RlbUlkW10sIHN0YXR1czogQ3VzdG9tZXJbJ3N0YXR1cyddKSA9PiB2b2lkO1xyXG4gICAgcmVzdG9yZU1hbnk6IChzeXN0ZW1JZHM6IFN5c3RlbUlkW10pID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8vIEF1Z21lbnRlZCBtZXRob2RzXHJcbmNvbnN0IGF1Z21lbnRlZE1ldGhvZHMgPSB7XHJcbiAgICBzZWFyY2hDdXN0b21lcnM6IGFzeW5jIChxdWVyeTogc3RyaW5nLCBwYWdlOiBudW1iZXIsIGxpbWl0OiBudW1iZXIgPSAyMCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx7IGl0ZW1zOiB7IHZhbHVlOiBzdHJpbmc7IGxhYmVsOiBzdHJpbmcgfVtdLCBoYXNOZXh0UGFnZTogYm9vbGVhbiB9PihyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxDdXN0b21lcnMgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZnJlc2ggRnVzZSBpbnN0YW5jZSB3aXRoIGN1cnJlbnQgZGF0YSAoYXZvaWQgc3RhbGUgZGF0YSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1c2UgPSBuZXcgRnVzZShhbGxDdXN0b21lcnMsIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzOiBbJ25hbWUnLCAnaWQnLCAncGhvbmUnXSxcclxuICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDAuMyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gcXVlcnkgPyBmdXNlLnNlYXJjaChxdWVyeSkubWFwKHIgPT4gci5pdGVtKSA6IGFsbEN1c3RvbWVycztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAocGFnZSAtIDEpICogbGltaXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIGxpbWl0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnaW5hdGVkSXRlbXMgPSByZXN1bHRzLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBwYWdpbmF0ZWRJdGVtcy5tYXAoYyA9PiAoeyB2YWx1ZTogYy5zeXN0ZW1JZCwgbGFiZWw6IGMubmFtZSB9KSksXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFBhZ2U6IGVuZCA8IHJlc3VsdHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIDMwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlRGVidDogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgYW1vdW50Q2hhbmdlOiBudW1iZXIpID0+IHtcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoY3VzdG9tZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbWVyLnN5c3RlbUlkID09PSBzeXN0ZW1JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlYnQgPSAoY3VzdG9tZXIuY3VycmVudERlYnQgfHwgMCkgKyBhbW91bnRDaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3luYyB0byBBUElcclxuICAgICAgICAgICAgICAgICAgICBzeW5jVG9BcGkudXBkYXRlKHN5c3RlbUlkLCB7IGN1cnJlbnREZWJ0OiBuZXdEZWJ0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVidDogbmV3RGVidCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbWVyO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBpbmNyZW1lbnRPcmRlclN0YXRzOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBvcmRlclZhbHVlOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBhbGxDdXN0b21lcnMgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5nZXRBY3RpdmUoKTtcclxuICAgICAgICBcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoY3VzdG9tZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbWVyLnN5c3RlbUlkID09PSBzeXN0ZW1JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDdXN0b21lciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VzdG9tZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsT3JkZXJzOiAoY3VzdG9tZXIudG90YWxPcmRlcnMgfHwgMCkgKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNwZW50OiAoY3VzdG9tZXIudG90YWxTcGVudCB8fCAwKSArIG9yZGVyVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQdXJjaGFzZURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV0by11cGRhdGUgaW50ZWxsaWdlbmNlIGFmdGVyIG9yZGVyIHN0YXRzIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJmbVNjb3JlcyA9IGNhbGN1bGF0ZVJGTVNjb3Jlcyh1cGRhdGVkQ3VzdG9tZXIsIGFsbEN1c3RvbWVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGdldEN1c3RvbWVyU2VnbWVudChyZm1TY29yZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWx0aFNjb3JlID0gY2FsY3VsYXRlSGVhbHRoU2NvcmUodXBkYXRlZEN1c3RvbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVyblJpc2sgPSBjYWxjdWxhdGVDaHVyblJpc2sodXBkYXRlZEN1c3RvbWVyKS5yaXNrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpZmVjeWNsZVN0YWdlID0gY2FsY3VsYXRlTGlmZWN5Y2xlU3RhZ2UodXBkYXRlZEN1c3RvbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVkQ3VzdG9tZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmbVNjb3JlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhbHRoU2NvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodXJuUmlzayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlU3RhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21lcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZGVjcmVtZW50T3JkZXJTdGF0czogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgb3JkZXJWYWx1ZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYWxsQ3VzdG9tZXJzID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZ2V0QWN0aXZlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKGN1c3RvbWVyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21lci5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ3VzdG9tZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE9yZGVyczogTWF0aC5tYXgoMCwgKGN1c3RvbWVyLnRvdGFsT3JkZXJzIHx8IDApIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU3BlbnQ6IE1hdGgubWF4KDAsIChjdXN0b21lci50b3RhbFNwZW50IHx8IDApIC0gb3JkZXJWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvLXVwZGF0ZSBpbnRlbGxpZ2VuY2UgYWZ0ZXIgb3JkZXIgc3RhdHMgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmZtU2NvcmVzID0gY2FsY3VsYXRlUkZNU2NvcmVzKHVwZGF0ZWRDdXN0b21lciwgYWxsQ3VzdG9tZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gZ2V0Q3VzdG9tZXJTZWdtZW50KHJmbVNjb3Jlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhbHRoU2NvcmUgPSBjYWxjdWxhdGVIZWFsdGhTY29yZSh1cGRhdGVkQ3VzdG9tZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodXJuUmlzayA9IGNhbGN1bGF0ZUNodXJuUmlzayh1cGRhdGVkQ3VzdG9tZXIpLnJpc2s7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlmZWN5Y2xlU3RhZ2UgPSBjYWxjdWxhdGVMaWZlY3ljbGVTdGFnZSh1cGRhdGVkQ3VzdG9tZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRDdXN0b21lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmZtU2NvcmVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhTY29yZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1cm5SaXNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGVTdGFnZSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbWVyO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBpbmNyZW1lbnRSZXR1cm5TdGF0czogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcXVhbnRpdHk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tZXIuc3lzdGVtSWQgPT09IHN5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VzdG9tZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUXVhbnRpdHlSZXR1cm5lZDogKGN1c3RvbWVyLnRvdGFsUXVhbnRpdHlSZXR1cm5lZCB8fCAwKSArIHF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tZXI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGluY3JlbWVudEZhaWxlZERlbGl2ZXJ5U3RhdHM6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHtcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoY3VzdG9tZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbWVyLnN5c3RlbUlkID09PSBzeXN0ZW1JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWREZWxpdmVyaWVzOiAoY3VzdG9tZXIuZmFpbGVkRGVsaXZlcmllcyB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21lcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgYWRkRGVidFRyYW5zYWN0aW9uOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCB0cmFuc2FjdGlvbjogaW1wb3J0KCcuL3R5cGVzJykuRGVidFRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKGN1c3RvbWVyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21lci5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNhY3Rpb25zID0gY3VzdG9tZXIuZGVidFRyYW5zYWN0aW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBkdXBsaWNhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2FjdGlvbnMuc29tZSh0ID0+IHQub3JkZXJJZCA9PT0gdHJhbnNhY3Rpb24ub3JkZXJJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0c3RhbmRpbmdBbW91bnQgPSBNYXRoLm1heCh0cmFuc2FjdGlvbi5yZW1haW5pbmdBbW91bnQgPz8gdHJhbnNhY3Rpb24uYW1vdW50ID8/IDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVidDogTWF0aC5tYXgoMCwgKGN1c3RvbWVyLmN1cnJlbnREZWJ0IHx8IDApICsgb3V0c3RhbmRpbmdBbW91bnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ0VHJhbnNhY3Rpb25zOiBbLi4uY3VycmVudFRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25dLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tZXI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZURlYnRUcmFuc2FjdGlvblBheW1lbnQ6IChzeXN0ZW1JZDogU3lzdGVtSWQsIG9yZGVySWQ6IEJ1c2luZXNzSWQsIGFtb3VudFBhaWQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tZXIuc3lzdGVtSWQgPT09IHN5c3RlbUlkICYmIGN1c3RvbWVyLmRlYnRUcmFuc2FjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVidERlbHRhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkVHJhbnNhY3Rpb25zID0gY3VzdG9tZXIuZGVidFRyYW5zYWN0aW9ucy5tYXAodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Lm9yZGVySWQgIT09IG9yZGVySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFpZCA9IHQucGFpZEFtb3VudCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmVtYWluaW5nID0gdC5yZW1haW5pbmdBbW91bnQgPz8gTWF0aC5tYXgodC5hbW91bnQgLSBjdXJyZW50UGFpZCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcHBsaWVkQW1vdW50ID0gYW1vdW50UGFpZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBsaWVkQW1vdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZEFtb3VudCA9IE1hdGgubWluKGFwcGxpZWRBbW91bnQsIGN1cnJlbnRSZW1haW5pbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGxpZWRBbW91bnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkQW1vdW50ID0gTWF0aC5tYXgoYXBwbGllZEFtb3VudCwgLWN1cnJlbnRQYWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UGFpZEFtb3VudCA9IGN1cnJlbnRQYWlkICsgYXBwbGllZEFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjYWxjdWxhdGVkUmVtYWluaW5nID0gTWF0aC5tYXgodC5hbW91bnQgLSBuZXdQYWlkQW1vdW50LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidERlbHRhIC09IGFwcGxpZWRBbW91bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaWRBbW91bnQ6IG5ld1BhaWRBbW91bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdBbW91bnQ6IHJlY2FsY3VsYXRlZFJlbWFpbmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpZDogcmVjYWxjdWxhdGVkUmVtYWluaW5nIDw9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlkRGF0ZTogcmVjYWxjdWxhdGVkUmVtYWluaW5nIDw9IDAgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSA6IHQucGFpZERhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVidDogTWF0aC5tYXgoMCwgKGN1c3RvbWVyLmN1cnJlbnREZWJ0IHx8IDApICsgZGVidERlbHRhKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidFRyYW5zYWN0aW9uczogdXBkYXRlZFRyYW5zYWN0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbWVyO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVEZWJ0VHJhbnNhY3Rpb246IChzeXN0ZW1JZDogU3lzdGVtSWQsIG9yZGVySWQ6IEJ1c2luZXNzSWQpID0+IHtcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoY3VzdG9tZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbWVyLnN5c3RlbUlkID09PSBzeXN0ZW1JZCAmJiBjdXN0b21lci5kZWJ0VHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjdXN0b21lci5kZWJ0VHJhbnNhY3Rpb25zLmZpbmQodCA9PiB0Lm9yZGVySWQgPT09IG9yZGVySWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHN0YW5kaW5nID0gdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1heCh0cmFuc2FjdGlvbi5yZW1haW5pbmdBbW91bnQgPz8gKHRyYW5zYWN0aW9uLmFtb3VudCAtICh0cmFuc2FjdGlvbi5wYWlkQW1vdW50IHx8IDApKSwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVidDogTWF0aC5tYXgoMCwgKGN1c3RvbWVyLmN1cnJlbnREZWJ0IHx8IDApIC0gb3V0c3RhbmRpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ0VHJhbnNhY3Rpb25zOiBjdXN0b21lci5kZWJ0VHJhbnNhY3Rpb25zLmZpbHRlcih0ID0+IHQub3JkZXJJZCAhPT0gb3JkZXJJZCksXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21lcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gQWRkIGRlYnQgcmVtaW5kZXIgKDMuMylcclxuICAgIGFkZERlYnRSZW1pbmRlcjogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcmVtaW5kZXI6IGltcG9ydCgnLi90eXBlcycpLkRlYnRSZW1pbmRlcikgPT4ge1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tZXIuc3lzdGVtSWQgPT09IHN5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJlbWluZGVycyA9IGN1c3RvbWVyLmRlYnRSZW1pbmRlcnMgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VzdG9tZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnRSZW1pbmRlcnM6IFsuLi5jdXJyZW50UmVtaW5kZXJzLCByZW1pbmRlcl0sXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21lcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gVXBkYXRlIGRlYnQgcmVtaW5kZXIgKDMuMylcclxuICAgIHVwZGF0ZURlYnRSZW1pbmRlcjogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcmVtaW5kZXJJZDogU3lzdGVtSWQsIHVwZGF0ZXM6IFBhcnRpYWw8aW1wb3J0KCcuL3R5cGVzJykuRGVidFJlbWluZGVyPikgPT4ge1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tZXIuc3lzdGVtSWQgPT09IHN5c3RlbUlkICYmIGN1c3RvbWVyLmRlYnRSZW1pbmRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdXN0b21lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidFJlbWluZGVyczogY3VzdG9tZXIuZGVidFJlbWluZGVycy5tYXAociA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5zeXN0ZW1JZCA9PT0gcmVtaW5kZXJJZCA/IHsgLi4uciwgLi4udXBkYXRlcyB9IDogclxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tZXI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIC8vIFJlbW92ZSBkZWJ0IHJlbWluZGVyICgzLjMpXHJcbiAgICByZW1vdmVEZWJ0UmVtaW5kZXI6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlbWluZGVySWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKGN1c3RvbWVyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21lci5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQgJiYgY3VzdG9tZXIuZGVidFJlbWluZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ0UmVtaW5kZXJzOiBjdXN0b21lci5kZWJ0UmVtaW5kZXJzLmZpbHRlcihyID0+IHIuc3lzdGVtSWQgIT09IHJlbWluZGVySWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tZXI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIC8vIE92ZXJyaWRlIGFkZCB0byBhdXRvLWNhbGN1bGF0ZSBsaWZlY3ljbGUgc3RhZ2UgYW5kIGxvZyBhY3Rpdml0eVxyXG4gICAgYWRkOiAoY3VzdG9tZXI6IE9taXQ8Q3VzdG9tZXIsICdzeXN0ZW1JZCc+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXNlckluZm8gPSBnZXRDdXJyZW50VXNlckluZm8oKTtcclxuICAgICAgICBjb25zdCBjdXN0b21lcldpdGhMaWZlY3ljbGUgPSB7XHJcbiAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICBsaWZlY3ljbGVTdGFnZTogY2FsY3VsYXRlTGlmZWN5Y2xlU3RhZ2UoY3VzdG9tZXIgYXMgQ3VzdG9tZXIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBuZXdDdXN0b21lciA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmFkZChjdXN0b21lcldpdGhMaWZlY3ljbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBhY3Rpdml0eSBoaXN0b3J5IGVudHJ5XHJcbiAgICAgICAgY29uc3QgaGlzdG9yeUVudHJ5ID0gY3JlYXRlQ3JlYXRlZEVudHJ5KFxyXG4gICAgICAgICAgICB1c2VySW5mbyxcclxuICAgICAgICAgICAgYCR7dXNlckluZm8ubmFtZX0gxJHDoyB04bqhbyBraMOhY2ggaMOgbmcgJHtuZXdDdXN0b21lci5uYW1lfSAoJHtuZXdDdXN0b21lci5pZH0pYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYmFzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlKG5ld0N1c3RvbWVyLnN5c3RlbUlkLCB7XHJcbiAgICAgICAgICAgIC4uLm5ld0N1c3RvbWVyLFxyXG4gICAgICAgICAgICBhY3Rpdml0eUhpc3Rvcnk6IFtoaXN0b3J5RW50cnldXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ld0N1c3RvbWVyO1xyXG4gICAgfSxcclxuICAgIC8vIE92ZXJyaWRlIHVwZGF0ZSB0byBhdXRvLWNhbGN1bGF0ZSBsaWZlY3ljbGUgc3RhZ2UgYW5kIGxvZyBhY3Rpdml0eVxyXG4gICAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCB1cGRhdGVkQ3VzdG9tZXI6IEN1c3RvbWVyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tDdXN0b21lclN0b3JlXSB1cGRhdGUgY2FsbGVkOicsIHsgc3lzdGVtSWQsIHVwZGF0ZWRDdXN0b21lciB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB1c2VySW5mbyA9IGdldEN1cnJlbnRVc2VySW5mbygpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ3VzdG9tZXIgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQoYyA9PiBjLnN5c3RlbUlkID09PSBzeXN0ZW1JZCk7XHJcbiAgICAgICAgY29uc3QgaGlzdG9yeUVudHJpZXM6IEhpc3RvcnlFbnRyeVtdID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nQ3VzdG9tZXIpIHtcclxuICAgICAgICAgICAgLy8gVHJhY2sgc3RhdHVzIGNoYW5nZXNcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ3VzdG9tZXIuc3RhdHVzICE9PSB1cGRhdGVkQ3VzdG9tZXIuc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBoaXN0b3J5RW50cmllcy5wdXNoKGNyZWF0ZVN0YXR1c0NoYW5nZWRFbnRyeShcclxuICAgICAgICAgICAgICAgICAgICB1c2VySW5mbyxcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0N1c3RvbWVyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQ3VzdG9tZXIuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGAke3VzZXJJbmZvLm5hbWV9IMSRw6MgxJHhu5VpIHRy4bqhbmcgdGjDoWkgdOG7qyBcIiR7ZXhpc3RpbmdDdXN0b21lci5zdGF0dXN9XCIgc2FuZyBcIiR7dXBkYXRlZEN1c3RvbWVyLnN0YXR1c31cImBcclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUcmFjayBmaWVsZCBjaGFuZ2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkc1RvVHJhY2s6IEFycmF5PHsga2V5OiBrZXlvZiBDdXN0b21lcjsgbGFiZWw6IHN0cmluZyB9PiA9IFtcclxuICAgICAgICAgICAgICAgIHsga2V5OiAnbmFtZScsIGxhYmVsOiAnVMOqbiBraMOhY2ggaMOgbmcnIH0sXHJcbiAgICAgICAgICAgICAgICB7IGtleTogJ2VtYWlsJywgbGFiZWw6ICdFbWFpbCcgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAncGhvbmUnLCBsYWJlbDogJ1Phu5EgxJFp4buHbiB0aG/huqFpJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdjb21wYW55JywgbGFiZWw6ICdDw7RuZyB0eScgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAndGF4Q29kZScsIGxhYmVsOiAnTcOjIHPhu5EgdGh14bq/JyB9LFxyXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdyZXByZXNlbnRhdGl2ZScsIGxhYmVsOiAnTmfGsOG7nWkgxJHhuqFpIGRp4buHbicgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAndHlwZScsIGxhYmVsOiAnTG/huqFpIGtow6FjaCBow6BuZycgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAnY3VzdG9tZXJHcm91cCcsIGxhYmVsOiAnTmjDs20ga2jDoWNoIGjDoG5nJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdsaWZlY3ljbGVTdGFnZScsIGxhYmVsOiAnR2lhaSDEkW/huqFuIHbDsm5nIMSR4budaScgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAnbWF4RGVidCcsIGxhYmVsOiAnSOG6oW4gbeG7qWMgY8O0bmcgbuG7oycgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAncGF5bWVudFRlcm1zJywgbGFiZWw6ICfEkGnhu4F1IGtob+G6o24gdGhhbmggdG/DoW4nIH0sXHJcbiAgICAgICAgICAgICAgICB7IGtleTogJ2NyZWRpdFJhdGluZycsIGxhYmVsOiAnWOG6v3AgaOG6oW5nIHTDrW4gZOG7pW5nJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdwcmljaW5nTGV2ZWwnLCBsYWJlbDogJ03hu6ljIGdpw6EnIH0sXHJcbiAgICAgICAgICAgICAgICB7IGtleTogJ2RlZmF1bHREaXNjb3VudCcsIGxhYmVsOiAnQ2hp4bq/dCBraOG6pXUgbeG6t2MgxJHhu4tuaCcgfSxcclxuICAgICAgICAgICAgICAgIHsga2V5OiAnYWNjb3VudE1hbmFnZXJJZCcsIGxhYmVsOiAnTmjDom4gdmnDqm4gcGjhu6UgdHLDoWNoJyB9LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNUb1RyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWwgPSBleGlzdGluZ0N1c3RvbWVyW2ZpZWxkLmtleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSB1cGRhdGVkQ3VzdG9tZXJbZmllbGQua2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCAmJiAhKG9sZFZhbCA9PT0gdW5kZWZpbmVkICYmIG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgaWYgaXQncyB0aGUgc3RhdHVzIGZpZWxkIChhbHJlYWR5IHRyYWNrZWQgYWJvdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmtleSA9PT0gJ3N0YXR1cycpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZERpc3BsYXkgPSBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IG51bGwgJiYgb2xkVmFsICE9PSAnJyA/IFN0cmluZyhvbGRWYWwpIDogJyh0cuG7kW5nKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzcGxheSA9IG5ld1ZhbCAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbCAhPT0gbnVsbCAmJiBuZXdWYWwgIT09ICcnID8gU3RyaW5nKG5ld1ZhbCkgOiAnKHRy4buRbmcpJztcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goYCR7ZmllbGQubGFiZWx9OiAke29sZERpc3BsYXl9IOKGkiAke25ld0Rpc3BsYXl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGhpc3RvcnlFbnRyaWVzLnB1c2goY3JlYXRlVXBkYXRlZEVudHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgIGAke3VzZXJJbmZvLm5hbWV9IMSRw6MgY+G6rXAgbmjhuq10OiAke2NoYW5nZXMuam9pbignLCAnKX1gXHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBjdXN0b21lcldpdGhMaWZlY3ljbGUgPSB7XHJcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRDdXN0b21lcixcclxuICAgICAgICAgICAgbGlmZWN5Y2xlU3RhZ2U6IGNhbGN1bGF0ZUxpZmVjeWNsZVN0YWdlKHVwZGF0ZWRDdXN0b21lciksXHJcbiAgICAgICAgICAgIGFjdGl2aXR5SGlzdG9yeTogYXBwZW5kSGlzdG9yeUVudHJ5KGV4aXN0aW5nQ3VzdG9tZXI/LmFjdGl2aXR5SGlzdG9yeSwgLi4uaGlzdG9yeUVudHJpZXMpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW0N1c3RvbWVyU3RvcmVdIENhbGxpbmcgYmFzZVN0b3JlLnVwZGF0ZSB3aXRoOicsIGN1c3RvbWVyV2l0aExpZmVjeWNsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgdXBkYXRlIGZ1bmN0aW9uIGZyb20gYmFzZVN0b3JlIGRpcmVjdGx5XHJcbiAgICAgICAgYmFzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlKHN5c3RlbUlkLCBjdXN0b21lcldpdGhMaWZlY3ljbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbQ3VzdG9tZXJTdG9yZV0gU3RhdGUgYWZ0ZXIgdXBkYXRlOicsIGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmRhdGEuZmluZChjID0+IGMuc3lzdGVtSWQgPT09IHN5c3RlbUlkKSk7XHJcbiAgICB9LFxyXG4gICAgLy8gR2V0IGN1c3RvbWVycyB3aXRoIGhpZ2ggZGVidCByaXNrXHJcbiAgICBnZXRIaWdoUmlza0RlYnRDdXN0b21lcnM6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBhY3RpdmVDdXN0b21lcnMgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5nZXRBY3RpdmUoKTtcclxuICAgICAgICByZXR1cm4gZ2V0SGlnaFJpc2tEZWJ0Q3VzdG9tZXJzKGFjdGl2ZUN1c3RvbWVycyk7XHJcbiAgICB9LFxyXG4gICAgLy8gQmF0Y2ggdXBkYXRlIGN1c3RvbWVyIGludGVsbGlnZW5jZSAoUkZNLCBoZWFsdGggc2NvcmUsIGNodXJuIHJpc2spXHJcbiAgICB1cGRhdGVDdXN0b21lckludGVsbGlnZW5jZTogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFsbEN1c3RvbWVycyA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmdldEFjdGl2ZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tZXIuaXNEZWxldGVkKSByZXR1cm4gY3VzdG9tZXI7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBSRk1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJmbVNjb3JlcyA9IGNhbGN1bGF0ZVJGTVNjb3JlcyhjdXN0b21lciwgYWxsQ3VzdG9tZXJzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBnZXRDdXN0b21lclNlZ21lbnQocmZtU2NvcmVzKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGhlYWx0aCBzY29yZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhbHRoU2NvcmUgPSBjYWxjdWxhdGVIZWFsdGhTY29yZShjdXN0b21lcik7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaHVybiByaXNrXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVyblJpc2sgPSBjYWxjdWxhdGVDaHVyblJpc2soY3VzdG9tZXIpLnJpc2s7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsaWZlY3ljbGUgc3RhZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZmVjeWNsZVN0YWdlID0gY2FsY3VsYXRlTGlmZWN5Y2xlU3RhZ2UoY3VzdG9tZXIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHJmbVNjb3JlcyxcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWx0aFNjb3JlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNodXJuUmlzayxcclxuICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGVTdGFnZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gR2V0IGN1c3RvbWVycyBieSBzZWdtZW50XHJcbiAgICBnZXRDdXN0b21lcnNCeVNlZ21lbnQ6IChzZWdtZW50OiBzdHJpbmcpID0+IHtcclxuICAgICAgICByZXR1cm4gYmFzZVN0b3JlLmdldFN0YXRlKCkuZ2V0QWN0aXZlKCkuZmlsdGVyKGMgPT4gYy5zZWdtZW50ID09PSBzZWdtZW50KTtcclxuICAgIH0sXHJcbiAgICAvLyBHZXQgY3VzdG9tZXJzIHdpdGggb3ZlcmR1ZSBkZWJ0XHJcbiAgICBnZXRPdmVyZHVlRGVidEN1c3RvbWVyczogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUN1c3RvbWVycyA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmdldEFjdGl2ZSgpO1xyXG4gICAgICAgIHJldHVybiBnZXRPdmVyZHVlRGVidEN1c3RvbWVycyhhY3RpdmVDdXN0b21lcnMpO1xyXG4gICAgfSxcclxuICAgIC8vIEdldCBjdXN0b21lcnMgd2l0aCBkZWJ0IGR1ZSBzb29uXHJcbiAgICBnZXREdWVTb29uQ3VzdG9tZXJzOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlQ3VzdG9tZXJzID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZ2V0QWN0aXZlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldER1ZVNvb25DdXN0b21lcnMoYWN0aXZlQ3VzdG9tZXJzKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVNYW55OiAoc3lzdGVtSWRzOiBTeXN0ZW1JZFtdKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzeXN0ZW1JZHMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgZGVsZXRlZEF0VGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PlxyXG4gICAgICAgICAgICAgICAgc3lzdGVtSWRzLmluY2x1ZGVzKGN1c3RvbWVyLnN5c3RlbUlkKVxyXG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5jdXN0b21lciwgaXNEZWxldGVkOiB0cnVlLCBkZWxldGVkQXQ6IGRlbGV0ZWRBdFRpbWVzdGFtcCB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21lclxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZU1hbnlTdGF0dXM6IChzeXN0ZW1JZHM6IFN5c3RlbUlkW10sIHN0YXR1czogQ3VzdG9tZXJbJ3N0YXR1cyddKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzeXN0ZW1JZHMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKGN1c3RvbWVyID0+XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZHMuaW5jbHVkZXMoY3VzdG9tZXIuc3lzdGVtSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IC4uLmN1c3RvbWVyLCBzdGF0dXMgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogY3VzdG9tZXJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICByZXN0b3JlTWFueTogKHN5c3RlbUlkczogU3lzdGVtSWRbXSkgPT4ge1xyXG4gICAgICAgIGlmICghc3lzdGVtSWRzLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChjdXN0b21lciA9PlxyXG4gICAgICAgICAgICAgICAgc3lzdGVtSWRzLmluY2x1ZGVzKGN1c3RvbWVyLnN5c3RlbUlkKVxyXG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5jdXN0b21lciwgaXNEZWxldGVkOiBmYWxzZSwgZGVsZXRlZEF0OiBudWxsIH1cclxuICAgICAgICAgICAgICAgICAgICA6IGN1c3RvbWVyXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG50eXBlIEN1c3RvbWVyU3RvcmVTZWxlY3RvcjxUPiA9IChzdGF0ZTogQ3VzdG9tZXJTdG9yZVN0YXRlKSA9PiBUO1xyXG5cclxubGV0IGNhY2hlZEJhc2VTdGF0ZTogQ3J1ZFN0YXRlPEN1c3RvbWVyPiB8IG51bGwgPSBudWxsO1xyXG5sZXQgY2FjaGVkQ29tYmluZWRTdGF0ZTogQ3VzdG9tZXJTdG9yZVN0YXRlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5jb25zdCBnZXRDb21iaW5lZFN0YXRlID0gKHN0YXRlOiBDcnVkU3RhdGU8Q3VzdG9tZXI+KTogQ3VzdG9tZXJTdG9yZVN0YXRlID0+IHtcclxuICAgIGlmIChjYWNoZWRCYXNlU3RhdGUgIT09IHN0YXRlIHx8ICFjYWNoZWRDb21iaW5lZFN0YXRlKSB7XHJcbiAgICAgICAgY2FjaGVkQmFzZVN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgY2FjaGVkQ29tYmluZWRTdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLmF1Z21lbnRlZE1ldGhvZHMgfSBhcyBDdXN0b21lclN0b3JlU3RhdGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGVkQ29tYmluZWRTdGF0ZSE7XHJcbn07XHJcblxyXG5jb25zdCBib3VuZFN0b3JlID0gYmFzZVN0b3JlIGFzIHVua25vd24gYXMge1xyXG4gICAgPFI+KHNlbGVjdG9yOiAoc3RhdGU6IENydWRTdGF0ZTxDdXN0b21lcj4pID0+IFIsIGVxdWFsaXR5Rm4/OiAoYTogUiwgYjogUikgPT4gYm9vbGVhbik6IFI7XHJcbiAgICAoKTogQ3VzdG9tZXJTdG9yZVN0YXRlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUN1c3RvbWVyU3RvcmUgPSA8VCA9IEN1c3RvbWVyU3RvcmVTdGF0ZT4oXHJcbiAgICBzZWxlY3Rvcj86IEN1c3RvbWVyU3RvcmVTZWxlY3RvcjxUPixcclxuICAgIGVxdWFsaXR5Rm4/OiAoYTogVCwgYjogVCkgPT4gYm9vbGVhblxyXG4pOiBUID0+IHtcclxuICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChlcXVhbGl0eUZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBib3VuZFN0b3JlKChzdGF0ZSkgPT4gc2VsZWN0b3IoZ2V0Q29tYmluZWRTdGF0ZShzdGF0ZSkpLCBlcXVhbGl0eUZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kU3RvcmUoKHN0YXRlKSA9PiBzZWxlY3RvcihnZXRDb21iaW5lZFN0YXRlKHN0YXRlKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJvdW5kU3RvcmUoKHN0YXRlKSA9PiBnZXRDb21iaW5lZFN0YXRlKHN0YXRlKSBhcyB1bmtub3duIGFzIFQpO1xyXG59O1xyXG5cclxudXNlQ3VzdG9tZXJTdG9yZS5nZXRTdGF0ZSA9ICgpOiBDdXN0b21lclN0b3JlU3RhdGUgPT4ge1xyXG4gICAgcmV0dXJuIGdldENvbWJpbmVkU3RhdGUoYmFzZVN0b3JlLmdldFN0YXRlKCkpO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ3J1ZFN0b3JlIiwiY2FsY3VsYXRlTGlmZWN5Y2xlU3RhZ2UiLCJnZXRIaWdoUmlza0RlYnRDdXN0b21lcnMiLCJjYWxjdWxhdGVSRk1TY29yZXMiLCJnZXRDdXN0b21lclNlZ21lbnQiLCJjYWxjdWxhdGVIZWFsdGhTY29yZSIsImNhbGN1bGF0ZUNodXJuUmlzayIsImdldE92ZXJkdWVEZWJ0Q3VzdG9tZXJzIiwiZ2V0RHVlU29vbkN1c3RvbWVycyIsIkZ1c2UiLCJnZXRDdXJyZW50VXNlclN5c3RlbUlkIiwiZ2V0Q3VycmVudFVzZXJJbmZvIiwiY3JlYXRlQ3JlYXRlZEVudHJ5IiwiY3JlYXRlVXBkYXRlZEVudHJ5IiwiY3JlYXRlU3RhdHVzQ2hhbmdlZEVudHJ5IiwiYXBwZW5kSGlzdG9yeUVudHJ5IiwiYmFzZVN0b3JlIiwiYnVzaW5lc3NJZEZpZWxkIiwiZ2V0Q3VycmVudFVzZXIiLCJhcGlFbmRwb2ludCIsIkFQSV9FTkRQT0lOVCIsInN5bmNUb0FwaSIsImNyZWF0ZSIsImN1c3RvbWVyIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwid2FybiIsImxvZyIsInN5c3RlbUlkIiwiZSIsInVwZGF0ZSIsInVwZGF0ZXMiLCJkZWxldGUiLCJoYXJkIiwicmVzdG9yZSIsIm9yaWdpbmFsQWRkIiwiZ2V0U3RhdGUiLCJhZGQiLCJvcmlnaW5hbFVwZGF0ZSIsIm9yaWdpbmFsUmVtb3ZlIiwicmVtb3ZlIiwib3JpZ2luYWxIYXJkRGVsZXRlIiwiaGFyZERlbGV0ZSIsIm9yaWdpbmFsUmVzdG9yZSIsInNldFN0YXRlIiwiaXRlbSIsInJlc3VsdCIsImF1Z21lbnRlZE1ldGhvZHMiLCJzZWFyY2hDdXN0b21lcnMiLCJxdWVyeSIsInBhZ2UiLCJsaW1pdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImFsbEN1c3RvbWVycyIsImRhdGEiLCJmdXNlIiwia2V5cyIsInRocmVzaG9sZCIsInJlc3VsdHMiLCJzZWFyY2giLCJtYXAiLCJyIiwic3RhcnQiLCJlbmQiLCJwYWdpbmF0ZWRJdGVtcyIsInNsaWNlIiwiaXRlbXMiLCJjIiwidmFsdWUiLCJsYWJlbCIsIm5hbWUiLCJoYXNOZXh0UGFnZSIsImxlbmd0aCIsInVwZGF0ZURlYnQiLCJhbW91bnRDaGFuZ2UiLCJzdGF0ZSIsIm5ld0RlYnQiLCJjdXJyZW50RGVidCIsImluY3JlbWVudE9yZGVyU3RhdHMiLCJvcmRlclZhbHVlIiwiZ2V0QWN0aXZlIiwidXBkYXRlZEN1c3RvbWVyIiwidG90YWxPcmRlcnMiLCJ0b3RhbFNwZW50IiwibGFzdFB1cmNoYXNlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwicmZtU2NvcmVzIiwic2VnbWVudCIsImhlYWx0aFNjb3JlIiwiY2h1cm5SaXNrIiwicmlzayIsImxpZmVjeWNsZVN0YWdlIiwiZGVjcmVtZW50T3JkZXJTdGF0cyIsIk1hdGgiLCJtYXgiLCJpbmNyZW1lbnRSZXR1cm5TdGF0cyIsInF1YW50aXR5IiwidG90YWxRdWFudGl0eVJldHVybmVkIiwiaW5jcmVtZW50RmFpbGVkRGVsaXZlcnlTdGF0cyIsImZhaWxlZERlbGl2ZXJpZXMiLCJhZGREZWJ0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImN1cnJlbnRUcmFuc2FjdGlvbnMiLCJkZWJ0VHJhbnNhY3Rpb25zIiwic29tZSIsInQiLCJvcmRlcklkIiwib3V0c3RhbmRpbmdBbW91bnQiLCJyZW1haW5pbmdBbW91bnQiLCJhbW91bnQiLCJ1cGRhdGVEZWJ0VHJhbnNhY3Rpb25QYXltZW50IiwiYW1vdW50UGFpZCIsImRlYnREZWx0YSIsInVwZGF0ZWRUcmFuc2FjdGlvbnMiLCJjdXJyZW50UGFpZCIsInBhaWRBbW91bnQiLCJjdXJyZW50UmVtYWluaW5nIiwiYXBwbGllZEFtb3VudCIsIm1pbiIsIm5ld1BhaWRBbW91bnQiLCJyZWNhbGN1bGF0ZWRSZW1haW5pbmciLCJpc1BhaWQiLCJwYWlkRGF0ZSIsInJlbW92ZURlYnRUcmFuc2FjdGlvbiIsImZpbmQiLCJvdXRzdGFuZGluZyIsImZpbHRlciIsImFkZERlYnRSZW1pbmRlciIsInJlbWluZGVyIiwiY3VycmVudFJlbWluZGVycyIsImRlYnRSZW1pbmRlcnMiLCJ1cGRhdGVEZWJ0UmVtaW5kZXIiLCJyZW1pbmRlcklkIiwicmVtb3ZlRGVidFJlbWluZGVyIiwidXNlckluZm8iLCJjdXN0b21lcldpdGhMaWZlY3ljbGUiLCJuZXdDdXN0b21lciIsImhpc3RvcnlFbnRyeSIsImlkIiwiYWN0aXZpdHlIaXN0b3J5IiwiZXhpc3RpbmdDdXN0b21lciIsImhpc3RvcnlFbnRyaWVzIiwic3RhdHVzIiwicHVzaCIsImZpZWxkc1RvVHJhY2siLCJrZXkiLCJjaGFuZ2VzIiwiZmllbGQiLCJvbGRWYWwiLCJuZXdWYWwiLCJ1bmRlZmluZWQiLCJvbGREaXNwbGF5IiwiU3RyaW5nIiwibmV3RGlzcGxheSIsImpvaW4iLCJhY3RpdmVDdXN0b21lcnMiLCJ1cGRhdGVDdXN0b21lckludGVsbGlnZW5jZSIsImlzRGVsZXRlZCIsImdldEN1c3RvbWVyc0J5U2VnbWVudCIsInJlbW92ZU1hbnkiLCJzeXN0ZW1JZHMiLCJkZWxldGVkQXRUaW1lc3RhbXAiLCJpbmNsdWRlcyIsImRlbGV0ZWRBdCIsInVwZGF0ZU1hbnlTdGF0dXMiLCJyZXN0b3JlTWFueSIsImNhY2hlZEJhc2VTdGF0ZSIsImNhY2hlZENvbWJpbmVkU3RhdGUiLCJnZXRDb21iaW5lZFN0YXRlIiwiYm91bmRTdG9yZSIsInVzZUN1c3RvbWVyU3RvcmUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/customers/store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./features/products/store.ts":
/*!************************************!*\
  !*** ./features/products/store.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProductStore: () => (/* binding */ useProductStore)\n/* harmony export */ });\n/* harmony import */ var _lib_store_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/store-factory */ \"(app-pages-browser)/./lib/store-factory.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fuse.js */ \"(app-pages-browser)/./node_modules/fuse.js/dist/fuse.mjs\");\n/* harmony import */ var _lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/activity-history-helper */ \"(app-pages-browser)/./lib/activity-history-helper.ts\");\n\n\n\n\n\nconst baseStore = (0,_lib_store_factory__WEBPACK_IMPORTED_MODULE_0__.createCrudStore)([], 'products', {\n    businessIdField: 'id',\n    getCurrentUser: _contexts_auth_context__WEBPACK_IMPORTED_MODULE_2__.getCurrentUserSystemId,\n    apiEndpoint: '/api/products'\n});\n// ✅ API Sync helpers\nconst API_ENDPOINT = '/api/products';\nconst syncToApi = {\n    create: async (product)=>{\n        try {\n            const response = await fetch(API_ENDPOINT, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(product)\n            });\n            if (!response.ok) console.warn('[Product API] Create sync failed');\n            else console.log('[Product API] Created:', product.systemId);\n        } catch (e) {\n            console.warn('[Product API] Create sync error:', e);\n        }\n    },\n    update: async (systemId, updates)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'PATCH',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(updates)\n            });\n            if (!response.ok) console.warn('[Product API] Update sync failed');\n            else console.log('[Product API] Updated:', systemId);\n        } catch (e) {\n            console.warn('[Product API] Update sync error:', e);\n        }\n    },\n    delete: async (systemId, hard = false)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'DELETE',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    hard\n                })\n            });\n            if (!response.ok) console.warn('[Product API] Delete sync failed');\n            else console.log('[Product API] Deleted:', systemId);\n        } catch (e) {\n            console.warn('[Product API] Delete sync error:', e);\n        }\n    },\n    restore: async (systemId)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}/restore`, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) console.warn('[Product API] Restore sync failed');\n            else console.log('[Product API] Restored:', systemId);\n        } catch (e) {\n            console.warn('[Product API] Restore sync error:', e);\n        }\n    }\n};\n// ✅ Wrap base store methods with API sync\nconst originalAdd = baseStore.getState().add;\nconst originalUpdate = baseStore.getState().update;\nconst originalRemove = baseStore.getState().remove;\nconst originalHardDelete = baseStore.getState().hardDelete;\nconst originalRestore = baseStore.getState().restore;\nbaseStore.setState({\n    add: (item)=>{\n        const result = originalAdd(item);\n        syncToApi.create(result);\n        return result;\n    },\n    update: (systemId, updates)=>{\n        originalUpdate(systemId, updates);\n        syncToApi.update(systemId, updates);\n    },\n    remove: (systemId)=>{\n        originalRemove(systemId);\n        syncToApi.delete(systemId, false);\n    },\n    hardDelete: (systemId)=>{\n        originalHardDelete(systemId);\n        syncToApi.delete(systemId, true);\n    },\n    restore: (systemId)=>{\n        originalRestore(systemId);\n        syncToApi.restore(systemId);\n    }\n});\n// Helper to check if product tracks stock\nconst canModifyStock = (product)=>{\n    if (!product) return false;\n    // Services, digital products, and combos don't track stock directly\n    if (product.type === 'service' || product.type === 'digital' || product.type === 'combo') return false;\n    // Explicitly disabled stock tracking\n    if (product.isStockTracked === false) return false;\n    return true;\n};\n// Define custom methods\nconst updateInventory = (productSystemId, branchSystemId, quantityChange)=>{\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!product) return state;\n        // Skip if product doesn't track stock\n        if (!canModifyStock(product)) {\n            console.warn(`[updateInventory] Skipped: Product ${productSystemId} does not track stock`);\n            return state;\n        }\n        const oldQuantity = product.inventoryByBranch?.[branchSystemId] || 0;\n        const newQuantity = oldQuantity + quantityChange;\n        // ✅ Removed COMPLAINT_ADJUSTMENT stock history creation\n        // Stock history will be created by inventory check balance instead\n        return {\n            data: state.data.map((p)=>{\n                if (p.systemId === productSystemId) {\n                    const newInventoryByBranch = {\n                        ...p.inventoryByBranch\n                    };\n                    newInventoryByBranch[branchSystemId] = newQuantity;\n                    return {\n                        ...p,\n                        inventoryByBranch: newInventoryByBranch\n                    };\n                }\n                return p;\n            })\n        };\n    });\n};\nconst commitStock = (productSystemId, branchSystemId, quantity)=>{\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!canModifyStock(product)) {\n            console.warn(`[commitStock] Skipped: Product ${productSystemId} does not track stock`);\n            return state;\n        }\n        return {\n            data: state.data.map((p)=>{\n                if (p.systemId === productSystemId) {\n                    const newCommitted = {\n                        ...p.committedByBranch\n                    };\n                    newCommitted[branchSystemId] = (newCommitted[branchSystemId] || 0) + quantity;\n                    return {\n                        ...p,\n                        committedByBranch: newCommitted\n                    };\n                }\n                return p;\n            })\n        };\n    });\n};\nconst uncommitStock = (productSystemId, branchSystemId, quantity)=>{\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!canModifyStock(product)) {\n            console.warn(`[uncommitStock] Skipped: Product ${productSystemId} does not track stock`);\n            return state;\n        }\n        return {\n            data: state.data.map((p)=>{\n                if (p.systemId === productSystemId) {\n                    const newCommitted = {\n                        ...p.committedByBranch\n                    };\n                    newCommitted[branchSystemId] = Math.max(0, (newCommitted[branchSystemId] || 0) - quantity);\n                    return {\n                        ...p,\n                        committedByBranch: newCommitted\n                    };\n                }\n                return p;\n            })\n        };\n    });\n};\nconst dispatchStock = (productSystemId, branchSystemId, quantity)=>{\n    console.log('🔴 [dispatchStock] Called with:', {\n        productSystemId,\n        branchSystemId,\n        quantity\n    });\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!product) {\n            console.error('❌ [dispatchStock] Product not found:', productSystemId);\n            return state;\n        }\n        // Skip if product doesn't track stock\n        if (!canModifyStock(product)) {\n            console.warn(`[dispatchStock] Skipped: Product ${productSystemId} does not track stock`);\n            return state;\n        }\n        console.log('📦 [dispatchStock] Current inventory:', product.inventoryByBranch);\n        console.log('📦 [dispatchStock] Current committed:', product.committedByBranch);\n        return {\n            data: state.data.map((product)=>{\n                if (product.systemId === productSystemId) {\n                    const newInventory = {\n                        ...product.inventoryByBranch\n                    };\n                    const oldInventory = newInventory[branchSystemId] || 0;\n                    newInventory[branchSystemId] = oldInventory - quantity;\n                    const newCommitted = {\n                        ...product.committedByBranch\n                    };\n                    newCommitted[branchSystemId] = Math.max(0, (newCommitted[branchSystemId] || 0) - quantity);\n                    const newInTransit = {\n                        ...product.inTransitByBranch\n                    };\n                    newInTransit[branchSystemId] = (newInTransit[branchSystemId] || 0) + quantity;\n                    console.log('✅ [dispatchStock] Updated inventory:', {\n                        old: oldInventory,\n                        new: newInventory[branchSystemId],\n                        change: -quantity\n                    });\n                    return {\n                        ...product,\n                        inventoryByBranch: newInventory,\n                        committedByBranch: newCommitted,\n                        inTransitByBranch: newInTransit\n                    };\n                }\n                return product;\n            })\n        };\n    });\n    console.log('✅ [dispatchStock] Completed');\n};\nconst completeDelivery = (productSystemId, branchSystemId, quantity)=>{\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!canModifyStock(product)) {\n            return state;\n        }\n        return {\n            data: state.data.map((p)=>{\n                if (p.systemId === productSystemId) {\n                    const newInTransit = {\n                        ...p.inTransitByBranch\n                    };\n                    newInTransit[branchSystemId] = Math.max(0, (newInTransit[branchSystemId] || 0) - quantity);\n                    return {\n                        ...p,\n                        inTransitByBranch: newInTransit\n                    };\n                }\n                return p;\n            })\n        };\n    });\n};\nconst returnStockFromTransit = (productSystemId, branchSystemId, quantity)=>{\n    baseStore.setState((state)=>{\n        const product = state.data.find((p)=>p.systemId === productSystemId);\n        if (!canModifyStock(product)) {\n            return state;\n        }\n        return {\n            data: state.data.map((p)=>{\n                if (p.systemId === productSystemId) {\n                    const newInTransit = {\n                        ...p.inTransitByBranch\n                    };\n                    newInTransit[branchSystemId] = Math.max(0, (newInTransit[branchSystemId] || 0) - quantity);\n                    const newInventory = {\n                        ...p.inventoryByBranch\n                    };\n                    newInventory[branchSystemId] = (newInventory[branchSystemId] || 0) + quantity;\n                    return {\n                        ...p,\n                        inventoryByBranch: newInventory,\n                        inTransitByBranch: newInTransit\n                    };\n                }\n                return p;\n            })\n        };\n    });\n};\nconst updateLastPurchasePrice = (productSystemId, price, date)=>{\n    baseStore.setState((state)=>({\n            data: state.data.map((product)=>{\n                if (product.systemId === productSystemId) {\n                    // Only update if the new date is newer or equal to the existing lastPurchaseDate\n                    const existingDate = product.lastPurchaseDate ? new Date(product.lastPurchaseDate).getTime() : 0;\n                    const newDateTs = new Date(date).getTime();\n                    if (newDateTs >= existingDate) {\n                        return {\n                            ...product,\n                            lastPurchasePrice: price,\n                            lastPurchaseDate: date\n                        };\n                    }\n                }\n                return product;\n            })\n        }));\n};\nconst searchProducts = async (query, page = 1, limit = 10)=>{\n    const allProducts = baseStore.getState().data;\n    // ✅ Create fresh Fuse instance with current data (avoid stale data)\n    const fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](allProducts, {\n        keys: [\n            'name',\n            'id',\n            'sku',\n            'barcode'\n        ],\n        threshold: 0.3\n    });\n    const results = fuse.search(query);\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    const paginatedResults = results.slice(startIndex, endIndex);\n    return {\n        items: paginatedResults.map((result)=>({\n                value: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)(result.item.systemId),\n                label: `${result.item.name} (${result.item.id})`\n            })),\n        hasNextPage: endIndex < results.length\n    };\n};\n// Wrapped add method with activity history logging\nconst addProduct = (product)=>{\n    const userInfo = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.getCurrentUserInfo)();\n    const newProduct = baseStore.getState().add(product);\n    // Add activity history entry\n    const historyEntry = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.createCreatedEntry)(userInfo, `${userInfo.name} đã tạo sản phẩm ${newProduct.name} (${newProduct.id})`);\n    baseStore.getState().update(newProduct.systemId, {\n        ...newProduct,\n        activityHistory: [\n            historyEntry\n        ]\n    });\n    return newProduct;\n};\n// Wrapped update method with activity history logging\nconst updateProduct = (systemId, updatedProduct)=>{\n    const userInfo = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.getCurrentUserInfo)();\n    const existingProduct = baseStore.getState().data.find((p)=>p.systemId === systemId);\n    const historyEntries = [];\n    if (existingProduct) {\n        // Track status changes\n        if (existingProduct.status !== updatedProduct.status) {\n            const statusLabels = {\n                'active': 'Đang kinh doanh',\n                'inactive': 'Ngừng kinh doanh',\n                'discontinued': 'Ngừng sản xuất'\n            };\n            historyEntries.push((0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.createStatusChangedEntry)(userInfo, statusLabels[existingProduct.status || 'active'], statusLabels[updatedProduct.status || 'active'], `${userInfo.name} đã đổi trạng thái từ \"${statusLabels[existingProduct.status || 'active']}\" sang \"${statusLabels[updatedProduct.status || 'active']}\"`));\n        }\n        // Track field changes\n        const fieldsToTrack = [\n            {\n                key: 'name',\n                label: 'Tên sản phẩm'\n            },\n            {\n                key: 'id',\n                label: 'Mã SKU'\n            },\n            {\n                key: 'description',\n                label: 'Mô tả'\n            },\n            {\n                key: 'shortDescription',\n                label: 'Mô tả ngắn'\n            },\n            {\n                key: 'type',\n                label: 'Loại sản phẩm'\n            },\n            {\n                key: 'categorySystemId',\n                label: 'Danh mục'\n            },\n            {\n                key: 'brandSystemId',\n                label: 'Thương hiệu'\n            },\n            {\n                key: 'unit',\n                label: 'Đơn vị tính'\n            },\n            {\n                key: 'costPrice',\n                label: 'Giá vốn'\n            },\n            {\n                key: 'minPrice',\n                label: 'Giá tối thiểu'\n            },\n            {\n                key: 'barcode',\n                label: 'Mã vạch'\n            },\n            {\n                key: 'primarySupplierSystemId',\n                label: 'Nhà cung cấp chính'\n            },\n            {\n                key: 'warrantyPeriodMonths',\n                label: 'Thời hạn bảo hành'\n            },\n            {\n                key: 'reorderLevel',\n                label: 'Mức đặt hàng lại'\n            },\n            {\n                key: 'safetyStock',\n                label: 'Tồn kho an toàn'\n            },\n            {\n                key: 'maxStock',\n                label: 'Tồn kho tối đa'\n            }\n        ];\n        const changes = [];\n        for (const field of fieldsToTrack){\n            const oldVal = existingProduct[field.key];\n            const newVal = updatedProduct[field.key];\n            if (oldVal !== newVal && !(oldVal === undefined && newVal === undefined)) {\n                if (field.key === 'status') continue;\n                const oldDisplay = oldVal !== undefined && oldVal !== null && oldVal !== '' ? String(oldVal) : '(trống)';\n                const newDisplay = newVal !== undefined && newVal !== null && newVal !== '' ? String(newVal) : '(trống)';\n                changes.push(`${field.label}: ${oldDisplay} → ${newDisplay}`);\n            }\n        }\n        // Track price changes separately\n        if (existingProduct.costPrice !== updatedProduct.costPrice) {\n            changes.push(`Giá vốn: ${existingProduct.costPrice?.toLocaleString('vi-VN')} → ${updatedProduct.costPrice?.toLocaleString('vi-VN')}`);\n        }\n        if (changes.length > 0) {\n            historyEntries.push((0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.createUpdatedEntry)(userInfo, `${userInfo.name} đã cập nhật: ${changes.join(', ')}`));\n        }\n    }\n    const productWithHistory = {\n        ...updatedProduct,\n        activityHistory: (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_3__.appendHistoryEntry)(existingProduct?.activityHistory, ...historyEntries)\n    };\n    baseStore.getState().update(systemId, productWithHistory);\n};\n// Export typed hook that includes both base and custom methods\nconst useProductStore = ()=>{\n    const state = baseStore();\n    return {\n        ...state,\n        add: addProduct,\n        update: updateProduct,\n        updateInventory,\n        commitStock,\n        uncommitStock,\n        dispatchStock,\n        completeDelivery,\n        returnStockFromTransit,\n        updateLastPurchasePrice,\n        searchProducts\n    };\n};\n// Export getState method for non-hook usage\nuseProductStore.getState = ()=>{\n    const state = baseStore.getState();\n    return {\n        ...state,\n        add: addProduct,\n        update: updateProduct,\n        updateInventory,\n        commitStock,\n        uncommitStock,\n        dispatchStock,\n        completeDelivery,\n        returnStockFromTransit,\n        updateLastPurchasePrice,\n        searchProducts\n    };\n};\nuseProductStore.subscribe = baseStore.subscribe;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3Byb2R1Y3RzL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFxRTtBQUlQO0FBQ087QUFDMUM7QUFRZ0I7QUFFM0MsTUFBTVMsWUFBWVQsbUVBQWVBLENBQVUsRUFBRSxFQUFFLFlBQVk7SUFDekRVLGlCQUFpQjtJQUNqQkMsZ0JBQWdCVCwwRUFBc0JBO0lBQ3RDVSxhQUFhO0FBQ2Y7QUFFQSxxQkFBcUI7QUFDckIsTUFBTUMsZUFBZTtBQUVyQixNQUFNQyxZQUFZO0lBQ2hCQyxRQUFRLE9BQU9DO1FBQ2IsSUFBSTtZQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUwsY0FBYztnQkFDekNNLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ1I7WUFDdkI7WUFDQSxJQUFJLENBQUNDLFNBQVNRLEVBQUUsRUFBRUMsUUFBUUMsSUFBSSxDQUFDO2lCQUMxQkQsUUFBUUUsR0FBRyxDQUFDLDBCQUEwQlosUUFBUWEsUUFBUTtRQUM3RCxFQUFFLE9BQU9DLEdBQUc7WUFDVkosUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ0c7UUFDbkQ7SUFDRjtJQUNBQyxRQUFRLE9BQU9GLFVBQW9CRztRQUNqQyxJQUFJO1lBQ0YsTUFBTWYsV0FBVyxNQUFNQyxNQUFNLEdBQUdMLGFBQWEsQ0FBQyxFQUFFZ0IsVUFBVSxFQUFFO2dCQUMxRFYsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDUTtZQUN2QjtZQUNBLElBQUksQ0FBQ2YsU0FBU1EsRUFBRSxFQUFFQyxRQUFRQyxJQUFJLENBQUM7aUJBQzFCRCxRQUFRRSxHQUFHLENBQUMsMEJBQTBCQztRQUM3QyxFQUFFLE9BQU9DLEdBQUc7WUFDVkosUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ0c7UUFDbkQ7SUFDRjtJQUNBRyxRQUFRLE9BQU9KLFVBQW9CSyxPQUFPLEtBQUs7UUFDN0MsSUFBSTtZQUNGLE1BQU1qQixXQUFXLE1BQU1DLE1BQU0sR0FBR0wsYUFBYSxDQUFDLEVBQUVnQixVQUFVLEVBQUU7Z0JBQzFEVixRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVVO2dCQUFLO1lBQzlCO1lBQ0EsSUFBSSxDQUFDakIsU0FBU1EsRUFBRSxFQUFFQyxRQUFRQyxJQUFJLENBQUM7aUJBQzFCRCxRQUFRRSxHQUFHLENBQUMsMEJBQTBCQztRQUM3QyxFQUFFLE9BQU9DLEdBQUc7WUFDVkosUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ0c7UUFDbkQ7SUFDRjtJQUNBSyxTQUFTLE9BQU9OO1FBQ2QsSUFBSTtZQUNGLE1BQU1aLFdBQVcsTUFBTUMsTUFBTSxHQUFHTCxhQUFhLENBQUMsRUFBRWdCLFNBQVMsUUFBUSxDQUFDLEVBQUU7Z0JBQ2xFVixRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFDaEQ7WUFDQSxJQUFJLENBQUNKLFNBQVNRLEVBQUUsRUFBRUMsUUFBUUMsSUFBSSxDQUFDO2lCQUMxQkQsUUFBUUUsR0FBRyxDQUFDLDJCQUEyQkM7UUFDOUMsRUFBRSxPQUFPQyxHQUFHO1lBQ1ZKLFFBQVFDLElBQUksQ0FBQyxxQ0FBcUNHO1FBQ3BEO0lBQ0Y7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxNQUFNTSxjQUFjM0IsVUFBVTRCLFFBQVEsR0FBR0MsR0FBRztBQUM1QyxNQUFNQyxpQkFBaUI5QixVQUFVNEIsUUFBUSxHQUFHTixNQUFNO0FBQ2xELE1BQU1TLGlCQUFpQi9CLFVBQVU0QixRQUFRLEdBQUdJLE1BQU07QUFDbEQsTUFBTUMscUJBQXFCakMsVUFBVTRCLFFBQVEsR0FBR00sVUFBVTtBQUMxRCxNQUFNQyxrQkFBa0JuQyxVQUFVNEIsUUFBUSxHQUFHRixPQUFPO0FBRXBEMUIsVUFBVW9DLFFBQVEsQ0FBQztJQUNqQlAsS0FBSyxDQUFDUTtRQUNKLE1BQU1DLFNBQVNYLFlBQVlVO1FBQzNCaEMsVUFBVUMsTUFBTSxDQUFDZ0M7UUFDakIsT0FBT0E7SUFDVDtJQUNBaEIsUUFBUSxDQUFDRixVQUFvQkc7UUFDM0JPLGVBQWVWLFVBQVVHO1FBQ3pCbEIsVUFBVWlCLE1BQU0sQ0FBQ0YsVUFBVUc7SUFDN0I7SUFDQVMsUUFBUSxDQUFDWjtRQUNQVyxlQUFlWDtRQUNmZixVQUFVbUIsTUFBTSxDQUFDSixVQUFVO0lBQzdCO0lBQ0FjLFlBQVksQ0FBQ2Q7UUFDWGEsbUJBQW1CYjtRQUNuQmYsVUFBVW1CLE1BQU0sQ0FBQ0osVUFBVTtJQUM3QjtJQUNBTSxTQUFTLENBQUNOO1FBQ1JlLGdCQUFnQmY7UUFDaEJmLFVBQVVxQixPQUFPLENBQUNOO0lBQ3BCO0FBQ0Y7QUFjQSwwQ0FBMEM7QUFDMUMsTUFBTW1CLGlCQUFpQixDQUFDaEM7SUFDdEIsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsb0VBQW9FO0lBQ3BFLElBQUlBLFFBQVFpQyxJQUFJLEtBQUssYUFBYWpDLFFBQVFpQyxJQUFJLEtBQUssYUFBYWpDLFFBQVFpQyxJQUFJLEtBQUssU0FBUyxPQUFPO0lBQ2pHLHFDQUFxQztJQUNyQyxJQUFJakMsUUFBUWtDLGNBQWMsS0FBSyxPQUFPLE9BQU87SUFDN0MsT0FBTztBQUNUO0FBRUEsd0JBQXdCO0FBQ3hCLE1BQU1DLGtCQUFrQixDQUFDQyxpQkFBMkJDLGdCQUEwQkM7SUFDNUU3QyxVQUFVb0MsUUFBUSxDQUFDVSxDQUFBQTtRQUNqQixNQUFNdkMsVUFBVXVDLE1BQU1DLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0IsUUFBUSxLQUFLdUI7UUFDcEQsSUFBSSxDQUFDcEMsU0FBUyxPQUFPdUM7UUFFckIsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ1AsZUFBZWhDLFVBQVU7WUFDNUJVLFFBQVFDLElBQUksQ0FBQyxDQUFDLG1DQUFtQyxFQUFFeUIsZ0JBQWdCLHFCQUFxQixDQUFDO1lBQ3pGLE9BQU9HO1FBQ1Q7UUFFQSxNQUFNSSxjQUFjM0MsUUFBUTRDLGlCQUFpQixFQUFFLENBQUNQLGVBQWUsSUFBSTtRQUNuRSxNQUFNUSxjQUFjRixjQUFjTDtRQUVsQyx3REFBd0Q7UUFDeEQsbUVBQW1FO1FBRW5FLE9BQU87WUFDTEUsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUNKLENBQUFBO2dCQUNuQixJQUFJQSxFQUFFN0IsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUNsQyxNQUFNVyx1QkFBdUI7d0JBQUUsR0FBR0wsRUFBRUUsaUJBQWlCO29CQUFDO29CQUN0REcsb0JBQW9CLENBQUNWLGVBQWUsR0FBR1E7b0JBQ3ZDLE9BQU87d0JBQ0wsR0FBR0gsQ0FBQzt3QkFDSkUsbUJBQW1CRztvQkFDckI7Z0JBQ0Y7Z0JBQ0EsT0FBT0w7WUFDVDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1NLGNBQWMsQ0FBQ1osaUJBQTJCQyxnQkFBMEJZO0lBQ3hFeEQsVUFBVW9DLFFBQVEsQ0FBQ1UsQ0FBQUE7UUFDakIsTUFBTXZDLFVBQVV1QyxNQUFNQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTdCLFFBQVEsS0FBS3VCO1FBQ3BELElBQUksQ0FBQ0osZUFBZWhDLFVBQVU7WUFDNUJVLFFBQVFDLElBQUksQ0FBQyxDQUFDLCtCQUErQixFQUFFeUIsZ0JBQWdCLHFCQUFxQixDQUFDO1lBQ3JGLE9BQU9HO1FBQ1Q7UUFDQSxPQUFPO1lBQ0xDLE1BQU1ELE1BQU1DLElBQUksQ0FBQ00sR0FBRyxDQUFDSixDQUFBQTtnQkFDbkIsSUFBSUEsRUFBRTdCLFFBQVEsS0FBS3VCLGlCQUFpQjtvQkFDbEMsTUFBTWMsZUFBZTt3QkFBRSxHQUFHUixFQUFFUyxpQkFBaUI7b0JBQUM7b0JBQzlDRCxZQUFZLENBQUNiLGVBQWUsR0FBRyxDQUFDYSxZQUFZLENBQUNiLGVBQWUsSUFBSSxLQUFLWTtvQkFDckUsT0FBTzt3QkFBRSxHQUFHUCxDQUFDO3dCQUFFUyxtQkFBbUJEO29CQUFhO2dCQUNqRDtnQkFDQSxPQUFPUjtZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsTUFBTVUsZ0JBQWdCLENBQUNoQixpQkFBMkJDLGdCQUEwQlk7SUFDMUV4RCxVQUFVb0MsUUFBUSxDQUFDVSxDQUFBQTtRQUNqQixNQUFNdkMsVUFBVXVDLE1BQU1DLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0IsUUFBUSxLQUFLdUI7UUFDcEQsSUFBSSxDQUFDSixlQUFlaEMsVUFBVTtZQUM1QlUsUUFBUUMsSUFBSSxDQUFDLENBQUMsaUNBQWlDLEVBQUV5QixnQkFBZ0IscUJBQXFCLENBQUM7WUFDdkYsT0FBT0c7UUFDVDtRQUNBLE9BQU87WUFDTEMsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUNKLENBQUFBO2dCQUNuQixJQUFJQSxFQUFFN0IsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUNsQyxNQUFNYyxlQUFlO3dCQUFFLEdBQUdSLEVBQUVTLGlCQUFpQjtvQkFBQztvQkFDOUNELFlBQVksQ0FBQ2IsZUFBZSxHQUFHZ0IsS0FBS0MsR0FBRyxDQUFDLEdBQUcsQ0FBQ0osWUFBWSxDQUFDYixlQUFlLElBQUksS0FBS1k7b0JBQ2pGLE9BQU87d0JBQUUsR0FBR1AsQ0FBQzt3QkFBRVMsbUJBQW1CRDtvQkFBYTtnQkFDakQ7Z0JBQ0EsT0FBT1I7WUFDVDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1hLGdCQUFnQixDQUFDbkIsaUJBQTJCQyxnQkFBMEJZO0lBQzFFdkMsUUFBUUUsR0FBRyxDQUFDLG1DQUFtQztRQUFFd0I7UUFBaUJDO1FBQWdCWTtJQUFTO0lBRTNGeEQsVUFBVW9DLFFBQVEsQ0FBQ1UsQ0FBQUE7UUFDakIsTUFBTXZDLFVBQVV1QyxNQUFNQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTdCLFFBQVEsS0FBS3VCO1FBQ3BELElBQUksQ0FBQ3BDLFNBQVM7WUFDWlUsUUFBUThDLEtBQUssQ0FBQyx3Q0FBd0NwQjtZQUN0RCxPQUFPRztRQUNUO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ1AsZUFBZWhDLFVBQVU7WUFDNUJVLFFBQVFDLElBQUksQ0FBQyxDQUFDLGlDQUFpQyxFQUFFeUIsZ0JBQWdCLHFCQUFxQixDQUFDO1lBQ3ZGLE9BQU9HO1FBQ1Q7UUFFQTdCLFFBQVFFLEdBQUcsQ0FBQyx5Q0FBeUNaLFFBQVE0QyxpQkFBaUI7UUFDOUVsQyxRQUFRRSxHQUFHLENBQUMseUNBQXlDWixRQUFRbUQsaUJBQWlCO1FBRTlFLE9BQU87WUFDTFgsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUM5QyxDQUFBQTtnQkFDbkIsSUFBSUEsUUFBUWEsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUN4QyxNQUFNcUIsZUFBZTt3QkFBRSxHQUFHekQsUUFBUTRDLGlCQUFpQjtvQkFBQztvQkFDcEQsTUFBTWMsZUFBZUQsWUFBWSxDQUFDcEIsZUFBZSxJQUFJO29CQUNyRG9CLFlBQVksQ0FBQ3BCLGVBQWUsR0FBR3FCLGVBQWVUO29CQUU5QyxNQUFNQyxlQUFlO3dCQUFFLEdBQUdsRCxRQUFRbUQsaUJBQWlCO29CQUFDO29CQUNwREQsWUFBWSxDQUFDYixlQUFlLEdBQUdnQixLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDSixZQUFZLENBQUNiLGVBQWUsSUFBSSxLQUFLWTtvQkFFakYsTUFBTVUsZUFBZTt3QkFBRSxHQUFHM0QsUUFBUTRELGlCQUFpQjtvQkFBQztvQkFDcERELFlBQVksQ0FBQ3RCLGVBQWUsR0FBRyxDQUFDc0IsWUFBWSxDQUFDdEIsZUFBZSxJQUFJLEtBQUtZO29CQUVyRXZDLFFBQVFFLEdBQUcsQ0FBQyx3Q0FBd0M7d0JBQ2xEaUQsS0FBS0g7d0JBQ0xJLEtBQUtMLFlBQVksQ0FBQ3BCLGVBQWU7d0JBQ2pDMEIsUUFBUSxDQUFDZDtvQkFDWDtvQkFFQSxPQUFPO3dCQUNMLEdBQUdqRCxPQUFPO3dCQUNWNEMsbUJBQW1CYTt3QkFDbkJOLG1CQUFtQkQ7d0JBQ25CVSxtQkFBbUJEO29CQUNyQjtnQkFDRjtnQkFDQSxPQUFPM0Q7WUFDVDtRQUNGO0lBQ0Y7SUFFQVUsUUFBUUUsR0FBRyxDQUFDO0FBQ2Q7QUFFQSxNQUFNb0QsbUJBQW1CLENBQUM1QixpQkFBMkJDLGdCQUEwQlk7SUFDN0V4RCxVQUFVb0MsUUFBUSxDQUFDVSxDQUFBQTtRQUNqQixNQUFNdkMsVUFBVXVDLE1BQU1DLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0IsUUFBUSxLQUFLdUI7UUFDcEQsSUFBSSxDQUFDSixlQUFlaEMsVUFBVTtZQUM1QixPQUFPdUM7UUFDVDtRQUNBLE9BQU87WUFDTEMsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUNKLENBQUFBO2dCQUNuQixJQUFJQSxFQUFFN0IsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUNsQyxNQUFNdUIsZUFBZTt3QkFBRSxHQUFHakIsRUFBRWtCLGlCQUFpQjtvQkFBQztvQkFDOUNELFlBQVksQ0FBQ3RCLGVBQWUsR0FBR2dCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNLLFlBQVksQ0FBQ3RCLGVBQWUsSUFBSSxLQUFLWTtvQkFDakYsT0FBTzt3QkFBRSxHQUFHUCxDQUFDO3dCQUFFa0IsbUJBQW1CRDtvQkFBYTtnQkFDakQ7Z0JBQ0EsT0FBT2pCO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxNQUFNdUIseUJBQXlCLENBQUM3QixpQkFBMkJDLGdCQUEwQlk7SUFDbkZ4RCxVQUFVb0MsUUFBUSxDQUFDVSxDQUFBQTtRQUNqQixNQUFNdkMsVUFBVXVDLE1BQU1DLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0IsUUFBUSxLQUFLdUI7UUFDcEQsSUFBSSxDQUFDSixlQUFlaEMsVUFBVTtZQUM1QixPQUFPdUM7UUFDVDtRQUNBLE9BQU87WUFDTEMsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUNKLENBQUFBO2dCQUNuQixJQUFJQSxFQUFFN0IsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUNsQyxNQUFNdUIsZUFBZTt3QkFBRSxHQUFHakIsRUFBRWtCLGlCQUFpQjtvQkFBQztvQkFDOUNELFlBQVksQ0FBQ3RCLGVBQWUsR0FBR2dCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNLLFlBQVksQ0FBQ3RCLGVBQWUsSUFBSSxLQUFLWTtvQkFDakYsTUFBTVEsZUFBZTt3QkFBRSxHQUFHZixFQUFFRSxpQkFBaUI7b0JBQUM7b0JBQzlDYSxZQUFZLENBQUNwQixlQUFlLEdBQUcsQ0FBQ29CLFlBQVksQ0FBQ3BCLGVBQWUsSUFBSSxLQUFLWTtvQkFDckUsT0FBTzt3QkFBRSxHQUFHUCxDQUFDO3dCQUFFRSxtQkFBbUJhO3dCQUFjRyxtQkFBbUJEO29CQUFhO2dCQUNsRjtnQkFDQSxPQUFPakI7WUFDVDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU13QiwwQkFBMEIsQ0FBQzlCLGlCQUEyQitCLE9BQWVDO0lBQ3pFM0UsVUFBVW9DLFFBQVEsQ0FBQ1UsQ0FBQUEsUUFBVTtZQUMzQkMsTUFBTUQsTUFBTUMsSUFBSSxDQUFDTSxHQUFHLENBQUM5QyxDQUFBQTtnQkFDbkIsSUFBSUEsUUFBUWEsUUFBUSxLQUFLdUIsaUJBQWlCO29CQUN4QyxpRkFBaUY7b0JBQ2pGLE1BQU1pQyxlQUFlckUsUUFBUXNFLGdCQUFnQixHQUFHLElBQUlDLEtBQUt2RSxRQUFRc0UsZ0JBQWdCLEVBQUVFLE9BQU8sS0FBSztvQkFDL0YsTUFBTUMsWUFBWSxJQUFJRixLQUFLSCxNQUFNSSxPQUFPO29CQUV4QyxJQUFJQyxhQUFhSixjQUFjO3dCQUM3QixPQUFPOzRCQUNMLEdBQUdyRSxPQUFPOzRCQUNWMEUsbUJBQW1CUDs0QkFDbkJHLGtCQUFrQkY7d0JBQ3BCO29CQUNGO2dCQUNGO2dCQUNBLE9BQU9wRTtZQUNUO1FBQ0Y7QUFDRjtBQUVBLE1BQU0yRSxpQkFBaUIsT0FBT0MsT0FBZUMsT0FBZSxDQUFDLEVBQUVDLFFBQWdCLEVBQUU7SUFDL0UsTUFBTUMsY0FBY3RGLFVBQVU0QixRQUFRLEdBQUdtQixJQUFJO0lBRTdDLG9FQUFvRTtJQUNwRSxNQUFNd0MsT0FBTyxJQUFJN0YsK0NBQUlBLENBQUM0RixhQUFhO1FBQ2pDRSxNQUFNO1lBQUM7WUFBUTtZQUFNO1lBQU87U0FBVTtRQUN0Q0MsV0FBVztJQUNiO0lBRUEsTUFBTUMsVUFBVUgsS0FBS0ksTUFBTSxDQUFDUjtJQUM1QixNQUFNUyxhQUFhLENBQUNSLE9BQU8sS0FBS0M7SUFDaEMsTUFBTVEsV0FBV0QsYUFBYVA7SUFDOUIsTUFBTVMsbUJBQW1CSixRQUFRSyxLQUFLLENBQUNILFlBQVlDO0lBRW5ELE9BQU87UUFDTEcsT0FBT0YsaUJBQWlCekMsR0FBRyxDQUFDZixDQUFBQSxTQUFXO2dCQUNyQzJELE9BQU96Ryx5REFBVUEsQ0FBQzhDLE9BQU9ELElBQUksQ0FBQ2pCLFFBQVE7Z0JBQ3RDOEUsT0FBTyxHQUFHNUQsT0FBT0QsSUFBSSxDQUFDOEQsSUFBSSxDQUFDLEVBQUUsRUFBRTdELE9BQU9ELElBQUksQ0FBQytELEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEQ7UUFDQUMsYUFBYVIsV0FBV0gsUUFBUVksTUFBTTtJQUN4QztBQUNGO0FBRUEsbURBQW1EO0FBQ25ELE1BQU1DLGFBQWEsQ0FBQ2hHO0lBQ2xCLE1BQU1pRyxXQUFXN0csZ0ZBQWtCQTtJQUNuQyxNQUFNOEcsYUFBYXpHLFVBQVU0QixRQUFRLEdBQUdDLEdBQUcsQ0FBQ3RCO0lBRTVDLDZCQUE2QjtJQUM3QixNQUFNbUcsZUFBZTlHLGdGQUFrQkEsQ0FDckM0RyxVQUNBLEdBQUdBLFNBQVNMLElBQUksQ0FBQyxpQkFBaUIsRUFBRU0sV0FBV04sSUFBSSxDQUFDLEVBQUUsRUFBRU0sV0FBV0wsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUUxRXBHLFVBQVU0QixRQUFRLEdBQUdOLE1BQU0sQ0FBQ21GLFdBQVdyRixRQUFRLEVBQUU7UUFDL0MsR0FBR3FGLFVBQVU7UUFDYkUsaUJBQWlCO1lBQUNEO1NBQWE7SUFDakM7SUFFQSxPQUFPRDtBQUNUO0FBRUEsc0RBQXNEO0FBQ3RELE1BQU1HLGdCQUFnQixDQUFDeEYsVUFBb0J5RjtJQUN6QyxNQUFNTCxXQUFXN0csZ0ZBQWtCQTtJQUNuQyxNQUFNbUgsa0JBQWtCOUcsVUFBVTRCLFFBQVEsR0FBR21CLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFN0IsUUFBUSxLQUFLQTtJQUMzRSxNQUFNMkYsaUJBQWlDLEVBQUU7SUFFekMsSUFBSUQsaUJBQWlCO1FBQ25CLHVCQUF1QjtRQUN2QixJQUFJQSxnQkFBZ0JFLE1BQU0sS0FBS0gsZUFBZUcsTUFBTSxFQUFFO1lBQ3BELE1BQU1DLGVBQXVDO2dCQUMzQyxVQUFVO2dCQUNWLFlBQVk7Z0JBQ1osZ0JBQWdCO1lBQ2xCO1lBQ0FGLGVBQWVHLElBQUksQ0FBQ3BILHNGQUF3QkEsQ0FDMUMwRyxVQUNBUyxZQUFZLENBQUNILGdCQUFnQkUsTUFBTSxJQUFJLFNBQVMsRUFDaERDLFlBQVksQ0FBQ0osZUFBZUcsTUFBTSxJQUFJLFNBQVMsRUFDL0MsR0FBR1IsU0FBU0wsSUFBSSxDQUFDLHVCQUF1QixFQUFFYyxZQUFZLENBQUNILGdCQUFnQkUsTUFBTSxJQUFJLFNBQVMsQ0FBQyxRQUFRLEVBQUVDLFlBQVksQ0FBQ0osZUFBZUcsTUFBTSxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFFM0o7UUFFQSxzQkFBc0I7UUFDdEIsTUFBTUcsZ0JBQThEO1lBQ2xFO2dCQUFFQyxLQUFLO2dCQUFRbEIsT0FBTztZQUFlO1lBQ3JDO2dCQUFFa0IsS0FBSztnQkFBTWxCLE9BQU87WUFBUztZQUM3QjtnQkFBRWtCLEtBQUs7Z0JBQWVsQixPQUFPO1lBQVE7WUFDckM7Z0JBQUVrQixLQUFLO2dCQUFvQmxCLE9BQU87WUFBYTtZQUMvQztnQkFBRWtCLEtBQUs7Z0JBQVFsQixPQUFPO1lBQWdCO1lBQ3RDO2dCQUFFa0IsS0FBSztnQkFBb0JsQixPQUFPO1lBQVc7WUFDN0M7Z0JBQUVrQixLQUFLO2dCQUFpQmxCLE9BQU87WUFBYztZQUM3QztnQkFBRWtCLEtBQUs7Z0JBQVFsQixPQUFPO1lBQWM7WUFDcEM7Z0JBQUVrQixLQUFLO2dCQUFhbEIsT0FBTztZQUFVO1lBQ3JDO2dCQUFFa0IsS0FBSztnQkFBWWxCLE9BQU87WUFBZ0I7WUFDMUM7Z0JBQUVrQixLQUFLO2dCQUFXbEIsT0FBTztZQUFVO1lBQ25DO2dCQUFFa0IsS0FBSztnQkFBMkJsQixPQUFPO1lBQXFCO1lBQzlEO2dCQUFFa0IsS0FBSztnQkFBd0JsQixPQUFPO1lBQW9CO1lBQzFEO2dCQUFFa0IsS0FBSztnQkFBZ0JsQixPQUFPO1lBQW1CO1lBQ2pEO2dCQUFFa0IsS0FBSztnQkFBZWxCLE9BQU87WUFBa0I7WUFDL0M7Z0JBQUVrQixLQUFLO2dCQUFZbEIsT0FBTztZQUFpQjtTQUM1QztRQUVELE1BQU1tQixVQUFvQixFQUFFO1FBQzVCLEtBQUssTUFBTUMsU0FBU0gsY0FBZTtZQUNqQyxNQUFNSSxTQUFTVCxlQUFlLENBQUNRLE1BQU1GLEdBQUcsQ0FBQztZQUN6QyxNQUFNSSxTQUFTWCxjQUFjLENBQUNTLE1BQU1GLEdBQUcsQ0FBQztZQUN4QyxJQUFJRyxXQUFXQyxVQUFVLENBQUVELENBQUFBLFdBQVdFLGFBQWFELFdBQVdDLFNBQVEsR0FBSTtnQkFDeEUsSUFBSUgsTUFBTUYsR0FBRyxLQUFLLFVBQVU7Z0JBQzVCLE1BQU1NLGFBQWFILFdBQVdFLGFBQWFGLFdBQVcsUUFBUUEsV0FBVyxLQUFLSSxPQUFPSixVQUFVO2dCQUMvRixNQUFNSyxhQUFhSixXQUFXQyxhQUFhRCxXQUFXLFFBQVFBLFdBQVcsS0FBS0csT0FBT0gsVUFBVTtnQkFDL0ZILFFBQVFILElBQUksQ0FBQyxHQUFHSSxNQUFNcEIsS0FBSyxDQUFDLEVBQUUsRUFBRXdCLFdBQVcsR0FBRyxFQUFFRSxZQUFZO1lBQzlEO1FBQ0Y7UUFFQSxpQ0FBaUM7UUFDakMsSUFBSWQsZ0JBQWdCZSxTQUFTLEtBQUtoQixlQUFlZ0IsU0FBUyxFQUFFO1lBQzFEUixRQUFRSCxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUVKLGdCQUFnQmUsU0FBUyxFQUFFQyxlQUFlLFNBQVMsR0FBRyxFQUFFakIsZUFBZWdCLFNBQVMsRUFBRUMsZUFBZSxVQUFVO1FBQ3RJO1FBRUEsSUFBSVQsUUFBUWYsTUFBTSxHQUFHLEdBQUc7WUFDdEJTLGVBQWVHLElBQUksQ0FBQ3JILGdGQUFrQkEsQ0FDcEMyRyxVQUNBLEdBQUdBLFNBQVNMLElBQUksQ0FBQyxjQUFjLEVBQUVrQixRQUFRVSxJQUFJLENBQUMsT0FBTztRQUV6RDtJQUNGO0lBRUEsTUFBTUMscUJBQXFCO1FBQ3pCLEdBQUduQixjQUFjO1FBQ2pCRixpQkFBaUI1RyxnRkFBa0JBLENBQUMrRyxpQkFBaUJILG9CQUFvQkk7SUFDM0U7SUFFQS9HLFVBQVU0QixRQUFRLEdBQUdOLE1BQU0sQ0FBQ0YsVUFBVTRHO0FBQ3hDO0FBRUEsK0RBQStEO0FBQ3hELE1BQU1DLGtCQUFrQjtJQUM3QixNQUFNbkYsUUFBUTlDO0lBQ2QsT0FBTztRQUNMLEdBQUc4QyxLQUFLO1FBQ1JqQixLQUFLMEU7UUFDTGpGLFFBQVFzRjtRQUNSbEU7UUFDQWE7UUFDQUk7UUFDQUc7UUFDQVM7UUFDQUM7UUFDQUM7UUFDQVM7SUFDRjtBQUNGLEVBQUU7QUFFRiw0Q0FBNEM7QUFDNUMrQyxnQkFBZ0JyRyxRQUFRLEdBQUc7SUFDekIsTUFBTWtCLFFBQVE5QyxVQUFVNEIsUUFBUTtJQUNoQyxPQUFPO1FBQ0wsR0FBR2tCLEtBQUs7UUFDUmpCLEtBQUswRTtRQUNMakYsUUFBUXNGO1FBQ1JsRTtRQUNBYTtRQUNBSTtRQUNBRztRQUNBUztRQUNBQztRQUNBQztRQUNBUztJQUNGO0FBQ0Y7QUFFQytDLGdCQUF3RkMsU0FBUyxHQUFHbEksVUFBVWtJLFNBQVMiLCJzb3VyY2VzIjpbIkQ6XFxocm0yXFxmZWF0dXJlc1xccHJvZHVjdHNcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNydWRTdG9yZSwgQ3J1ZFN0YXRlIH0gZnJvbSAnLi4vLi4vbGliL3N0b3JlLWZhY3RvcnknO1xyXG4vLyBSRU1PVkVEOiBpbXBvcnQgeyBkYXRhIGFzIGluaXRpYWxEYXRhIH0gZnJvbSAnLi9kYXRhJzsgLy8gTW9jayBkYXRhIG5vIGxvbmdlciB1c2VkIC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbmltcG9ydCB0eXBlIHsgUHJvZHVjdCB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyB0eXBlIFN5c3RlbUlkIH0gZnJvbSAnQC9saWIvaWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBhc1N5c3RlbUlkLCBhc0J1c2luZXNzSWQgfSBmcm9tICcuLi8uLi9saWIvaWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBnZXRDdXJyZW50VXNlclN5c3RlbUlkIH0gZnJvbSAnLi4vLi4vY29udGV4dHMvYXV0aC1jb250ZXh0JztcclxuaW1wb3J0IEZ1c2UgZnJvbSAnZnVzZS5qcyc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0Q3VycmVudFVzZXJJbmZvLFxyXG4gIGNyZWF0ZUNyZWF0ZWRFbnRyeSxcclxuICBjcmVhdGVVcGRhdGVkRW50cnksXHJcbiAgY3JlYXRlU3RhdHVzQ2hhbmdlZEVudHJ5LFxyXG4gIGFwcGVuZEhpc3RvcnlFbnRyeSxcclxuICB0eXBlIEhpc3RvcnlFbnRyeVxyXG59IGZyb20gJy4uLy4uL2xpYi9hY3Rpdml0eS1oaXN0b3J5LWhlbHBlcic7XHJcblxyXG5jb25zdCBiYXNlU3RvcmUgPSBjcmVhdGVDcnVkU3RvcmU8UHJvZHVjdD4oW10sICdwcm9kdWN0cycsIHtcclxuICBidXNpbmVzc0lkRmllbGQ6ICdpZCcsXHJcbiAgZ2V0Q3VycmVudFVzZXI6IGdldEN1cnJlbnRVc2VyU3lzdGVtSWQsIC8vIOKchSBUcmFjayB3aG8gY3JlYXRlcy91cGRhdGVzXHJcbiAgYXBpRW5kcG9pbnQ6ICcvYXBpL3Byb2R1Y3RzJyxcclxufSk7XHJcblxyXG4vLyDinIUgQVBJIFN5bmMgaGVscGVyc1xyXG5jb25zdCBBUElfRU5EUE9JTlQgPSAnL2FwaS9wcm9kdWN0cyc7XHJcblxyXG5jb25zdCBzeW5jVG9BcGkgPSB7XHJcbiAgY3JlYXRlOiBhc3luYyAocHJvZHVjdDogUHJvZHVjdCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBUElfRU5EUE9JTlQsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2R1Y3QpLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbUHJvZHVjdCBBUEldIENyZWF0ZSBzeW5jIGZhaWxlZCcpO1xyXG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdbUHJvZHVjdCBBUEldIENyZWF0ZWQ6JywgcHJvZHVjdC5zeXN0ZW1JZCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW1Byb2R1Y3QgQVBJXSBDcmVhdGUgc3luYyBlcnJvcjonLCBlKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHVwZGF0ZTogYXN5bmMgKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdXBkYXRlczogUGFydGlhbDxQcm9kdWN0PikgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfRU5EUE9JTlR9LyR7c3lzdGVtSWR9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZXMpLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbUHJvZHVjdCBBUEldIFVwZGF0ZSBzeW5jIGZhaWxlZCcpO1xyXG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdbUHJvZHVjdCBBUEldIFVwZGF0ZWQ6Jywgc3lzdGVtSWQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tQcm9kdWN0IEFQSV0gVXBkYXRlIHN5bmMgZXJyb3I6JywgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZWxldGU6IGFzeW5jIChzeXN0ZW1JZDogU3lzdGVtSWQsIGhhcmQgPSBmYWxzZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfRU5EUE9JTlR9LyR7c3lzdGVtSWR9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGhhcmQgfSksXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSBjb25zb2xlLndhcm4oJ1tQcm9kdWN0IEFQSV0gRGVsZXRlIHN5bmMgZmFpbGVkJyk7XHJcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ1tQcm9kdWN0IEFQSV0gRGVsZXRlZDonLCBzeXN0ZW1JZCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW1Byb2R1Y3QgQVBJXSBEZWxldGUgc3luYyBlcnJvcjonLCBlKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHJlc3RvcmU6IGFzeW5jIChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0VORFBPSU5UfS8ke3N5c3RlbUlkfS9yZXN0b3JlYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSBjb25zb2xlLndhcm4oJ1tQcm9kdWN0IEFQSV0gUmVzdG9yZSBzeW5jIGZhaWxlZCcpO1xyXG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdbUHJvZHVjdCBBUEldIFJlc3RvcmVkOicsIHN5c3RlbUlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbUHJvZHVjdCBBUEldIFJlc3RvcmUgc3luYyBlcnJvcjonLCBlKTtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5cclxuLy8g4pyFIFdyYXAgYmFzZSBzdG9yZSBtZXRob2RzIHdpdGggQVBJIHN5bmNcclxuY29uc3Qgb3JpZ2luYWxBZGQgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5hZGQ7XHJcbmNvbnN0IG9yaWdpbmFsVXBkYXRlID0gYmFzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlO1xyXG5jb25zdCBvcmlnaW5hbFJlbW92ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnJlbW92ZTtcclxuY29uc3Qgb3JpZ2luYWxIYXJkRGVsZXRlID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuaGFyZERlbGV0ZTtcclxuY29uc3Qgb3JpZ2luYWxSZXN0b3JlID0gYmFzZVN0b3JlLmdldFN0YXRlKCkucmVzdG9yZTtcclxuXHJcbmJhc2VTdG9yZS5zZXRTdGF0ZSh7XHJcbiAgYWRkOiAoaXRlbTogT21pdDxQcm9kdWN0LCAnc3lzdGVtSWQnPikgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWxBZGQoaXRlbSk7XHJcbiAgICBzeW5jVG9BcGkuY3JlYXRlKHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sXHJcbiAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCB1cGRhdGVzOiBQYXJ0aWFsPFByb2R1Y3Q+KSA9PiB7XHJcbiAgICBvcmlnaW5hbFVwZGF0ZShzeXN0ZW1JZCwgdXBkYXRlcyk7XHJcbiAgICBzeW5jVG9BcGkudXBkYXRlKHN5c3RlbUlkLCB1cGRhdGVzKTtcclxuICB9LFxyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZW1vdmUoc3lzdGVtSWQpO1xyXG4gICAgc3luY1RvQXBpLmRlbGV0ZShzeXN0ZW1JZCwgZmFsc2UpO1xyXG4gIH0sXHJcbiAgaGFyZERlbGV0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxIYXJkRGVsZXRlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5kZWxldGUoc3lzdGVtSWQsIHRydWUpO1xyXG4gIH0sXHJcbiAgcmVzdG9yZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZXN0b3JlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5yZXN0b3JlKHN5c3RlbUlkKTtcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIERlZmluZSBleHRlbmRlZCBzdG9yZSBpbnRlcmZhY2VcclxuZXhwb3J0IGludGVyZmFjZSBQcm9kdWN0U3RvcmVTdGF0ZSBleHRlbmRzIENydWRTdGF0ZTxQcm9kdWN0PiB7XHJcbiAgdXBkYXRlSW52ZW50b3J5OiAocHJvZHVjdFN5c3RlbUlkOiBTeXN0ZW1JZCwgYnJhbmNoU3lzdGVtSWQ6IFN5c3RlbUlkLCBxdWFudGl0eUNoYW5nZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIGNvbW1pdFN0b2NrOiAocHJvZHVjdFN5c3RlbUlkOiBTeXN0ZW1JZCwgYnJhbmNoU3lzdGVtSWQ6IFN5c3RlbUlkLCBxdWFudGl0eTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIHVuY29tbWl0U3RvY2s6IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5OiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgZGlzcGF0Y2hTdG9jazogKHByb2R1Y3RTeXN0ZW1JZDogU3lzdGVtSWQsIGJyYW5jaFN5c3RlbUlkOiBTeXN0ZW1JZCwgcXVhbnRpdHk6IG51bWJlcikgPT4gdm9pZDtcclxuICBjb21wbGV0ZURlbGl2ZXJ5OiAocHJvZHVjdFN5c3RlbUlkOiBTeXN0ZW1JZCwgYnJhbmNoU3lzdGVtSWQ6IFN5c3RlbUlkLCBxdWFudGl0eTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIHJldHVyblN0b2NrRnJvbVRyYW5zaXQ6IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5OiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgdXBkYXRlTGFzdFB1cmNoYXNlUHJpY2U6IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBwcmljZTogbnVtYmVyLCBkYXRlOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgc2VhcmNoUHJvZHVjdHM6IChxdWVyeTogc3RyaW5nLCBwYWdlOiBudW1iZXIsIGxpbWl0PzogbnVtYmVyKSA9PiBQcm9taXNlPHsgaXRlbXM6IHsgdmFsdWU6IFN5c3RlbUlkOyBsYWJlbDogc3RyaW5nIH1bXSwgaGFzTmV4dFBhZ2U6IGJvb2xlYW4gfT47XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBjaGVjayBpZiBwcm9kdWN0IHRyYWNrcyBzdG9ja1xyXG5jb25zdCBjYW5Nb2RpZnlTdG9jayA9IChwcm9kdWN0OiBQcm9kdWN0IHwgdW5kZWZpbmVkKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKCFwcm9kdWN0KSByZXR1cm4gZmFsc2U7XHJcbiAgLy8gU2VydmljZXMsIGRpZ2l0YWwgcHJvZHVjdHMsIGFuZCBjb21ib3MgZG9uJ3QgdHJhY2sgc3RvY2sgZGlyZWN0bHlcclxuICBpZiAocHJvZHVjdC50eXBlID09PSAnc2VydmljZScgfHwgcHJvZHVjdC50eXBlID09PSAnZGlnaXRhbCcgfHwgcHJvZHVjdC50eXBlID09PSAnY29tYm8nKSByZXR1cm4gZmFsc2U7XHJcbiAgLy8gRXhwbGljaXRseSBkaXNhYmxlZCBzdG9jayB0cmFja2luZ1xyXG4gIGlmIChwcm9kdWN0LmlzU3RvY2tUcmFja2VkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLy8gRGVmaW5lIGN1c3RvbSBtZXRob2RzXHJcbmNvbnN0IHVwZGF0ZUludmVudG9yeSA9IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5Q2hhbmdlOiBudW1iZXIpID0+IHtcclxuICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcHJvZHVjdCA9IHN0YXRlLmRhdGEuZmluZChwID0+IHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICBpZiAoIXByb2R1Y3QpIHJldHVybiBzdGF0ZTtcclxuICAgIFxyXG4gICAgLy8gU2tpcCBpZiBwcm9kdWN0IGRvZXNuJ3QgdHJhY2sgc3RvY2tcclxuICAgIGlmICghY2FuTW9kaWZ5U3RvY2socHJvZHVjdCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBbdXBkYXRlSW52ZW50b3J5XSBTa2lwcGVkOiBQcm9kdWN0ICR7cHJvZHVjdFN5c3RlbUlkfSBkb2VzIG5vdCB0cmFjayBzdG9ja2ApO1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IG9sZFF1YW50aXR5ID0gcHJvZHVjdC5pbnZlbnRvcnlCeUJyYW5jaD8uW2JyYW5jaFN5c3RlbUlkXSB8fCAwO1xyXG4gICAgY29uc3QgbmV3UXVhbnRpdHkgPSBvbGRRdWFudGl0eSArIHF1YW50aXR5Q2hhbmdlO1xyXG4gICAgXHJcbiAgICAvLyDinIUgUmVtb3ZlZCBDT01QTEFJTlRfQURKVVNUTUVOVCBzdG9jayBoaXN0b3J5IGNyZWF0aW9uXHJcbiAgICAvLyBTdG9jayBoaXN0b3J5IHdpbGwgYmUgY3JlYXRlZCBieSBpbnZlbnRvcnkgY2hlY2sgYmFsYW5jZSBpbnN0ZWFkXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKHAgPT4ge1xyXG4gICAgICAgIGlmIChwLnN5c3RlbUlkID09PSBwcm9kdWN0U3lzdGVtSWQpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld0ludmVudG9yeUJ5QnJhbmNoID0geyAuLi5wLmludmVudG9yeUJ5QnJhbmNoIH07XHJcbiAgICAgICAgICBuZXdJbnZlbnRvcnlCeUJyYW5jaFticmFuY2hTeXN0ZW1JZF0gPSBuZXdRdWFudGl0eTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgIGludmVudG9yeUJ5QnJhbmNoOiBuZXdJbnZlbnRvcnlCeUJyYW5jaCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgICB9KSxcclxuICAgIH07XHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCBjb21taXRTdG9jayA9IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5OiBudW1iZXIpID0+IHtcclxuICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcHJvZHVjdCA9IHN0YXRlLmRhdGEuZmluZChwID0+IHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICBpZiAoIWNhbk1vZGlmeVN0b2NrKHByb2R1Y3QpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgW2NvbW1pdFN0b2NrXSBTa2lwcGVkOiBQcm9kdWN0ICR7cHJvZHVjdFN5c3RlbUlkfSBkb2VzIG5vdCB0cmFjayBzdG9ja2ApO1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChwID0+IHtcclxuICAgICAgICBpZiAocC5zeXN0ZW1JZCA9PT0gcHJvZHVjdFN5c3RlbUlkKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdDb21taXR0ZWQgPSB7IC4uLnAuY29tbWl0dGVkQnlCcmFuY2ggfTtcclxuICAgICAgICAgIG5ld0NvbW1pdHRlZFticmFuY2hTeXN0ZW1JZF0gPSAobmV3Q29tbWl0dGVkW2JyYW5jaFN5c3RlbUlkXSB8fCAwKSArIHF1YW50aXR5O1xyXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucCwgY29tbWl0dGVkQnlCcmFuY2g6IG5ld0NvbW1pdHRlZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgICAgfSksXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgdW5jb21taXRTdG9jayA9IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5OiBudW1iZXIpID0+IHtcclxuICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcHJvZHVjdCA9IHN0YXRlLmRhdGEuZmluZChwID0+IHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICBpZiAoIWNhbk1vZGlmeVN0b2NrKHByb2R1Y3QpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgW3VuY29tbWl0U3RvY2tdIFNraXBwZWQ6IFByb2R1Y3QgJHtwcm9kdWN0U3lzdGVtSWR9IGRvZXMgbm90IHRyYWNrIHN0b2NrYCk7XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKHAgPT4ge1xyXG4gICAgICAgIGlmIChwLnN5c3RlbUlkID09PSBwcm9kdWN0U3lzdGVtSWQpIHtcclxuICAgICAgICAgIGNvbnN0IG5ld0NvbW1pdHRlZCA9IHsgLi4ucC5jb21taXR0ZWRCeUJyYW5jaCB9O1xyXG4gICAgICAgICAgbmV3Q29tbWl0dGVkW2JyYW5jaFN5c3RlbUlkXSA9IE1hdGgubWF4KDAsIChuZXdDb21taXR0ZWRbYnJhbmNoU3lzdGVtSWRdIHx8IDApIC0gcXVhbnRpdHkpO1xyXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucCwgY29tbWl0dGVkQnlCcmFuY2g6IG5ld0NvbW1pdHRlZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgICAgfSksXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgZGlzcGF0Y2hTdG9jayA9IChwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkLCBicmFuY2hTeXN0ZW1JZDogU3lzdGVtSWQsIHF1YW50aXR5OiBudW1iZXIpID0+IHtcclxuICBjb25zb2xlLmxvZygn8J+UtCBbZGlzcGF0Y2hTdG9ja10gQ2FsbGVkIHdpdGg6JywgeyBwcm9kdWN0U3lzdGVtSWQsIGJyYW5jaFN5c3RlbUlkLCBxdWFudGl0eSB9KTtcclxuICBcclxuICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcHJvZHVjdCA9IHN0YXRlLmRhdGEuZmluZChwID0+IHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICBpZiAoIXByb2R1Y3QpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFtkaXNwYXRjaFN0b2NrXSBQcm9kdWN0IG5vdCBmb3VuZDonLCBwcm9kdWN0U3lzdGVtSWQpO1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNraXAgaWYgcHJvZHVjdCBkb2Vzbid0IHRyYWNrIHN0b2NrXHJcbiAgICBpZiAoIWNhbk1vZGlmeVN0b2NrKHByb2R1Y3QpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgW2Rpc3BhdGNoU3RvY2tdIFNraXBwZWQ6IFByb2R1Y3QgJHtwcm9kdWN0U3lzdGVtSWR9IGRvZXMgbm90IHRyYWNrIHN0b2NrYCk7XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/Cfk6YgW2Rpc3BhdGNoU3RvY2tdIEN1cnJlbnQgaW52ZW50b3J5OicsIHByb2R1Y3QuaW52ZW50b3J5QnlCcmFuY2gpO1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk6YgW2Rpc3BhdGNoU3RvY2tdIEN1cnJlbnQgY29tbWl0dGVkOicsIHByb2R1Y3QuY29tbWl0dGVkQnlCcmFuY2gpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChwcm9kdWN0ID0+IHtcclxuICAgICAgICBpZiAocHJvZHVjdC5zeXN0ZW1JZCA9PT0gcHJvZHVjdFN5c3RlbUlkKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdJbnZlbnRvcnkgPSB7IC4uLnByb2R1Y3QuaW52ZW50b3J5QnlCcmFuY2ggfTtcclxuICAgICAgICAgIGNvbnN0IG9sZEludmVudG9yeSA9IG5ld0ludmVudG9yeVticmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgIG5ld0ludmVudG9yeVticmFuY2hTeXN0ZW1JZF0gPSBvbGRJbnZlbnRvcnkgLSBxdWFudGl0eTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgbmV3Q29tbWl0dGVkID0geyAuLi5wcm9kdWN0LmNvbW1pdHRlZEJ5QnJhbmNoIH07XHJcbiAgICAgICAgICBuZXdDb21taXR0ZWRbYnJhbmNoU3lzdGVtSWRdID0gTWF0aC5tYXgoMCwgKG5ld0NvbW1pdHRlZFticmFuY2hTeXN0ZW1JZF0gfHwgMCkgLSBxdWFudGl0eSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgbmV3SW5UcmFuc2l0ID0geyAuLi5wcm9kdWN0LmluVHJhbnNpdEJ5QnJhbmNoIH07XHJcbiAgICAgICAgICBuZXdJblRyYW5zaXRbYnJhbmNoU3lzdGVtSWRdID0gKG5ld0luVHJhbnNpdFticmFuY2hTeXN0ZW1JZF0gfHwgMCkgKyBxdWFudGl0eTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBbZGlzcGF0Y2hTdG9ja10gVXBkYXRlZCBpbnZlbnRvcnk6Jywge1xyXG4gICAgICAgICAgICBvbGQ6IG9sZEludmVudG9yeSxcclxuICAgICAgICAgICAgbmV3OiBuZXdJbnZlbnRvcnlbYnJhbmNoU3lzdGVtSWRdLFxyXG4gICAgICAgICAgICBjaGFuZ2U6IC1xdWFudGl0eVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiB7IFxyXG4gICAgICAgICAgICAuLi5wcm9kdWN0LCBcclxuICAgICAgICAgICAgaW52ZW50b3J5QnlCcmFuY2g6IG5ld0ludmVudG9yeSxcclxuICAgICAgICAgICAgY29tbWl0dGVkQnlCcmFuY2g6IG5ld0NvbW1pdHRlZCxcclxuICAgICAgICAgICAgaW5UcmFuc2l0QnlCcmFuY2g6IG5ld0luVHJhbnNpdCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgICB9KSxcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ+KchSBbZGlzcGF0Y2hTdG9ja10gQ29tcGxldGVkJyk7XHJcbn07XHJcblxyXG5jb25zdCBjb21wbGV0ZURlbGl2ZXJ5ID0gKHByb2R1Y3RTeXN0ZW1JZDogU3lzdGVtSWQsIGJyYW5jaFN5c3RlbUlkOiBTeXN0ZW1JZCwgcXVhbnRpdHk6IG51bWJlcikgPT4ge1xyXG4gIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCBwcm9kdWN0ID0gc3RhdGUuZGF0YS5maW5kKHAgPT4gcC5zeXN0ZW1JZCA9PT0gcHJvZHVjdFN5c3RlbUlkKTtcclxuICAgIGlmICghY2FuTW9kaWZ5U3RvY2socHJvZHVjdCkpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAocCA9PiB7XHJcbiAgICAgICAgaWYgKHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCkge1xyXG4gICAgICAgICAgY29uc3QgbmV3SW5UcmFuc2l0ID0geyAuLi5wLmluVHJhbnNpdEJ5QnJhbmNoIH07XHJcbiAgICAgICAgICBuZXdJblRyYW5zaXRbYnJhbmNoU3lzdGVtSWRdID0gTWF0aC5tYXgoMCwgKG5ld0luVHJhbnNpdFticmFuY2hTeXN0ZW1JZF0gfHwgMCkgLSBxdWFudGl0eSk7XHJcbiAgICAgICAgICByZXR1cm4geyAuLi5wLCBpblRyYW5zaXRCeUJyYW5jaDogbmV3SW5UcmFuc2l0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgICB9KSxcclxuICAgIH07XHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCByZXR1cm5TdG9ja0Zyb21UcmFuc2l0ID0gKHByb2R1Y3RTeXN0ZW1JZDogU3lzdGVtSWQsIGJyYW5jaFN5c3RlbUlkOiBTeXN0ZW1JZCwgcXVhbnRpdHk6IG51bWJlcikgPT4ge1xyXG4gIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCBwcm9kdWN0ID0gc3RhdGUuZGF0YS5maW5kKHAgPT4gcC5zeXN0ZW1JZCA9PT0gcHJvZHVjdFN5c3RlbUlkKTtcclxuICAgIGlmICghY2FuTW9kaWZ5U3RvY2socHJvZHVjdCkpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAocCA9PiB7XHJcbiAgICAgICAgaWYgKHAuc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCkge1xyXG4gICAgICAgICAgY29uc3QgbmV3SW5UcmFuc2l0ID0geyAuLi5wLmluVHJhbnNpdEJ5QnJhbmNoIH07XHJcbiAgICAgICAgICBuZXdJblRyYW5zaXRbYnJhbmNoU3lzdGVtSWRdID0gTWF0aC5tYXgoMCwgKG5ld0luVHJhbnNpdFticmFuY2hTeXN0ZW1JZF0gfHwgMCkgLSBxdWFudGl0eSk7XHJcbiAgICAgICAgICBjb25zdCBuZXdJbnZlbnRvcnkgPSB7IC4uLnAuaW52ZW50b3J5QnlCcmFuY2ggfTtcclxuICAgICAgICAgIG5ld0ludmVudG9yeVticmFuY2hTeXN0ZW1JZF0gPSAobmV3SW52ZW50b3J5W2JyYW5jaFN5c3RlbUlkXSB8fCAwKSArIHF1YW50aXR5O1xyXG4gICAgICAgICAgcmV0dXJuIHsgLi4ucCwgaW52ZW50b3J5QnlCcmFuY2g6IG5ld0ludmVudG9yeSwgaW5UcmFuc2l0QnlCcmFuY2g6IG5ld0luVHJhbnNpdCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgICAgfSksXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgdXBkYXRlTGFzdFB1cmNoYXNlUHJpY2UgPSAocHJvZHVjdFN5c3RlbUlkOiBTeXN0ZW1JZCwgcHJpY2U6IG51bWJlciwgZGF0ZTogc3RyaW5nKSA9PiB7XHJcbiAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChwcm9kdWN0ID0+IHtcclxuICAgICAgaWYgKHByb2R1Y3Quc3lzdGVtSWQgPT09IHByb2R1Y3RTeXN0ZW1JZCkge1xyXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHRoZSBuZXcgZGF0ZSBpcyBuZXdlciBvciBlcXVhbCB0byB0aGUgZXhpc3RpbmcgbGFzdFB1cmNoYXNlRGF0ZVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGF0ZSA9IHByb2R1Y3QubGFzdFB1cmNoYXNlRGF0ZSA/IG5ldyBEYXRlKHByb2R1Y3QubGFzdFB1cmNoYXNlRGF0ZSkuZ2V0VGltZSgpIDogMDtcclxuICAgICAgICBjb25zdCBuZXdEYXRlVHMgPSBuZXcgRGF0ZShkYXRlKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG5ld0RhdGVUcyA+PSBleGlzdGluZ0RhdGUpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnByb2R1Y3QsXHJcbiAgICAgICAgICAgIGxhc3RQdXJjaGFzZVByaWNlOiBwcmljZSxcclxuICAgICAgICAgICAgbGFzdFB1cmNoYXNlRGF0ZTogZGF0ZSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfSksXHJcbiAgfSkpO1xyXG59O1xyXG5cclxuY29uc3Qgc2VhcmNoUHJvZHVjdHMgPSBhc3luYyAocXVlcnk6IHN0cmluZywgcGFnZTogbnVtYmVyID0gMSwgbGltaXQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTx7IGl0ZW1zOiB7IHZhbHVlOiBTeXN0ZW1JZDsgbGFiZWw6IHN0cmluZyB9W10sIGhhc05leHRQYWdlOiBib29sZWFuIH0+ID0+IHtcclxuICBjb25zdCBhbGxQcm9kdWN0cyA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmRhdGE7XHJcbiAgXHJcbiAgLy8g4pyFIENyZWF0ZSBmcmVzaCBGdXNlIGluc3RhbmNlIHdpdGggY3VycmVudCBkYXRhIChhdm9pZCBzdGFsZSBkYXRhKVxyXG4gIGNvbnN0IGZ1c2UgPSBuZXcgRnVzZShhbGxQcm9kdWN0cywge1xyXG4gICAga2V5czogWyduYW1lJywgJ2lkJywgJ3NrdScsICdiYXJjb2RlJ10sXHJcbiAgICB0aHJlc2hvbGQ6IDAuMyxcclxuICB9KTtcclxuICBcclxuICBjb25zdCByZXN1bHRzID0gZnVzZS5zZWFyY2gocXVlcnkpO1xyXG4gIGNvbnN0IHN0YXJ0SW5kZXggPSAocGFnZSAtIDEpICogbGltaXQ7XHJcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGltaXQ7XHJcbiAgY29uc3QgcGFnaW5hdGVkUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXRlbXM6IHBhZ2luYXRlZFJlc3VsdHMubWFwKHJlc3VsdCA9PiAoe1xyXG4gICAgICB2YWx1ZTogYXNTeXN0ZW1JZChyZXN1bHQuaXRlbS5zeXN0ZW1JZCksXHJcbiAgICAgIGxhYmVsOiBgJHtyZXN1bHQuaXRlbS5uYW1lfSAoJHtyZXN1bHQuaXRlbS5pZH0pYCxcclxuICAgIH0pKSxcclxuICAgIGhhc05leHRQYWdlOiBlbmRJbmRleCA8IHJlc3VsdHMubGVuZ3RoLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBXcmFwcGVkIGFkZCBtZXRob2Qgd2l0aCBhY3Rpdml0eSBoaXN0b3J5IGxvZ2dpbmdcclxuY29uc3QgYWRkUHJvZHVjdCA9IChwcm9kdWN0OiBPbWl0PFByb2R1Y3QsICdzeXN0ZW1JZCc+KSA9PiB7XHJcbiAgY29uc3QgdXNlckluZm8gPSBnZXRDdXJyZW50VXNlckluZm8oKTtcclxuICBjb25zdCBuZXdQcm9kdWN0ID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuYWRkKHByb2R1Y3QpO1xyXG4gIFxyXG4gIC8vIEFkZCBhY3Rpdml0eSBoaXN0b3J5IGVudHJ5XHJcbiAgY29uc3QgaGlzdG9yeUVudHJ5ID0gY3JlYXRlQ3JlYXRlZEVudHJ5KFxyXG4gICAgdXNlckluZm8sXHJcbiAgICBgJHt1c2VySW5mby5uYW1lfSDEkcOjIHThuqFvIHPhuqNuIHBo4bqpbSAke25ld1Byb2R1Y3QubmFtZX0gKCR7bmV3UHJvZHVjdC5pZH0pYFxyXG4gICk7XHJcbiAgYmFzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlKG5ld1Byb2R1Y3Quc3lzdGVtSWQsIHtcclxuICAgIC4uLm5ld1Byb2R1Y3QsXHJcbiAgICBhY3Rpdml0eUhpc3Rvcnk6IFtoaXN0b3J5RW50cnldXHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIG5ld1Byb2R1Y3Q7XHJcbn07XHJcblxyXG4vLyBXcmFwcGVkIHVwZGF0ZSBtZXRob2Qgd2l0aCBhY3Rpdml0eSBoaXN0b3J5IGxvZ2dpbmdcclxuY29uc3QgdXBkYXRlUHJvZHVjdCA9IChzeXN0ZW1JZDogU3lzdGVtSWQsIHVwZGF0ZWRQcm9kdWN0OiBQcm9kdWN0KSA9PiB7XHJcbiAgY29uc3QgdXNlckluZm8gPSBnZXRDdXJyZW50VXNlckluZm8oKTtcclxuICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQocCA9PiBwLnN5c3RlbUlkID09PSBzeXN0ZW1JZCk7XHJcbiAgY29uc3QgaGlzdG9yeUVudHJpZXM6IEhpc3RvcnlFbnRyeVtdID0gW107XHJcbiAgXHJcbiAgaWYgKGV4aXN0aW5nUHJvZHVjdCkge1xyXG4gICAgLy8gVHJhY2sgc3RhdHVzIGNoYW5nZXNcclxuICAgIGlmIChleGlzdGluZ1Byb2R1Y3Quc3RhdHVzICE9PSB1cGRhdGVkUHJvZHVjdC5zdGF0dXMpIHtcclxuICAgICAgY29uc3Qgc3RhdHVzTGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgICdhY3RpdmUnOiAnxJBhbmcga2luaCBkb2FuaCcsXHJcbiAgICAgICAgJ2luYWN0aXZlJzogJ05n4burbmcga2luaCBkb2FuaCcsXHJcbiAgICAgICAgJ2Rpc2NvbnRpbnVlZCc6ICdOZ+G7q25nIHPhuqNuIHh14bqldCdcclxuICAgICAgfTtcclxuICAgICAgaGlzdG9yeUVudHJpZXMucHVzaChjcmVhdGVTdGF0dXNDaGFuZ2VkRW50cnkoXHJcbiAgICAgICAgdXNlckluZm8sXHJcbiAgICAgICAgc3RhdHVzTGFiZWxzW2V4aXN0aW5nUHJvZHVjdC5zdGF0dXMgfHwgJ2FjdGl2ZSddLFxyXG4gICAgICAgIHN0YXR1c0xhYmVsc1t1cGRhdGVkUHJvZHVjdC5zdGF0dXMgfHwgJ2FjdGl2ZSddLFxyXG4gICAgICAgIGAke3VzZXJJbmZvLm5hbWV9IMSRw6MgxJHhu5VpIHRy4bqhbmcgdGjDoWkgdOG7qyBcIiR7c3RhdHVzTGFiZWxzW2V4aXN0aW5nUHJvZHVjdC5zdGF0dXMgfHwgJ2FjdGl2ZSddfVwiIHNhbmcgXCIke3N0YXR1c0xhYmVsc1t1cGRhdGVkUHJvZHVjdC5zdGF0dXMgfHwgJ2FjdGl2ZSddfVwiYFxyXG4gICAgICApKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJhY2sgZmllbGQgY2hhbmdlc1xyXG4gICAgY29uc3QgZmllbGRzVG9UcmFjazogQXJyYXk8eyBrZXk6IGtleW9mIFByb2R1Y3Q7IGxhYmVsOiBzdHJpbmcgfT4gPSBbXHJcbiAgICAgIHsga2V5OiAnbmFtZScsIGxhYmVsOiAnVMOqbiBz4bqjbiBwaOG6qW0nIH0sXHJcbiAgICAgIHsga2V5OiAnaWQnLCBsYWJlbDogJ03DoyBTS1UnIH0sXHJcbiAgICAgIHsga2V5OiAnZGVzY3JpcHRpb24nLCBsYWJlbDogJ03DtCB04bqjJyB9LFxyXG4gICAgICB7IGtleTogJ3Nob3J0RGVzY3JpcHRpb24nLCBsYWJlbDogJ03DtCB04bqjIG5n4bqvbicgfSxcclxuICAgICAgeyBrZXk6ICd0eXBlJywgbGFiZWw6ICdMb+G6oWkgc+G6o24gcGjhuqltJyB9LFxyXG4gICAgICB7IGtleTogJ2NhdGVnb3J5U3lzdGVtSWQnLCBsYWJlbDogJ0RhbmggbeG7pWMnIH0sXHJcbiAgICAgIHsga2V5OiAnYnJhbmRTeXN0ZW1JZCcsIGxhYmVsOiAnVGjGsMahbmcgaGnhu4d1JyB9LFxyXG4gICAgICB7IGtleTogJ3VuaXQnLCBsYWJlbDogJ8SQxqFuIHbhu4sgdMOtbmgnIH0sXHJcbiAgICAgIHsga2V5OiAnY29zdFByaWNlJywgbGFiZWw6ICdHacOhIHbhu5FuJyB9LFxyXG4gICAgICB7IGtleTogJ21pblByaWNlJywgbGFiZWw6ICdHacOhIHThu5FpIHRoaeG7g3UnIH0sXHJcbiAgICAgIHsga2V5OiAnYmFyY29kZScsIGxhYmVsOiAnTcOjIHbhuqFjaCcgfSxcclxuICAgICAgeyBrZXk6ICdwcmltYXJ5U3VwcGxpZXJTeXN0ZW1JZCcsIGxhYmVsOiAnTmjDoCBjdW5nIGPhuqVwIGNow61uaCcgfSxcclxuICAgICAgeyBrZXk6ICd3YXJyYW50eVBlcmlvZE1vbnRocycsIGxhYmVsOiAnVGjhu51pIGjhuqFuIGLhuqNvIGjDoG5oJyB9LFxyXG4gICAgICB7IGtleTogJ3Jlb3JkZXJMZXZlbCcsIGxhYmVsOiAnTeG7qWMgxJHhurd0IGjDoG5nIGzhuqFpJyB9LFxyXG4gICAgICB7IGtleTogJ3NhZmV0eVN0b2NrJywgbGFiZWw6ICdU4buTbiBraG8gYW4gdG/DoG4nIH0sXHJcbiAgICAgIHsga2V5OiAnbWF4U3RvY2snLCBsYWJlbDogJ1Thu5NuIGtobyB04buRaSDEkWEnIH0sXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBjb25zdCBjaGFuZ2VzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHNUb1RyYWNrKSB7XHJcbiAgICAgIGNvbnN0IG9sZFZhbCA9IGV4aXN0aW5nUHJvZHVjdFtmaWVsZC5rZXldO1xyXG4gICAgICBjb25zdCBuZXdWYWwgPSB1cGRhdGVkUHJvZHVjdFtmaWVsZC5rZXldO1xyXG4gICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwgJiYgIShvbGRWYWwgPT09IHVuZGVmaW5lZCAmJiBuZXdWYWwgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICBpZiAoZmllbGQua2V5ID09PSAnc3RhdHVzJykgY29udGludWU7XHJcbiAgICAgICAgY29uc3Qgb2xkRGlzcGxheSA9IG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmIG9sZFZhbCAhPT0gbnVsbCAmJiBvbGRWYWwgIT09ICcnID8gU3RyaW5nKG9sZFZhbCkgOiAnKHRy4buRbmcpJztcclxuICAgICAgICBjb25zdCBuZXdEaXNwbGF5ID0gbmV3VmFsICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsICE9PSBudWxsICYmIG5ld1ZhbCAhPT0gJycgPyBTdHJpbmcobmV3VmFsKSA6ICcodHLhu5FuZyknO1xyXG4gICAgICAgIGNoYW5nZXMucHVzaChgJHtmaWVsZC5sYWJlbH06ICR7b2xkRGlzcGxheX0g4oaSICR7bmV3RGlzcGxheX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUcmFjayBwcmljZSBjaGFuZ2VzIHNlcGFyYXRlbHlcclxuICAgIGlmIChleGlzdGluZ1Byb2R1Y3QuY29zdFByaWNlICE9PSB1cGRhdGVkUHJvZHVjdC5jb3N0UHJpY2UpIHtcclxuICAgICAgY2hhbmdlcy5wdXNoKGBHacOhIHbhu5FuOiAke2V4aXN0aW5nUHJvZHVjdC5jb3N0UHJpY2U/LnRvTG9jYWxlU3RyaW5nKCd2aS1WTicpfSDihpIgJHt1cGRhdGVkUHJvZHVjdC5jb3N0UHJpY2U/LnRvTG9jYWxlU3RyaW5nKCd2aS1WTicpfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGhpc3RvcnlFbnRyaWVzLnB1c2goY3JlYXRlVXBkYXRlZEVudHJ5KFxyXG4gICAgICAgIHVzZXJJbmZvLFxyXG4gICAgICAgIGAke3VzZXJJbmZvLm5hbWV9IMSRw6MgY+G6rXAgbmjhuq10OiAke2NoYW5nZXMuam9pbignLCAnKX1gXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBjb25zdCBwcm9kdWN0V2l0aEhpc3RvcnkgPSB7XHJcbiAgICAuLi51cGRhdGVkUHJvZHVjdCxcclxuICAgIGFjdGl2aXR5SGlzdG9yeTogYXBwZW5kSGlzdG9yeUVudHJ5KGV4aXN0aW5nUHJvZHVjdD8uYWN0aXZpdHlIaXN0b3J5LCAuLi5oaXN0b3J5RW50cmllcylcclxuICB9O1xyXG4gIFxyXG4gIGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZShzeXN0ZW1JZCwgcHJvZHVjdFdpdGhIaXN0b3J5KTtcclxufTtcclxuXHJcbi8vIEV4cG9ydCB0eXBlZCBob29rIHRoYXQgaW5jbHVkZXMgYm90aCBiYXNlIGFuZCBjdXN0b20gbWV0aG9kc1xyXG5leHBvcnQgY29uc3QgdXNlUHJvZHVjdFN0b3JlID0gKCk6IFByb2R1Y3RTdG9yZVN0YXRlID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IGJhc2VTdG9yZSgpO1xyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIGFkZDogYWRkUHJvZHVjdCxcclxuICAgIHVwZGF0ZTogdXBkYXRlUHJvZHVjdCxcclxuICAgIHVwZGF0ZUludmVudG9yeSxcclxuICAgIGNvbW1pdFN0b2NrLFxyXG4gICAgdW5jb21taXRTdG9jayxcclxuICAgIGRpc3BhdGNoU3RvY2ssXHJcbiAgICBjb21wbGV0ZURlbGl2ZXJ5LFxyXG4gICAgcmV0dXJuU3RvY2tGcm9tVHJhbnNpdCxcclxuICAgIHVwZGF0ZUxhc3RQdXJjaGFzZVByaWNlLFxyXG4gICAgc2VhcmNoUHJvZHVjdHMsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEV4cG9ydCBnZXRTdGF0ZSBtZXRob2QgZm9yIG5vbi1ob29rIHVzYWdlXHJcbnVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSA9ICgpID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIGFkZDogYWRkUHJvZHVjdCxcclxuICAgIHVwZGF0ZTogdXBkYXRlUHJvZHVjdCxcclxuICAgIHVwZGF0ZUludmVudG9yeSxcclxuICAgIGNvbW1pdFN0b2NrLFxyXG4gICAgdW5jb21taXRTdG9jayxcclxuICAgIGRpc3BhdGNoU3RvY2ssXHJcbiAgICBjb21wbGV0ZURlbGl2ZXJ5LFxyXG4gICAgcmV0dXJuU3RvY2tGcm9tVHJhbnNpdCxcclxuICAgIHVwZGF0ZUxhc3RQdXJjaGFzZVByaWNlLFxyXG4gICAgc2VhcmNoUHJvZHVjdHMsXHJcbiAgfTtcclxufTtcclxuXHJcbih1c2VQcm9kdWN0U3RvcmUgYXMgdHlwZW9mIHVzZVByb2R1Y3RTdG9yZSAmIHsgc3Vic2NyaWJlPzogdHlwZW9mIGJhc2VTdG9yZS5zdWJzY3JpYmUgfSkuc3Vic2NyaWJlID0gYmFzZVN0b3JlLnN1YnNjcmliZTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNydWRTdG9yZSIsImFzU3lzdGVtSWQiLCJnZXRDdXJyZW50VXNlclN5c3RlbUlkIiwiRnVzZSIsImdldEN1cnJlbnRVc2VySW5mbyIsImNyZWF0ZUNyZWF0ZWRFbnRyeSIsImNyZWF0ZVVwZGF0ZWRFbnRyeSIsImNyZWF0ZVN0YXR1c0NoYW5nZWRFbnRyeSIsImFwcGVuZEhpc3RvcnlFbnRyeSIsImJhc2VTdG9yZSIsImJ1c2luZXNzSWRGaWVsZCIsImdldEN1cnJlbnRVc2VyIiwiYXBpRW5kcG9pbnQiLCJBUElfRU5EUE9JTlQiLCJzeW5jVG9BcGkiLCJjcmVhdGUiLCJwcm9kdWN0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwid2FybiIsImxvZyIsInN5c3RlbUlkIiwiZSIsInVwZGF0ZSIsInVwZGF0ZXMiLCJkZWxldGUiLCJoYXJkIiwicmVzdG9yZSIsIm9yaWdpbmFsQWRkIiwiZ2V0U3RhdGUiLCJhZGQiLCJvcmlnaW5hbFVwZGF0ZSIsIm9yaWdpbmFsUmVtb3ZlIiwicmVtb3ZlIiwib3JpZ2luYWxIYXJkRGVsZXRlIiwiaGFyZERlbGV0ZSIsIm9yaWdpbmFsUmVzdG9yZSIsInNldFN0YXRlIiwiaXRlbSIsInJlc3VsdCIsImNhbk1vZGlmeVN0b2NrIiwidHlwZSIsImlzU3RvY2tUcmFja2VkIiwidXBkYXRlSW52ZW50b3J5IiwicHJvZHVjdFN5c3RlbUlkIiwiYnJhbmNoU3lzdGVtSWQiLCJxdWFudGl0eUNoYW5nZSIsInN0YXRlIiwiZGF0YSIsImZpbmQiLCJwIiwib2xkUXVhbnRpdHkiLCJpbnZlbnRvcnlCeUJyYW5jaCIsIm5ld1F1YW50aXR5IiwibWFwIiwibmV3SW52ZW50b3J5QnlCcmFuY2giLCJjb21taXRTdG9jayIsInF1YW50aXR5IiwibmV3Q29tbWl0dGVkIiwiY29tbWl0dGVkQnlCcmFuY2giLCJ1bmNvbW1pdFN0b2NrIiwiTWF0aCIsIm1heCIsImRpc3BhdGNoU3RvY2siLCJlcnJvciIsIm5ld0ludmVudG9yeSIsIm9sZEludmVudG9yeSIsIm5ld0luVHJhbnNpdCIsImluVHJhbnNpdEJ5QnJhbmNoIiwib2xkIiwibmV3IiwiY2hhbmdlIiwiY29tcGxldGVEZWxpdmVyeSIsInJldHVyblN0b2NrRnJvbVRyYW5zaXQiLCJ1cGRhdGVMYXN0UHVyY2hhc2VQcmljZSIsInByaWNlIiwiZGF0ZSIsImV4aXN0aW5nRGF0ZSIsImxhc3RQdXJjaGFzZURhdGUiLCJEYXRlIiwiZ2V0VGltZSIsIm5ld0RhdGVUcyIsImxhc3RQdXJjaGFzZVByaWNlIiwic2VhcmNoUHJvZHVjdHMiLCJxdWVyeSIsInBhZ2UiLCJsaW1pdCIsImFsbFByb2R1Y3RzIiwiZnVzZSIsImtleXMiLCJ0aHJlc2hvbGQiLCJyZXN1bHRzIiwic2VhcmNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwicGFnaW5hdGVkUmVzdWx0cyIsInNsaWNlIiwiaXRlbXMiLCJ2YWx1ZSIsImxhYmVsIiwibmFtZSIsImlkIiwiaGFzTmV4dFBhZ2UiLCJsZW5ndGgiLCJhZGRQcm9kdWN0IiwidXNlckluZm8iLCJuZXdQcm9kdWN0IiwiaGlzdG9yeUVudHJ5IiwiYWN0aXZpdHlIaXN0b3J5IiwidXBkYXRlUHJvZHVjdCIsInVwZGF0ZWRQcm9kdWN0IiwiZXhpc3RpbmdQcm9kdWN0IiwiaGlzdG9yeUVudHJpZXMiLCJzdGF0dXMiLCJzdGF0dXNMYWJlbHMiLCJwdXNoIiwiZmllbGRzVG9UcmFjayIsImtleSIsImNoYW5nZXMiLCJmaWVsZCIsIm9sZFZhbCIsIm5ld1ZhbCIsInVuZGVmaW5lZCIsIm9sZERpc3BsYXkiLCJTdHJpbmciLCJuZXdEaXNwbGF5IiwiY29zdFByaWNlIiwidG9Mb2NhbGVTdHJpbmciLCJqb2luIiwicHJvZHVjdFdpdGhIaXN0b3J5IiwidXNlUHJvZHVjdFN0b3JlIiwic3Vic2NyaWJlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/products/store.ts\n"));

/***/ })

});