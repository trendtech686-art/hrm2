"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/employees/page",{

/***/ "(app-pages-browser)/./lib/store-factory.ts":
/*!******************************!*\
  !*** ./lib/store-factory.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCrudStore: () => (/* binding */ createCrudStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _smart_prefix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./smart-prefix */ \"(app-pages-browser)/./lib/smart-prefix.ts\");\n/* harmony import */ var _id_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./id-config */ \"(app-pages-browser)/./lib/id-config.ts\");\n\n// persist, createJSONStorage removed - database is now source of truth\n\n\n\nconst SYSTEM_FALLBACK_ID = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)('SYS000000');\nconst asSystemIdFallback = ()=>SYSTEM_FALLBACK_ID;\n// ✅ API Sync helper for store-factory\nasync function syncToAPI(apiEndpoint, action, data, systemId) {\n    try {\n        const endpoint = action === 'create' ? apiEndpoint : `${apiEndpoint}/${systemId || data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : action === 'delete' ? 'DELETE' : 'PATCH'; // restore uses PATCH\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            credentials: 'include',\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.warn(`[Store Factory API] ${action} failed for ${apiEndpoint}:`, response.status);\n        }\n        return response.ok;\n    } catch (error) {\n        console.error(`[Store Factory API] ${action} error for ${apiEndpoint}:`, error);\n        return false;\n    }\n}\nconst createCrudStore = (_initialData, entityType, options)=>{\n    const businessPrefix = (0,_smart_prefix__WEBPACK_IMPORTED_MODULE_1__.getPrefix)(entityType); // Vietnamese prefix for Business ID (NV, KH, DH)\n    const config = _id_config__WEBPACK_IMPORTED_MODULE_2__.ID_CONFIG[entityType];\n    const systemIdPrefix = config?.systemIdPrefix || entityType.toUpperCase(); // English prefix for SystemId (EMP, CUSTOMER, ORDER)\n    const businessIdField = options?.businessIdField ?? 'id';\n    // const persistKey = options?.persistKey; // @deprecated - No longer used\n    const getCurrentUser = options?.getCurrentUser;\n    const apiEndpoint = options?.apiEndpoint;\n    // ✅ CHANGED: Start with empty array - database is source of truth\n    // Mock data files (data.ts) are NO LONGER USED for runtime\n    const normalizedInitialData = [];\n    const storeConfig = (set, get)=>({\n            data: normalizedInitialData,\n            // ✅ Counters start at 0 - will be initialized from API via loadFromAPI()\n            _counters: {\n                systemId: 0,\n                businessId: 0\n            },\n            _initialized: false,\n            add: (item)=>{\n                // ✅ Get counters from state (persisted)\n                const currentCounters = get()._counters;\n                const newSystemIdCounter = currentCounters.systemId + 1;\n                const newSystemId = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)((0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(entityType, newSystemIdCounter));\n                // Generate or validate Business ID (if field exists)\n                let finalItem = {\n                    ...item\n                };\n                let newBusinessIdCounter = currentCounters.businessId;\n                if (businessIdField in item) {\n                    const customId = item[businessIdField];\n                    const existingIds = get().data.map((d)=>d[businessIdField]);\n                    // ✅ If customId provided, validate uniqueness\n                    if (customId && customId.trim()) {\n                        if (!(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(customId, existingIds)) {\n                            throw new Error(`Mã \"${customId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                        }\n                        finalItem[businessIdField] = customId.trim().toUpperCase();\n                    } else {\n                        // ✅ Auto-generate with findNextAvailableBusinessId\n                        const digitCount = 6; // All entities use 6 digits\n                        const result = (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(businessPrefix, existingIds, newBusinessIdCounter, digitCount);\n                        finalItem[businessIdField] = result.nextId;\n                        newBusinessIdCounter = result.updatedCounter;\n                    }\n                }\n                const now = new Date().toISOString();\n                const currentUser = getCurrentUser?.();\n                const newItem = {\n                    ...finalItem,\n                    systemId: newSystemId,\n                    createdAt: finalItem.createdAt || now,\n                    updatedAt: now,\n                    createdBy: finalItem.createdBy || currentUser,\n                    updatedBy: currentUser\n                };\n                // ✅ Update both data and counters atomically\n                set((state)=>({\n                        data: [\n                            ...state.data,\n                            newItem\n                        ],\n                        _counters: {\n                            systemId: newSystemIdCounter,\n                            businessId: newBusinessIdCounter\n                        }\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    syncToAPI(apiEndpoint, 'create', newItem).catch(console.error);\n                }\n                return newItem;\n            },\n            addMultiple: (items)=>set((state)=>{\n                    const now = new Date().toISOString();\n                    const currentUser = getCurrentUser?.();\n                    const newItems = [];\n                    const digitCount = 6; // All entities use 6 digits\n                    // ✅ Start from current counters\n                    let currentSystemIdCounter = state._counters.systemId;\n                    let currentBusinessIdCounter = state._counters.businessId;\n                    items.forEach((item)=>{\n                        // ✅ Generate SystemId from current counter\n                        currentSystemIdCounter++;\n                        const newSystemId = (0,_id_config__WEBPACK_IMPORTED_MODULE_2__.createSystemId)((0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(entityType, currentSystemIdCounter));\n                        // Generate or validate Business ID (if field exists)\n                        let finalItem = {\n                            ...item\n                        };\n                        if (businessIdField in item) {\n                            const customId = item[businessIdField];\n                            // Collect existing IDs (from state + already added in this batch)\n                            const existingIds = [\n                                ...state.data.map((d)=>d[businessIdField]),\n                                ...newItems.map((d)=>d[businessIdField])\n                            ];\n                            // ✅ If customId provided, validate uniqueness\n                            if (customId && customId.trim()) {\n                                if (!(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(customId, existingIds)) {\n                                    throw new Error(`Mã \"${customId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                                }\n                                finalItem[businessIdField] = customId.trim().toUpperCase();\n                            } else {\n                                // ✅ Auto-generate with findNextAvailableBusinessId\n                                const result = (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(businessPrefix, existingIds, currentBusinessIdCounter, digitCount);\n                                finalItem[businessIdField] = result.nextId;\n                                currentBusinessIdCounter = result.updatedCounter;\n                            }\n                        }\n                        newItems.push({\n                            ...finalItem,\n                            systemId: newSystemId,\n                            createdAt: now,\n                            updatedAt: now,\n                            createdBy: currentUser,\n                            updatedBy: currentUser\n                        });\n                    });\n                    // ✅ Update both data and counters\n                    const result = {\n                        data: [\n                            ...state.data,\n                            ...newItems\n                        ],\n                        _counters: {\n                            systemId: currentSystemIdCounter,\n                            businessId: currentBusinessIdCounter\n                        }\n                    };\n                    // ✅ Sync to API in background (batch)\n                    if (apiEndpoint) {\n                        newItems.forEach((item)=>{\n                            syncToAPI(apiEndpoint, 'create', item).catch(console.error);\n                        });\n                    }\n                    return result;\n                }),\n            update: (systemId, updatedItem)=>{\n                // Validate unique business ID (case-insensitive, skip self)\n                if (businessIdField in updatedItem) {\n                    const businessId = updatedItem[businessIdField];\n                    const existingIds = get().data.filter((d)=>d.systemId !== systemId).map((d)=>d[businessIdField]);\n                    if (businessId && !(0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.isBusinessIdUnique)(businessId, existingIds)) {\n                        throw new Error(`Mã \"${businessId}\" đã tồn tại! Vui lòng sử dụng mã khác.`);\n                    }\n                }\n                const now = new Date().toISOString();\n                const currentUser = getCurrentUser?.();\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                ...updatedItem,\n                                updatedAt: now,\n                                updatedBy: currentUser\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const fullItem = get().data.find((item)=>item.systemId === systemId);\n                    if (fullItem) {\n                        syncToAPI(apiEndpoint, 'update', fullItem, systemId).catch(console.error);\n                    }\n                }\n            },\n            remove: (systemId)=>{\n                // Soft delete - mark as deleted\n                const now = new Date().toISOString();\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                isDeleted: true,\n                                deletedAt: now\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const item = get().data.find((item)=>item.systemId === systemId);\n                    if (item) {\n                        syncToAPI(apiEndpoint, 'update', {\n                            ...item,\n                            isDeleted: true,\n                            deletedAt: now\n                        }, systemId).catch(console.error);\n                    }\n                }\n            },\n            hardDelete: (systemId)=>{\n                // Permanent delete - remove from array\n                set((state)=>({\n                        data: state.data.filter((item)=>item.systemId !== systemId)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    syncToAPI(apiEndpoint, 'delete', {\n                        systemId\n                    }, systemId).catch(console.error);\n                }\n            },\n            restore: (systemId)=>{\n                // Restore soft-deleted item\n                set((state)=>({\n                        data: state.data.map((item)=>item.systemId === systemId ? {\n                                ...item,\n                                isDeleted: false,\n                                deletedAt: null\n                            } : item)\n                    }));\n                // ✅ Sync to API in background\n                if (apiEndpoint) {\n                    const item = get().data.find((item)=>item.systemId === systemId);\n                    if (item) {\n                        syncToAPI(apiEndpoint, 'restore', {\n                            ...item,\n                            isDeleted: false,\n                            deletedAt: null\n                        }, systemId).catch(console.error);\n                    }\n                }\n            },\n            getActive: ()=>get().data.filter((item)=>!item.isDeleted),\n            getDeleted: ()=>get().data.filter((item)=>item.isDeleted),\n            findById: (id)=>get().data.find((item)=>item.systemId === id || item.id === id),\n            // ✅ Load data from database API - OPTIMIZED: No more limit=10000!\n            // This is now only used for counter initialization, NOT for loading all data\n            // Use React Query hooks for data fetching with proper pagination\n            loadFromAPI: async ()=>{\n                if (!apiEndpoint) return;\n                if (get()._initialized) return;\n                try {\n                    // Only fetch minimal data needed to initialize counters\n                    // Actual data loading should be done via React Query hooks\n                    const response = await fetch(`${apiEndpoint}?limit=1&sortBy=systemId&sortOrder=desc`, {\n                        credentials: 'include'\n                    });\n                    if (response.ok) {\n                        const json = await response.json();\n                        const pagination = json.pagination || {};\n                        const lastItem = json.data?.[0];\n                        // Initialize counters from the latest item (highest IDs)\n                        const newCounters = {\n                            systemId: lastItem ? (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)([\n                                lastItem\n                            ], systemIdPrefix) : 0,\n                            businessId: lastItem && options?.businessIdField ? (0,_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)([\n                                lastItem\n                            ], businessPrefix) : 0\n                        };\n                        set({\n                            data: [],\n                            _counters: newCounters,\n                            _initialized: true\n                        });\n                        console.log(`[Store Factory] ${apiEndpoint} initialized. Total records: ${pagination.total || 'unknown'}`);\n                    }\n                } catch (error) {\n                    console.error(`[Store Factory] loadFromAPI error for ${apiEndpoint}:`, error);\n                    // Still mark as initialized to prevent infinite retry\n                    set({\n                        _initialized: true\n                    });\n                }\n            }\n        });\n    // ✅ SIMPLIFIED: No localStorage persistence, database is source of truth\n    // Data is loaded via ApiSyncProvider on app init\n    return (0,zustand__WEBPACK_IMPORTED_MODULE_3__.create)(storeConfig);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdG9yZS1mYWN0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBQ2pDLHVFQUF1RTtBQVNuRDtBQUN1QjtBQUNrRjtBQUU3SCxNQUFNUyxxQkFBK0JELDBEQUFjQSxDQUFDO0FBRXBELE1BQU1FLHFCQUFxQixJQUFnQkQ7QUFFM0Msc0NBQXNDO0FBQ3RDLGVBQWVFLFVBQ2JDLFdBQW1CLEVBQ25CQyxNQUFrRCxFQUNsREMsSUFBZ0MsRUFDaENDLFFBQW1CO0lBRW5CLElBQUk7UUFDRixNQUFNQyxXQUFXSCxXQUFXLFdBQ3hCRCxjQUNBLEdBQUdBLFlBQVksQ0FBQyxFQUFFRyxZQUFZLEtBQWNBLFFBQVEsRUFBRTtRQUUxRCxNQUFNRSxTQUFTSixXQUFXLFdBQVcsU0FDakNBLFdBQVcsV0FBVyxVQUN0QkEsV0FBVyxXQUFXLFdBQ3RCLFNBQVMscUJBQXFCO1FBRWxDLE1BQU1LLFdBQVcsTUFBTUMsTUFBTUgsVUFBVTtZQUNyQ0M7WUFDQUcsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDOUNDLGFBQWE7WUFDYkMsTUFBTVQsV0FBVyxXQUFXVSxLQUFLQyxTQUFTLENBQUNWLFFBQVFXO1FBQ3JEO1FBRUEsSUFBSSxDQUFDUCxTQUFTUSxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLElBQUksQ0FBQyxDQUFDLG9CQUFvQixFQUFFZixPQUFPLFlBQVksRUFBRUQsWUFBWSxDQUFDLENBQUMsRUFBRU0sU0FBU1csTUFBTTtRQUMxRjtRQUNBLE9BQU9YLFNBQVNRLEVBQUU7SUFDcEIsRUFBRSxPQUFPSSxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixFQUFFakIsT0FBTyxXQUFXLEVBQUVELFlBQVksQ0FBQyxDQUFDLEVBQUVrQjtRQUN6RSxPQUFPO0lBQ1Q7QUFDRjtBQTJCTyxNQUFNQyxrQkFBa0IsQ0FDN0JDLGNBQ0FDLFlBQ0FDO0lBT0EsTUFBTUMsaUJBQWlCN0Isd0RBQVNBLENBQUMy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bGliXFxzdG9yZS1mYWN0b3J5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xyXG4vLyBwZXJzaXN0LCBjcmVhdGVKU09OU3RvcmFnZSByZW1vdmVkIC0gZGF0YWJhc2UgaXMgbm93IHNvdXJjZSBvZiB0cnV0aFxyXG5pbXBvcnQgeyBcclxuICBnZW5lcmF0ZVN5c3RlbUlkLCBcclxuICBnZW5lcmF0ZUJ1c2luZXNzSWQsIFxyXG4gIGlzQnVzaW5lc3NJZFVuaXF1ZSxcclxuICBnZXRNYXhTeXN0ZW1JZENvdW50ZXIsXHJcbiAgZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkLFxyXG4gIHR5cGUgRW50aXR5VHlwZSBcclxufSBmcm9tICcuL2lkLXV0aWxzJztcclxuaW1wb3J0IHsgZ2V0UHJlZml4IH0gZnJvbSAnLi9zbWFydC1wcmVmaXgnO1xyXG5pbXBvcnQgeyBJRF9DT05GSUcsIHR5cGUgU3lzdGVtSWQsIHR5cGUgQnVzaW5lc3NJZCwgY3JlYXRlU3lzdGVtSWQsIGNyZWF0ZUJ1c2luZXNzSWQgYXMgYnJhbmRCdXNpbmVzc0lkIH0gZnJvbSAnLi9pZC1jb25maWcnO1xyXG5cclxuY29uc3QgU1lTVEVNX0ZBTExCQUNLX0lEOiBTeXN0ZW1JZCA9IGNyZWF0ZVN5c3RlbUlkKCdTWVMwMDAwMDAnKTtcclxuXHJcbmNvbnN0IGFzU3lzdGVtSWRGYWxsYmFjayA9ICgpOiBTeXN0ZW1JZCA9PiBTWVNURU1fRkFMTEJBQ0tfSUQ7XHJcblxyXG4vLyDinIUgQVBJIFN5bmMgaGVscGVyIGZvciBzdG9yZS1mYWN0b3J5XHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNUb0FQSTxUPihcclxuICBhcGlFbmRwb2ludDogc3RyaW5nLFxyXG4gIGFjdGlvbjogJ2NyZWF0ZScgfCAndXBkYXRlJyB8ICdkZWxldGUnIHwgJ3Jlc3RvcmUnLFxyXG4gIGRhdGE6IFQgfCB7IHN5c3RlbUlkOiBTeXN0ZW1JZCB9LFxyXG4gIHN5c3RlbUlkPzogU3lzdGVtSWRcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gYWN0aW9uID09PSAnY3JlYXRlJyBcclxuICAgICAgPyBhcGlFbmRwb2ludCBcclxuICAgICAgOiBgJHthcGlFbmRwb2ludH0vJHtzeXN0ZW1JZCB8fCAoZGF0YSBhcyBhbnkpLnN5c3RlbUlkfWA7XHJcbiAgICBcclxuICAgIGNvbnN0IG1ldGhvZCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnUE9TVCcgXHJcbiAgICAgIDogYWN0aW9uID09PSAndXBkYXRlJyA/ICdQQVRDSCcgXHJcbiAgICAgIDogYWN0aW9uID09PSAnZGVsZXRlJyA/ICdERUxFVEUnXHJcbiAgICAgIDogJ1BBVENIJzsgLy8gcmVzdG9yZSB1c2VzIFBBVENIXHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgYm9keTogYWN0aW9uICE9PSAnZGVsZXRlJyA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc29sZS53YXJuKGBbU3RvcmUgRmFjdG9yeSBBUEldICR7YWN0aW9ufSBmYWlsZWQgZm9yICR7YXBpRW5kcG9pbnR9OmAsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2Uub2s7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFtTdG9yZSBGYWN0b3J5IEFQSV0gJHthY3Rpb259IGVycm9yIGZvciAke2FwaUVuZHBvaW50fTpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBJdGVtIHdpdGggU3lzdGVtSWQgKGJyYW5kZWQgdHlwZSlcclxuZXhwb3J0IHR5cGUgSXRlbVdpdGhTeXN0ZW1JZCA9IHsgc3lzdGVtSWQ6IFN5c3RlbUlkOyBba2V5OiBzdHJpbmddOiBhbnkgfTtcclxuXHJcbi8vIOKchSBDb3VudGVyIHN0YXRlIGZvciBJRCBnZW5lcmF0aW9uXHJcbmV4cG9ydCB0eXBlIENvdW50ZXJTdGF0ZSA9IHtcclxuICBzeXN0ZW1JZDogbnVtYmVyO1xyXG4gIGJ1c2luZXNzSWQ6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIENydWRTdGF0ZTxUIGV4dGVuZHMgSXRlbVdpdGhTeXN0ZW1JZD4gPSB7XHJcbiAgZGF0YTogVFtdO1xyXG4gIF9jb3VudGVyczogQ291bnRlclN0YXRlOyAvLyDinIUgUGVyc2lzdGVkIGNvdW50ZXJzXHJcbiAgX2luaXRpYWxpemVkOiBib29sZWFuOyAvLyDinIUgVHJhY2sgaWYgbG9hZGVkIGZyb20gQVBJXHJcbiAgYWRkOiAoaXRlbTogT21pdDxULCAnc3lzdGVtSWQnPikgPT4gVDtcclxuICBhZGRNdWx0aXBsZTogKGl0ZW1zOiBPbWl0PFQsICdzeXN0ZW1JZCc+W10pID0+IHZvaWQ7XHJcbiAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBQYXJ0aWFsPFQ+KSA9PiB2b2lkOyAvLyDinIUgQWNjZXB0IHBhcnRpYWwgdXBkYXRlc1xyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gdm9pZDsgLy8g4pyFIEJyYW5kZWQgdHlwZVxyXG4gIGhhcmREZWxldGU6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHZvaWQ7IC8vIOKchSBCcmFuZGVkIHR5cGVcclxuICByZXN0b3JlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB2b2lkOyAvLyDinIUgQnJhbmRlZCB0eXBlXHJcbiAgZmluZEJ5SWQ6IChzeXN0ZW1JZDogU3lzdGVtSWQgfCBzdHJpbmcpID0+IFQgfCB1bmRlZmluZWQ7IC8vIOKchSBCcmFuZGVkIHR5cGVcclxuICBnZXRBY3RpdmU6ICgpID0+IFRbXTtcclxuICBnZXREZWxldGVkOiAoKSA9PiBUW107XHJcbiAgbG9hZEZyb21BUEk6ICgpID0+IFByb21pc2U8dm9pZD47IC8vIOKchSBMb2FkIGRhdGEgZnJvbSBkYXRhYmFzZVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNydWRTdG9yZSA9IDxUIGV4dGVuZHMgSXRlbVdpdGhTeXN0ZW1JZD4oXHJcbiAgX2luaXRpYWxEYXRhOiBUW10sIC8vIEBkZXByZWNhdGVkIC0gS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBidXQgTk8gTE9OR0VSIFVTRURcclxuICBlbnRpdHlUeXBlOiBFbnRpdHlUeXBlLCAvLyBDaGFuZ2VkIGZyb20gaWRQcmVmaXggdG8gZW50aXR5VHlwZVxyXG4gIG9wdGlvbnM/OiB7XHJcbiAgICBidXNpbmVzc0lkRmllbGQ/OiBrZXlvZiBUOyAvLyBGaWVsZCBuYW1lIGZvciBidXNpbmVzcyBJRCAoZGVmYXVsdDogJ2lkJylcclxuICAgIHBlcnNpc3RLZXk/OiBzdHJpbmc7IC8vIEBkZXByZWNhdGVkIC0gTm8gbG9uZ2VyIHVzZWQsIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgIGdldEN1cnJlbnRVc2VyPzogKCkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkOyAvLyBGdW5jdGlvbiB0byBnZXQgY3VycmVudCB1c2VyIHN5c3RlbUlkXHJcbiAgICBhcGlFbmRwb2ludD86IHN0cmluZzsgLy8g4pyFIEFQSSBlbmRwb2ludCBmb3IgZGF0YWJhc2Ugc3luYyAoZS5nLiwgJy9hcGkvZW1wbG95ZWVzJylcclxuICB9XHJcbikgPT4ge1xyXG4gIGNvbnN0IGJ1c2luZXNzUHJlZml4ID0gZ2V0UHJlZml4KGVudGl0eVR5cGUpOyAvLyBWaWV0bmFtZXNlIHByZWZpeCBmb3IgQnVzaW5lc3MgSUQgKE5WLCBLSCwgREgpXHJcbiAgY29uc3QgY29uZmlnID0gSURfQ09ORklHW2VudGl0eVR5cGVdO1xyXG4gIGNvbnN0IHN5c3RlbUlkUHJlZml4ID0gY29uZmlnPy5zeXN0ZW1JZFByZWZpeCB8fCBlbnRpdHlUeXBlLnRvVXBwZXJDYXNlKCk7IC8vIEVuZ2xpc2ggcHJlZml4IGZvciBTeXN0ZW1JZCAoRU1QLCBDVVNUT01FUiwgT1JERVIpXHJcbiAgXHJcbiAgY29uc3QgYnVzaW5lc3NJZEZpZWxkID0gb3B0aW9ucz8uYnVzaW5lc3NJZEZpZWxkID8/ICdpZCc7XHJcbiAgLy8gY29uc3QgcGVyc2lzdEtleSA9IG9wdGlvbnM/LnBlcnNpc3RLZXk7IC8vIEBkZXByZWNhdGVkIC0gTm8gbG9uZ2VyIHVzZWRcclxuICBjb25zdCBnZXRDdXJyZW50VXNlciA9IG9wdGlvbnM/LmdldEN1cnJlbnRVc2VyO1xyXG4gIGNvbnN0IGFwaUVuZHBvaW50ID0gb3B0aW9ucz8uYXBpRW5kcG9pbnQ7XHJcblxyXG4gIC8vIOKchSBDSEFOR0VEOiBTdGFydCB3aXRoIGVtcHR5IGFycmF5IC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbiAgLy8gTW9jayBkYXRhIGZpbGVzIChkYXRhLnRzKSBhcmUgTk8gTE9OR0VSIFVTRUQgZm9yIHJ1bnRpbWVcclxuICBjb25zdCBub3JtYWxpemVkSW5pdGlhbERhdGE6IFRbXSA9IFtdO1xyXG5cclxuICBjb25zdCBzdG9yZUNvbmZpZyA9IChzZXQ6IGFueSwgZ2V0OiBhbnkpID0+ICh7XHJcbiAgICBkYXRhOiBub3JtYWxpemVkSW5pdGlhbERhdGEsIC8vIOKchSBTdGFydCBlbXB0eSAtIGRhdGEgbG9hZGVkIHZpYSBSZWFjdCBRdWVyeVxyXG4gICAgLy8g4pyFIENvdW50ZXJzIHN0YXJ0IGF0IDAgLSB3aWxsIGJlIGluaXRpYWxpemVkIGZyb20gQVBJIHZpYSBsb2FkRnJvbUFQSSgpXHJcbiAgICBfY291bnRlcnM6IHtcclxuICAgICAgc3lzdGVtSWQ6IDAsXHJcbiAgICAgIGJ1c2luZXNzSWQ6IDBcclxuICAgIH0sXHJcbiAgICBfaW5pdGlhbGl6ZWQ6IGZhbHNlLCAvLyDinIUgVHJhY2sgQVBJIGluaXRpYWxpemF0aW9uXHJcbiAgICBhZGQ6IChpdGVtOiBPbWl0PFQsICdzeXN0ZW1JZCc+KTogVCA9PiB7XHJcbiAgICAgICAgLy8g4pyFIEdldCBjb3VudGVycyBmcm9tIHN0YXRlIChwZXJzaXN0ZWQpXHJcbiAgICAgICAgY29uc3QgY3VycmVudENvdW50ZXJzID0gZ2V0KCkuX2NvdW50ZXJzO1xyXG4gICAgICAgIGNvbnN0IG5ld1N5c3RlbUlkQ291bnRlciA9IGN1cnJlbnRDb3VudGVycy5zeXN0ZW1JZCArIDE7XHJcbiAgICAgICAgY29uc3QgbmV3U3lzdGVtSWQgPSBjcmVhdGVTeXN0ZW1JZChnZW5lcmF0ZVN5c3RlbUlkKGVudGl0eVR5cGUsIG5ld1N5c3RlbUlkQ291bnRlcikpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEdlbmVyYXRlIG9yIHZhbGlkYXRlIEJ1c2luZXNzIElEIChpZiBmaWVsZCBleGlzdHMpXHJcbiAgICAgICAgbGV0IGZpbmFsSXRlbSA9IHsgLi4uaXRlbSB9IGFzIGFueTtcclxuICAgICAgICBsZXQgbmV3QnVzaW5lc3NJZENvdW50ZXIgPSBjdXJyZW50Q291bnRlcnMuYnVzaW5lc3NJZDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYnVzaW5lc3NJZEZpZWxkIGluIGl0ZW0pIHtcclxuICAgICAgICAgIGNvbnN0IGN1c3RvbUlkID0gKGl0ZW0gYXMgYW55KVtidXNpbmVzc0lkRmllbGRdO1xyXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBnZXQoKS5kYXRhLm1hcCgoZDogYW55KSA9PiBkW2J1c2luZXNzSWRGaWVsZF0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyDinIUgSWYgY3VzdG9tSWQgcHJvdmlkZWQsIHZhbGlkYXRlIHVuaXF1ZW5lc3NcclxuICAgICAgICAgIGlmIChjdXN0b21JZCAmJiBjdXN0b21JZC50cmltKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0J1c2luZXNzSWRVbmlxdWUoY3VzdG9tSWQsIGV4aXN0aW5nSWRzKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTcOjIFwiJHtjdXN0b21JZH1cIiDEkcOjIHThu5NuIHThuqFpISBWdWkgbMOybmcgc+G7rSBk4bulbmcgbcOjIGtow6FjLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gY3VzdG9tSWQudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDinIUgQXV0by1nZW5lcmF0ZSB3aXRoIGZpbmROZXh0QXZhaWxhYmxlQnVzaW5lc3NJZFxyXG4gICAgICAgICAgICBjb25zdCBkaWdpdENvdW50ID0gNjsgLy8gQWxsIGVudGl0aWVzIHVzZSA2IGRpZ2l0c1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQoYnVzaW5lc3NQcmVmaXgsIGV4aXN0aW5nSWRzLCBuZXdCdXNpbmVzc0lkQ291bnRlciwgZGlnaXRDb3VudCk7XHJcbiAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gcmVzdWx0Lm5leHRJZDtcclxuICAgICAgICAgICAgbmV3QnVzaW5lc3NJZENvdW50ZXIgPSByZXN1bHQudXBkYXRlZENvdW50ZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGdldEN1cnJlbnRVc2VyPy4oKTtcclxuICAgICAgICBjb25zdCBuZXdJdGVtID0geyBcclxuICAgICAgICAgIC4uLmZpbmFsSXRlbSwgXHJcbiAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWQsIC8vIOKchSBCcmFuZGVkIFN5c3RlbUlkXHJcbiAgICAgICAgICBjcmVhdGVkQXQ6IGZpbmFsSXRlbS5jcmVhdGVkQXQgfHwgbm93LFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBub3csXHJcbiAgICAgICAgICBjcmVhdGVkQnk6IGZpbmFsSXRlbS5jcmVhdGVkQnkgfHwgY3VycmVudFVzZXIsXHJcbiAgICAgICAgICB1cGRhdGVkQnk6IGN1cnJlbnRVc2VyLFxyXG4gICAgICAgIH0gYXMgdW5rbm93biBhcyBUO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIOKchSBVcGRhdGUgYm90aCBkYXRhIGFuZCBjb3VudGVycyBhdG9taWNhbGx5XHJcbiAgICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoeyBcclxuICAgICAgICAgIGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCBuZXdJdGVtXSxcclxuICAgICAgICAgIF9jb3VudGVyczoge1xyXG4gICAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICAgICAgICBidXNpbmVzc0lkOiBuZXdCdXNpbmVzc0lkQ291bnRlclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDinIUgU3luYyB0byBBUEkgaW4gYmFja2dyb3VuZFxyXG4gICAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAnY3JlYXRlJywgbmV3SXRlbSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBuZXdJdGVtO1xyXG4gICAgfSxcclxuICAgIGFkZE11bHRpcGxlOiAoaXRlbXM6IE9taXQ8VCwgJ3N5c3RlbUlkJz5bXSkgPT4gXHJcbiAgICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFVzZXIgPSBnZXRDdXJyZW50VXNlcj8uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1zOiBUW10gPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZGlnaXRDb3VudCA9IDY7IC8vIEFsbCBlbnRpdGllcyB1c2UgNiBkaWdpdHNcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBTdGFydCBmcm9tIGN1cnJlbnQgY291bnRlcnNcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIgPSBzdGF0ZS5fY291bnRlcnMuc3lzdGVtSWQ7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIgPSBzdGF0ZS5fY291bnRlcnMuYnVzaW5lc3NJZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyDinIUgR2VuZXJhdGUgU3lzdGVtSWQgZnJvbSBjdXJyZW50IGNvdW50ZXJcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N5c3RlbUlkID0gY3JlYXRlU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZChlbnRpdHlUeXBlLCBjdXJyZW50U3lzdGVtSWRDb3VudGVyKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG9yIHZhbGlkYXRlIEJ1c2luZXNzIElEIChpZiBmaWVsZCBleGlzdHMpXHJcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxJdGVtID0geyAuLi5pdGVtIH0gYXMgYW55O1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1c2luZXNzSWRGaWVsZCBpbiBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbUlkID0gKGl0ZW0gYXMgYW55KVtidXNpbmVzc0lkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBleGlzdGluZyBJRHMgKGZyb20gc3RhdGUgKyBhbHJlYWR5IGFkZGVkIGluIHRoaXMgYmF0Y2gpXHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLmRhdGEubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4ubmV3SXRlbXMubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSlcclxuICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vIOKchSBJZiBjdXN0b21JZCBwcm92aWRlZCwgdmFsaWRhdGUgdW5pcXVlbmVzc1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tSWQgJiYgY3VzdG9tSWQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0J1c2luZXNzSWRVbmlxdWUoY3VzdG9tSWQsIGV4aXN0aW5nSWRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNw6MgXCIke2N1c3RvbUlkfVwiIMSRw6MgdOG7k24gdOG6oWkhIFZ1aSBsw7JuZyBz4butIGThu6VuZyBtw6Mga2jDoWMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gY3VzdG9tSWQudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g4pyFIEF1dG8tZ2VuZXJhdGUgd2l0aCBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQoYnVzaW5lc3NQcmVmaXgsIGV4aXN0aW5nSWRzLCBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIsIGRpZ2l0Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsSXRlbVtidXNpbmVzc0lkRmllbGRdID0gcmVzdWx0Lm5leHRJZDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXIgPSByZXN1bHQudXBkYXRlZENvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaCh7IFxyXG4gICAgICAgICAgICAgICAgICAuLi5maW5hbEl0ZW0sIFxyXG4gICAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbmV3U3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5vdyxcclxuICAgICAgICAgICAgICAgICAgY3JlYXRlZEJ5OiBjdXJyZW50VXNlcixcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlZEJ5OiBjdXJyZW50VXNlcixcclxuICAgICAgICAgICAgICAgIH0gYXMgdW5rbm93biBhcyBUKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGJvdGggZGF0YSBhbmQgY291bnRlcnNcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBcclxuICAgICAgICAgICAgICBkYXRhOiBbLi4uc3RhdGUuZGF0YSwgLi4ubmV3SXRlbXNdLFxyXG4gICAgICAgICAgICAgIF9jb3VudGVyczoge1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtSWQ6IGN1cnJlbnRTeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0lkOiBjdXJyZW50QnVzaW5lc3NJZENvdW50ZXJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgU3luYyB0byBBUEkgaW4gYmFja2dyb3VuZCAoYmF0Y2gpXHJcbiAgICAgICAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgICAgICAgIG5ld0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzeW5jVG9BUEkoYXBpRW5kcG9pbnQsICdjcmVhdGUnLCBpdGVtKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KSxcclxuICAgIHVwZGF0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdXBkYXRlZEl0ZW06IFBhcnRpYWw8VD4pID0+IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdW5pcXVlIGJ1c2luZXNzIElEIChjYXNlLWluc2Vuc2l0aXZlLCBza2lwIHNlbGYpXHJcbiAgICAgIGlmIChidXNpbmVzc0lkRmllbGQgaW4gdXBkYXRlZEl0ZW0pIHtcclxuICAgICAgICBjb25zdCBidXNpbmVzc0lkID0gKHVwZGF0ZWRJdGVtIGFzIGFueSlbYnVzaW5lc3NJZEZpZWxkXTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IGdldCgpLmRhdGFcclxuICAgICAgICAgIC5maWx0ZXIoKGQ6IGFueSkgPT4gZC5zeXN0ZW1JZCAhPT0gc3lzdGVtSWQpXHJcbiAgICAgICAgICAubWFwKChkOiBhbnkpID0+IGRbYnVzaW5lc3NJZEZpZWxkXSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJ1c2luZXNzSWQgJiYgIWlzQnVzaW5lc3NJZFVuaXF1ZShidXNpbmVzc0lkLCBleGlzdGluZ0lkcykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTcOjIFwiJHtidXNpbmVzc0lkfVwiIMSRw6MgdOG7k24gdOG6oWkhIFZ1aSBsw7JuZyBz4butIGThu6VuZyBtw6Mga2jDoWMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gZ2V0Q3VycmVudFVzZXI/LigpO1xyXG4gICAgICBzZXQoKHN0YXRlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAoKGl0ZW06IFQpID0+XHJcbiAgICAgICAgICBpdGVtLnN5c3RlbUlkID09PSBzeXN0ZW1JZCBcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIC4uLnVwZGF0ZWRJdGVtLCB1cGRhdGVkQXQ6IG5vdywgdXBkYXRlZEJ5OiBjdXJyZW50VXNlciB9IGFzIFRcclxuICAgICAgICAgICAgOiBpdGVtXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgZnVsbEl0ZW0gPSBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IHN5c3RlbUlkKTtcclxuICAgICAgICBpZiAoZnVsbEl0ZW0pIHtcclxuICAgICAgICAgIHN5bmNUb0FQSShhcGlFbmRwb2ludCwgJ3VwZGF0ZScsIGZ1bGxJdGVtLCBzeXN0ZW1JZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFNvZnQgZGVsZXRlIC0gbWFyayBhcyBkZWxldGVkXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKChpdGVtOiBUKSA9PlxyXG4gICAgICAgICAgaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWRcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIGlzRGVsZXRlZDogdHJ1ZSwgZGVsZXRlZEF0OiBub3cgfSBhcyBUXHJcbiAgICAgICAgICAgIDogaXRlbVxyXG4gICAgICAgICksXHJcbiAgICAgIH0pKTtcclxuICAgICAgXHJcbiAgICAgIC8vIOKchSBTeW5jIHRvIEFQSSBpbiBiYWNrZ3JvdW5kXHJcbiAgICAgIGlmIChhcGlFbmRwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IHN5c3RlbUlkKTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAndXBkYXRlJywgeyAuLi5pdGVtLCBpc0RlbGV0ZWQ6IHRydWUsIGRlbGV0ZWRBdDogbm93IH0sIHN5c3RlbUlkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoYXJkRGVsZXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFBlcm1hbmVudCBkZWxldGUgLSByZW1vdmUgZnJvbSBhcnJheVxyXG4gICAgICBzZXQoKHN0YXRlOiBhbnkpID0+ICh7XHJcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5maWx0ZXIoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgIT09IHN5c3RlbUlkKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgc3luY1RvQVBJKGFwaUVuZHBvaW50LCAnZGVsZXRlJywgeyBzeXN0ZW1JZCB9LCBzeXN0ZW1JZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZXN0b3JlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgIC8vIFJlc3RvcmUgc29mdC1kZWxldGVkIGl0ZW1cclxuICAgICAgc2V0KChzdGF0ZTogYW55KSA9PiAoe1xyXG4gICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKChpdGVtOiBUKSA9PlxyXG4gICAgICAgICAgaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWRcclxuICAgICAgICAgICAgPyB7IC4uLml0ZW0sIGlzRGVsZXRlZDogZmFsc2UsIGRlbGV0ZWRBdDogbnVsbCB9IGFzIFRcclxuICAgICAgICAgICAgOiBpdGVtXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBcclxuICAgICAgLy8g4pyFIFN5bmMgdG8gQVBJIGluIGJhY2tncm91bmRcclxuICAgICAgaWYgKGFwaUVuZHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldCgpLmRhdGEuZmluZCgoaXRlbTogVCkgPT4gaXRlbS5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpO1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoYXBpRW5kcG9pbnQsICdyZXN0b3JlJywgeyAuLi5pdGVtLCBpc0RlbGV0ZWQ6IGZhbHNlLCBkZWxldGVkQXQ6IG51bGwgfSwgc3lzdGVtSWQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldEFjdGl2ZTogKCkgPT4gZ2V0KCkuZGF0YS5maWx0ZXIoKGl0ZW06IGFueSkgPT4gIWl0ZW0uaXNEZWxldGVkKSxcclxuICAgIGdldERlbGV0ZWQ6ICgpID0+IGdldCgpLmRhdGEuZmlsdGVyKChpdGVtOiBhbnkpID0+IGl0ZW0uaXNEZWxldGVkKSxcclxuICAgIGZpbmRCeUlkOiAoaWQ6IFN5c3RlbUlkIHwgc3RyaW5nKSA9PiBnZXQoKS5kYXRhLmZpbmQoKGl0ZW06IFQpID0+IGl0ZW0uc3lzdGVtSWQgPT09IGlkIHx8IChpdGVtIGFzIGFueSkuaWQgPT09IGlkKSxcclxuICAgIFxyXG4gICAgLy8g4pyFIExvYWQgZGF0YSBmcm9tIGRhdGFiYXNlIEFQSSAtIE9QVElNSVpFRDogTm8gbW9yZSBsaW1pdD0xMDAwMCFcclxuICAgIC8vIFRoaXMgaXMgbm93IG9ubHkgdXNlZCBmb3IgY291bnRlciBpbml0aWFsaXphdGlvbiwgTk9UIGZvciBsb2FkaW5nIGFsbCBkYXRhXHJcbiAgICAvLyBVc2UgUmVhY3QgUXVlcnkgaG9va3MgZm9yIGRhdGEgZmV0Y2hpbmcgd2l0aCBwcm9wZXIgcGFnaW5hdGlvblxyXG4gICAgbG9hZEZyb21BUEk6IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKCFhcGlFbmRwb2ludCkgcmV0dXJuO1xyXG4gICAgICBpZiAoZ2V0KCkuX2luaXRpYWxpemVkKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIE9ubHkgZmV0Y2ggbWluaW1hbCBkYXRhIG5lZWRlZCB0byBpbml0aWFsaXplIGNvdW50ZXJzXHJcbiAgICAgICAgLy8gQWN0dWFsIGRhdGEgbG9hZGluZyBzaG91bGQgYmUgZG9uZSB2aWEgUmVhY3QgUXVlcnkgaG9va3NcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2FwaUVuZHBvaW50fT9saW1pdD0xJnNvcnRCeT1zeXN0ZW1JZCZzb3J0T3JkZXI9ZGVzY2AsIHtcclxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IGpzb24ucGFnaW5hdGlvbiB8fCB7fTtcclxuICAgICAgICAgIGNvbnN0IGxhc3RJdGVtID0ganNvbi5kYXRhPy5bMF07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEluaXRpYWxpemUgY291bnRlcnMgZnJvbSB0aGUgbGF0ZXN0IGl0ZW0gKGhpZ2hlc3QgSURzKVxyXG4gICAgICAgICAgY29uc3QgbmV3Q291bnRlcnMgPSB7XHJcbiAgICAgICAgICAgIHN5c3RlbUlkOiBsYXN0SXRlbSA/IGdldE1heFN5c3RlbUlkQ291bnRlcihbbGFzdEl0ZW1dLCBzeXN0ZW1JZFByZWZpeCkgOiAwLFxyXG4gICAgICAgICAgICBidXNpbmVzc0lkOiAobGFzdEl0ZW0gJiYgb3B0aW9ucz8uYnVzaW5lc3NJZEZpZWxkKVxyXG4gICAgICAgICAgICAgID8gZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIoW2xhc3RJdGVtXSBhcyBhbnlbXSwgYnVzaW5lc3NQcmVmaXgpXHJcbiAgICAgICAgICAgICAgOiAwXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzZXQoeyBcclxuICAgICAgICAgICAgZGF0YTogW10sIC8vIERvbid0IHN0b3JlIGRhdGEgaW4gWnVzdGFuZCBhbnltb3JlIC0gdXNlIFJlYWN0IFF1ZXJ5XHJcbiAgICAgICAgICAgIF9jb3VudGVyczogbmV3Q291bnRlcnMsXHJcbiAgICAgICAgICAgIF9pbml0aWFsaXplZDogdHJ1ZSBcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1N0b3JlIEZhY3RvcnldICR7YXBpRW5kcG9pbnR9IGluaXRpYWxpemVkLiBUb3RhbCByZWNvcmRzOiAke3BhZ2luYXRpb24udG90YWwgfHwgJ3Vua25vd24nfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBbU3RvcmUgRmFjdG9yeV0gbG9hZEZyb21BUEkgZXJyb3IgZm9yICR7YXBpRW5kcG9pbnR9OmAsIGVycm9yKTtcclxuICAgICAgICAvLyBTdGlsbCBtYXJrIGFzIGluaXRpYWxpemVkIHRvIHByZXZlbnQgaW5maW5pdGUgcmV0cnlcclxuICAgICAgICBzZXQoeyBfaW5pdGlhbGl6ZWQ6IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIOKchSBTSU1QTElGSUVEOiBObyBsb2NhbFN0b3JhZ2UgcGVyc2lzdGVuY2UsIGRhdGFiYXNlIGlzIHNvdXJjZSBvZiB0cnV0aFxyXG4gIC8vIERhdGEgaXMgbG9hZGVkIHZpYSBBcGlTeW5jUHJvdmlkZXIgb24gYXBwIGluaXRcclxuICByZXR1cm4gY3JlYXRlPENydWRTdGF0ZTxUPj4oc3RvcmVDb25maWcpO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiZ2VuZXJhdGVTeXN0ZW1JZCIsImlzQnVzaW5lc3NJZFVuaXF1ZSIsImdldE1heFN5c3RlbUlkQ291bnRlciIsImdldE1heEJ1c2luZXNzSWRDb3VudGVyIiwiZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkIiwiZ2V0UHJlZml4IiwiSURfQ09ORklHIiwiY3JlYXRlU3lzdGVtSWQiLCJTWVNURU1fRkFMTEJBQ0tfSUQiLCJhc1N5c3RlbUlkRmFsbGJhY2siLCJzeW5jVG9BUEkiLCJhcGlFbmRwb2ludCIsImFjdGlvbiIsImRhdGEiLCJzeXN0ZW1JZCIsImVuZHBvaW50IiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJjcmVkZW50aWFscyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwib2siLCJjb25zb2xlIiwid2FybiIsInN0YXR1cyIsImVycm9yIiwiY3JlYXRlQ3J1ZFN0b3JlIiwiX2luaXRpYWxEYXRhIiwiZW50aXR5VHlwZSIsIm9wdGlvbnMiLCJidXNpbmVzc1ByZWZpeCIsImNvbmZpZyIsInN5c3RlbUlkUHJlZml4IiwidG9VcHBlckNhc2UiLCJidXNpbmVzc0lkRmllbGQiLCJnZXRDdXJyZW50VXNlciIsIm5vcm1hbGl6ZWRJbml0aWFsRGF0YSIsInN0b3JlQ29uZmlnIiwic2V0IiwiZ2V0IiwiX2NvdW50ZXJzIiwiYnVzaW5lc3NJZCIsIl9pbml0aWFsaXplZCIsImFkZCIsIml0ZW0iLCJjdXJyZW50Q291bnRlcnMiLCJuZXdTeXN0ZW1JZENvdW50ZXIiLCJuZXdTeXN0ZW1JZCIsImZpbmFsSXRlbSIsIm5ld0J1c2luZXNzSWRDb3VudGVyIiwiY3VzdG9tSWQiLCJleGlzdGluZ0lkcyIsIm1hcCIsImQiLCJ0cmltIiwiRXJyb3IiLCJkaWdpdENvdW50IiwicmVzdWx0IiwibmV4dElkIiwidXBkYXRlZENvdW50ZXIiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJjdXJyZW50VXNlciIsIm5ld0l0ZW0iLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJjcmVhdGVkQnkiLCJ1cGRhdGVkQnkiLCJzdGF0ZSIsImNhdGNoIiwiYWRkTXVsdGlwbGUiLCJpdGVtcyIsIm5ld0l0ZW1zIiwiY3VycmVudFN5c3RlbUlkQ291bnRlciIsImN1cnJlbnRCdXNpbmVzc0lkQ291bnRlciIsImZvckVhY2giLCJwdXNoIiwidXBkYXRlIiwidXBkYXRlZEl0ZW0iLCJmaWx0ZXIiLCJmdWxsSXRlbSIsImZpbmQiLCJyZW1vdmUiLCJpc0RlbGV0ZWQiLCJkZWxldGVkQXQiLCJoYXJkRGVsZXRlIiwicmVzdG9yZSIsImdldEFjdGl2ZSIsImdldERlbGV0ZWQiLCJmaW5kQnlJZCIsImlkIiwibG9hZEZyb21BUEkiLCJqc29uIiwicGFnaW5hdGlvbiIsImxhc3RJdGVtIiwibmV3Q291bnRlcnMiLCJsb2ciLCJ0b3RhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/store-factory.ts\n"));

/***/ })

});