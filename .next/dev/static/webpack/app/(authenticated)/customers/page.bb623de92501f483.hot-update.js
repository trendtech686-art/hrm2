"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/customers/page",{

/***/ "(app-pages-browser)/./features/receipts/store.ts":
/*!************************************!*\
  !*** ./features/receipts/store.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useReceiptStore: () => (/* binding */ useReceiptStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/features/finance/document-lookups */ \"(app-pages-browser)/./features/finance/document-lookups.ts\");\n/* harmony import */ var _employees_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../employees/store */ \"(app-pages-browser)/./features/employees/store.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n\n\n\n\n// REMOVED: import { data as initialData } from './data'; // Mock data no longer used - database is source of truth\n\n\n\n// API sync helpers\nasync function syncToAPI(action, data) {\n    try {\n        const endpoint = action === 'create' ? '/api/receipts' : `/api/receipts/${data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : 'DELETE';\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.error(`[Receipts API] ${action} failed:`, await response.text());\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error(`[Receipts API] ${action} error:`, error);\n        return false;\n    }\n}\n// Helper to get current user info\nconst getCurrentUserInfo = ()=>{\n    const currentUserSystemId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.() || 'SYSTEM';\n    const employee = _employees_store__WEBPACK_IMPORTED_MODULE_3__.useEmployeeStore.getState().data.find((e)=>e.systemId === currentUserSystemId);\n    return {\n        systemId: currentUserSystemId,\n        name: employee?.fullName || 'Hệ thống',\n        avatar: employee?.avatarUrl\n    };\n};\n// Helper to create history entry\nconst createHistoryEntry = (action, description, metadata)=>({\n        id: crypto.randomUUID(),\n        action,\n        timestamp: new Date(),\n        user: getCurrentUserInfo(),\n        description,\n        metadata\n    });\nconst SYSTEM_AUTHOR = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)('SYSTEM');\nconst getCurrentReceiptAuthor = ()=>{\n    const userId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.();\n    return userId ? (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)(userId) : SYSTEM_AUTHOR;\n};\nconst RECEIPT_ENTITY = 'receipts';\nconst SYSTEM_ID_PREFIX = 'RECEIPT';\nconst BUSINESS_ID_PREFIX = 'PT';\nconst BUSINESS_ID_DIGITS = 6;\nconst normalizeReceiptStatus = (status)=>status === 'cancelled' ? 'cancelled' : 'completed';\nconst ensureReceiptMetadata = (receipt)=>{\n    let mutated = false;\n    const updates = {};\n    const targetGroup = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickTargetGroup)({\n        systemId: receipt.payerTypeSystemId,\n        name: receipt.payerTypeName\n    });\n    if (targetGroup) {\n        if (receipt.payerTypeSystemId !== targetGroup.systemId) {\n            updates.payerTypeSystemId = targetGroup.systemId;\n            mutated = true;\n        }\n        if (receipt.payerTypeName !== targetGroup.name) {\n            updates.payerTypeName = targetGroup.name;\n            mutated = true;\n        }\n    }\n    const paymentMethod = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentMethod)({\n        systemId: receipt.paymentMethodSystemId,\n        name: receipt.paymentMethodName\n    });\n    if (paymentMethod) {\n        if (receipt.paymentMethodSystemId !== paymentMethod.systemId) {\n            updates.paymentMethodSystemId = paymentMethod.systemId;\n            mutated = true;\n        }\n        if (receipt.paymentMethodName !== paymentMethod.name) {\n            updates.paymentMethodName = paymentMethod.name;\n            mutated = true;\n        }\n    }\n    const account = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickAccount)({\n        accountSystemId: receipt.accountSystemId,\n        branchSystemId: receipt.branchSystemId,\n        paymentMethodName: paymentMethod?.name ?? receipt.paymentMethodName\n    });\n    if (account && receipt.accountSystemId !== account.systemId) {\n        updates.accountSystemId = account.systemId;\n        mutated = true;\n    }\n    const receiptType = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickReceiptType)({\n        systemId: receipt.paymentReceiptTypeSystemId,\n        name: receipt.paymentReceiptTypeName\n    });\n    if (receiptType) {\n        if (receipt.paymentReceiptTypeSystemId !== receiptType.systemId) {\n            updates.paymentReceiptTypeSystemId = receiptType.systemId;\n            mutated = true;\n        }\n        if (receipt.paymentReceiptTypeName !== receiptType.name) {\n            updates.paymentReceiptTypeName = receiptType.name;\n            mutated = true;\n        }\n    }\n    if (!receipt.customerName && receipt.payerName) {\n        updates.customerName = receipt.payerName;\n        mutated = true;\n    }\n    if (!receipt.customerSystemId && receipt.payerSystemId) {\n        updates.customerSystemId = receipt.payerSystemId;\n        mutated = true;\n    }\n    return mutated ? {\n        ...receipt,\n        ...updates\n    } : receipt;\n};\nconst backfillReceiptMetadata = (receipts)=>{\n    let mutated = false;\n    const updated = receipts.map((receipt)=>{\n        const normalized = ensureReceiptMetadata(receipt);\n        if (normalized !== receipt) {\n            mutated = true;\n        }\n        return normalized;\n    });\n    return mutated ? updated : receipts;\n};\nconst initialReceipts = backfillReceiptMetadata(initialData.map((receipt)=>({\n        ...receipt,\n        status: normalizeReceiptStatus(receipt.status)\n    })));\nlet systemIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(initialReceipts, SYSTEM_ID_PREFIX);\nlet businessIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(initialReceipts, BUSINESS_ID_PREFIX);\nconst getNextSystemId = ()=>{\n    systemIdCounter += 1;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(RECEIPT_ENTITY, systemIdCounter));\n};\nconst ensureReceiptBusinessId = (receipts, provided)=>{\n    if (provided && `${provided}`.trim().length > 0) {\n        const normalized = `${provided}`.trim().toUpperCase();\n        const parsedCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.extractCounterFromBusinessId)(normalized, BUSINESS_ID_PREFIX);\n        if (parsedCounter > businessIdCounter) {\n            businessIdCounter = parsedCounter;\n        }\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(normalized);\n    }\n    const existingIds = receipts.map((receipt)=>receipt.id).filter(Boolean);\n    const { nextId, updatedCounter } = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(BUSINESS_ID_PREFIX, existingIds, businessIdCounter, BUSINESS_ID_DIGITS);\n    businessIdCounter = updatedCounter;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(nextId);\n};\nconst useReceiptStore = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_6__.subscribeWithSelector)((set, get)=>({\n        data: initialReceipts,\n        businessIdCounter,\n        systemIdCounter,\n        initialized: false,\n        add: (item)=>{\n            let createdReceipt = null;\n            set((state)=>{\n                const systemId = getNextSystemId();\n                const id = ensureReceiptBusinessId(state.data, item.id);\n                const createdBy = item.createdBy ?? getCurrentReceiptAuthor();\n                const newReceipt = {\n                    ...item,\n                    systemId,\n                    id,\n                    createdBy,\n                    createdAt: item.createdAt || new Date().toISOString(),\n                    status: normalizeReceiptStatus(item.status),\n                    orderAllocations: item.orderAllocations ?? []\n                };\n                const normalizedReceipt = ensureReceiptMetadata(newReceipt);\n                createdReceipt = normalizedReceipt;\n                return {\n                    data: [\n                        ...state.data,\n                        normalizedReceipt\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync to API\n            if (createdReceipt) {\n                syncToAPI('create', createdReceipt).catch(console.error);\n            }\n            return createdReceipt;\n        },\n        addMultiple: (items)=>{\n            const created = [];\n            set((state)=>{\n                items.forEach((item)=>{\n                    const context = [\n                        ...state.data,\n                        ...created\n                    ];\n                    const systemId = getNextSystemId();\n                    const id = ensureReceiptBusinessId(context, item.id);\n                    const createdBy = item.createdBy ?? getCurrentReceiptAuthor();\n                    const newReceipt = {\n                        ...item,\n                        systemId,\n                        id,\n                        createdBy,\n                        createdAt: item.createdAt || new Date().toISOString(),\n                        status: normalizeReceiptStatus(item.status),\n                        orderAllocations: item.orderAllocations ?? []\n                    };\n                    created.push(ensureReceiptMetadata(newReceipt));\n                });\n                return {\n                    data: [\n                        ...state.data,\n                        ...created\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync all to API\n            created.forEach((receipt)=>{\n                syncToAPI('create', receipt).catch(console.error);\n            });\n        },\n        update: (systemId, item)=>{\n            const updated = {\n                ...item,\n                status: normalizeReceiptStatus(item.status),\n                updatedAt: new Date().toISOString()\n            };\n            set((state)=>({\n                    data: state.data.map((r)=>r.systemId === systemId ? updated : r),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('update', updated).catch(console.error);\n        },\n        remove: (systemId)=>{\n            set((state)=>({\n                    data: state.data.filter((r)=>r.systemId !== systemId),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('delete', {\n                systemId\n            }).catch(console.error);\n        },\n        findById: (systemId)=>{\n            return get().data.find((r)=>r.systemId === systemId);\n        },\n        getActive: ()=>{\n            return get().data.filter((r)=>r.status !== 'cancelled');\n        },\n        cancel: (systemId, reason)=>{\n            const receipt = get().findById(systemId);\n            if (receipt && receipt.status !== 'cancelled') {\n                const historyEntry = createHistoryEntry('cancelled', `Đã hủy phiếu thu${reason ? `: ${reason}` : ''}`, {\n                    oldValue: 'Hoàn thành',\n                    newValue: 'Đã hủy',\n                    note: reason\n                });\n                get().update(systemId, {\n                    ...receipt,\n                    status: 'cancelled',\n                    cancelledAt: new Date().toISOString(),\n                    activityHistory: [\n                        ...receipt.activityHistory || [],\n                        historyEntry\n                    ]\n                });\n            }\n        },\n        loadFromAPI: async ()=>{\n            try {\n                // NOTE: Use React Query hooks for paginated data. This only loads initial batch.\n                const response = await fetch('/api/receipts?limit=30');\n                if (!response.ok) return;\n                const json = await response.json();\n                const apiData = json.data || [];\n                if (apiData.length > 0) {\n                    const normalized = backfillReceiptMetadata(apiData.map((receipt)=>({\n                            ...receipt,\n                            status: normalizeReceiptStatus(receipt.status)\n                        })));\n                    const nextSystemCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(normalized, SYSTEM_ID_PREFIX);\n                    const nextBusinessCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(normalized, BUSINESS_ID_PREFIX);\n                    systemIdCounter = nextSystemCounter;\n                    businessIdCounter = nextBusinessCounter;\n                    set({\n                        data: normalized,\n                        systemIdCounter,\n                        businessIdCounter,\n                        initialized: true\n                    });\n                } else {\n                    set({\n                        initialized: true\n                    });\n                }\n            } catch (error) {\n                console.error('[Receipts API] loadFromAPI error:', error);\n            }\n        }\n    })));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3JlY2VpcHRzL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzBCO0FBVW5DO0FBQ2tFO0FBQzFGLG1IQUFtSDtBQUNJO0FBQ2pFO0FBQ2U7QUFFckUsbUJBQW1CO0FBQ25CLGVBQWVlLFVBQVVDLE1BQXNDLEVBQUVDLElBQVM7SUFDeEUsSUFBSTtRQUNGLE1BQU1DLFdBQVdGLFdBQVcsV0FBVyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUVDLEtBQUtFLFFBQVEsRUFBRTtRQUN6RixNQUFNQyxTQUFTSixXQUFXLFdBQVcsU0FBU0EsV0FBVyxXQUFXLFVBQVU7UUFFOUUsTUFBTUssV0FBVyxNQUFNQyxNQUFNSixVQUFVO1lBQ3JDRTtZQUNBRyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTVIsV0FBVyxXQUFXUyxLQUFLQyxTQUFTLENBQUNULFFBQVFVO1FBQ3JEO1FBRUEsSUFBSSxDQUFDTixTQUFTTyxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGVBQWUsRUFBRWQsT0FBTyxRQUFRLENBQUMsRUFBRSxNQUFNSyxTQUFTVSxJQUFJO1lBQ3JFLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9ELE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFZCxPQUFPLE9BQU8sQ0FBQyxFQUFFYztRQUNqRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGtDQUFrQztBQUNsQyxNQUFNRSxxQkFBcUI7SUFDekIsTUFBTUMsc0JBQXNCbkIsOEVBQXNCQSxRQUFRO0lBQzFELE1BQU1vQixXQUFXckIsOERBQWdCQSxDQUFDc0IsUUFBUSxHQUFHbEIsSUFBSSxDQUFDbUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbEIsUUFBUSxLQUFLYztJQUMzRSxPQUFPO1FBQ0xkLFVBQVVjO1FBQ1ZLLE1BQU1KLFVBQVVLLFlBQVk7UUFDNUJDLFFB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LGVBQWUsSUFBSSxFQUFFO3dCQUFHTDtxQkFBYTtnQkFDckU7WUFDRjtRQUNGO1FBRUFNLGFBQWE7WUFDWCxJQUFJO2dCQUNGLGlGQUFpRjtnQkFDakYsTUFBTW5ILFdBQVcsTUFBTUMsTUFBTTtnQkFDN0IsSUFBSSxDQUFDRCxTQUFTTyxFQUFFLEVBQUU7Z0JBQ2xCLE1BQU02RyxPQUFPLE1BQU1wSCxTQUFTb0gsSUFBSTtnQkFDaEMsTUFBTUMsVUFBVUQsS0FBS3hILElBQUksSUFBSSxFQUFFO2dCQUMvQixJQUFJeUgsUUFBUTdDLE1BQU0sR0FBRyxHQUFHO29CQUN0QixNQUFNVCxhQUFhSix3QkFBd0IwRCxRQUFRdkQsR0FBRyxDQUFDLENBQUN0QixVQUFzQjs0QkFDNUUsR0FBR0EsT0FBTzs0QkFDVkYsUUFBUUQsdUJBQXVCRyxRQUFRRixNQUFNO3dCQUMvQztvQkFDQSxNQUFNZ0Ysb0JBQW9CdEksb0VBQXFCQSxDQUFDK0UsWUFBWTdCO29CQUM1RCxNQUFNcUYsc0JBQXNCeEksc0VBQXVCQSxDQUFDZ0YsWUFBWTVCO29CQUNoRStCLGtCQUFrQm9EO29CQUNsQm5ELG9CQUFvQm9EO29CQUNwQnRDLElBQUk7d0JBQ0ZyRixNQUFNbUU7d0JBQ05HO3dCQUNBQzt3QkFDQWdCLGFBQWE7b0JBQ2Y7Z0JBQ0YsT0FBTztvQkFDTEYsSUFBSTt3QkFBRUUsYUFBYTtvQkFBSztnQkFDMUI7WUFDRixFQUFFLE9BQU8xRSxPQUFPO2dCQUNkRCxRQUFRQyxLQUFLLENBQUMscUNBQXFDQTtZQUNyRDtRQUNGO0lBQ0YsS0FFRiIsInNvdXJjZXMiOlsiRDpcXGhybTJcXGZlYXR1cmVzXFxyZWNlaXB0c1xcc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHN1YnNjcmliZVdpdGhTZWxlY3RvciB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XHJcbmltcG9ydCB0eXBlIHsgUmVjZWlwdCB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgdHlwZSB7IEhpc3RvcnlFbnRyeSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQWN0aXZpdHlIaXN0b3J5JztcclxuaW1wb3J0IHsgXHJcbiAgZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkLCBcclxuICBnZW5lcmF0ZVN5c3RlbUlkLCBcclxuICBnZXRNYXhCdXNpbmVzc0lkQ291bnRlciwgXHJcbiAgZ2V0TWF4U3lzdGVtSWRDb3VudGVyLFxyXG4gIGV4dHJhY3RDb3VudGVyRnJvbUJ1c2luZXNzSWQsXHJcbiAgdHlwZSBFbnRpdHlUeXBlIFxyXG59IGZyb20gJ0AvbGliL2lkLXV0aWxzJztcclxuaW1wb3J0IHsgYXNTeXN0ZW1JZCwgYXNCdXNpbmVzc0lkLCB0eXBlIEJ1c2luZXNzSWQsIHR5cGUgU3lzdGVtSWQgfSBmcm9tICdAL2xpYi9pZC10eXBlcyc7XHJcbi8vIFJFTU9WRUQ6IGltcG9ydCB7IGRhdGEgYXMgaW5pdGlhbERhdGEgfSBmcm9tICcuL2RhdGEnOyAvLyBNb2NrIGRhdGEgbm8gbG9uZ2VyIHVzZWQgLSBkYXRhYmFzZSBpcyBzb3VyY2Ugb2YgdHJ1dGhcclxuaW1wb3J0IHsgcGlja0FjY291bnQsIHBpY2tQYXltZW50TWV0aG9kLCBwaWNrUmVjZWlwdFR5cGUsIHBpY2tUYXJnZXRHcm91cCB9IGZyb20gJ0AvZmVhdHVyZXMvZmluYW5jZS9kb2N1bWVudC1sb29rdXBzJztcclxuaW1wb3J0IHsgdXNlRW1wbG95ZWVTdG9yZSB9IGZyb20gJy4uL2VtcGxveWVlcy9zdG9yZSc7XHJcbmltcG9ydCB7IGdldEN1cnJlbnRVc2VyU3lzdGVtSWQgfSBmcm9tICcuLi8uLi9jb250ZXh0cy9hdXRoLWNvbnRleHQnO1xyXG5cclxuLy8gQVBJIHN5bmMgaGVscGVyc1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jVG9BUEkoYWN0aW9uOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIGRhdGE6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnL2FwaS9yZWNlaXB0cycgOiBgL2FwaS9yZWNlaXB0cy8ke2RhdGEuc3lzdGVtSWR9YDtcclxuICAgIGNvbnN0IG1ldGhvZCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnUE9TVCcgOiBhY3Rpb24gPT09ICd1cGRhdGUnID8gJ1BBVENIJyA6ICdERUxFVEUnO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XHJcbiAgICAgIG1ldGhvZCxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IGFjdGlvbiAhPT0gJ2RlbGV0ZScgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtSZWNlaXB0cyBBUEldICR7YWN0aW9ufSBmYWlsZWQ6YCwgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFtSZWNlaXB0cyBBUEldICR7YWN0aW9ufSBlcnJvcjpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gZ2V0IGN1cnJlbnQgdXNlciBpbmZvXHJcbmNvbnN0IGdldEN1cnJlbnRVc2VySW5mbyA9ICgpID0+IHtcclxuICBjb25zdCBjdXJyZW50VXNlclN5c3RlbUlkID0gZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZD8uKCkgfHwgJ1NZU1RFTSc7XHJcbiAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKGUgPT4gZS5zeXN0ZW1JZCA9PT0gY3VycmVudFVzZXJTeXN0ZW1JZCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5c3RlbUlkOiBjdXJyZW50VXNlclN5c3RlbUlkLFxyXG4gICAgbmFtZTogZW1wbG95ZWU/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgYXZhdGFyOiBlbXBsb3llZT8uYXZhdGFyVXJsLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGhpc3RvcnkgZW50cnlcclxuY29uc3QgY3JlYXRlSGlzdG9yeUVudHJ5ID0gKFxyXG4gIGFjdGlvbjogSGlzdG9yeUVudHJ5WydhY3Rpb24nXSxcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gIG1ldGFkYXRhPzogSGlzdG9yeUVudHJ5WydtZXRhZGF0YSddXHJcbik6IEhpc3RvcnlFbnRyeSA9PiAoe1xyXG4gIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gIGFjdGlvbixcclxuICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgdXNlcjogZ2V0Q3VycmVudFVzZXJJbmZvKCksXHJcbiAgZGVzY3JpcHRpb24sXHJcbiAgbWV0YWRhdGEsXHJcbn0pO1xyXG5cclxuY29uc3QgU1lTVEVNX0FVVEhPUiA9IGFzU3lzdGVtSWQoJ1NZU1RFTScpO1xyXG5jb25zdCBnZXRDdXJyZW50UmVjZWlwdEF1dGhvciA9ICgpOiBTeXN0ZW1JZCA9PiB7XHJcbiAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZD8uKCk7XHJcbiAgcmV0dXJuIHVzZXJJZCA/IGFzU3lzdGVtSWQodXNlcklkKSA6IFNZU1RFTV9BVVRIT1I7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZWNlaXB0SW5wdXQgPSBPbWl0PFJlY2VpcHQsICdzeXN0ZW1JZCcgfCAnaWQnPiAmIHsgaWQ/OiBCdXNpbmVzc0lkIH07XHJcblxyXG5pbnRlcmZhY2UgUmVjZWlwdFN0b3JlIHtcclxuICBkYXRhOiBSZWNlaXB0W107XHJcbiAgYnVzaW5lc3NJZENvdW50ZXI6IG51bWJlcjtcclxuICBzeXN0ZW1JZENvdW50ZXI6IG51bWJlcjtcclxuICBpbml0aWFsaXplZDogYm9vbGVhbjtcclxuICBhZGQ6IChpdGVtOiBSZWNlaXB0SW5wdXQpID0+IFJlY2VpcHQ7XHJcbiAgYWRkTXVsdGlwbGU6IChpdGVtczogUmVjZWlwdElucHV0W10pID0+IHZvaWQ7XHJcbiAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBSZWNlaXB0KSA9PiB2b2lkO1xyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gdm9pZDtcclxuICBmaW5kQnlJZDogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gUmVjZWlwdCB8IHVuZGVmaW5lZDtcclxuICBnZXRBY3RpdmU6ICgpID0+IFJlY2VpcHRbXTtcclxuICBjYW5jZWw6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlYXNvbj86IHN0cmluZykgPT4gdm9pZDtcclxuICBsb2FkRnJvbUFQSTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuY29uc3QgUkVDRUlQVF9FTlRJVFk6IEVudGl0eVR5cGUgPSAncmVjZWlwdHMnO1xyXG5jb25zdCBTWVNURU1fSURfUFJFRklYID0gJ1JFQ0VJUFQnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9QUkVGSVggPSAnUFQnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9ESUdJVFMgPSA2O1xyXG5cclxuY29uc3Qgbm9ybWFsaXplUmVjZWlwdFN0YXR1cyA9IChzdGF0dXM/OiBSZWNlaXB0WydzdGF0dXMnXSk6IFJlY2VpcHRbJ3N0YXR1cyddID0+XHJcbiAgc3RhdHVzID09PSAnY2FuY2VsbGVkJyA/ICdjYW5jZWxsZWQnIDogJ2NvbXBsZXRlZCc7XHJcblxyXG5jb25zdCBlbnN1cmVSZWNlaXB0TWV0YWRhdGEgPSAocmVjZWlwdDogUmVjZWlwdCk6IFJlY2VpcHQgPT4ge1xyXG4gIGxldCBtdXRhdGVkID0gZmFsc2U7XHJcbiAgY29uc3QgdXBkYXRlczogUGFydGlhbDxSZWNlaXB0PiA9IHt9O1xyXG5cclxuICBjb25zdCB0YXJnZXRHcm91cCA9IHBpY2tUYXJnZXRHcm91cCh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXllclR5cGVTeXN0ZW1JZCxcclxuICAgIG5hbWU6IHJlY2VpcHQucGF5ZXJUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAodGFyZ2V0R3JvdXApIHtcclxuICAgIGlmIChyZWNlaXB0LnBheWVyVHlwZVN5c3RlbUlkICE9PSB0YXJnZXRHcm91cC5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnBheWVyVHlwZVN5c3RlbUlkID0gdGFyZ2V0R3JvdXAuc3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY2VpcHQucGF5ZXJUeXBlTmFtZSAhPT0gdGFyZ2V0R3JvdXAubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnBheWVyVHlwZU5hbWUgPSB0YXJnZXRHcm91cC5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHBheW1lbnRNZXRob2QgPSBwaWNrUGF5bWVudE1ldGhvZCh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXltZW50TWV0aG9kU3lzdGVtSWQsXHJcbiAgICBuYW1lOiByZWNlaXB0LnBheW1lbnRNZXRob2ROYW1lLFxyXG4gIH0pO1xyXG4gIGlmIChwYXltZW50TWV0aG9kKSB7XHJcbiAgICBpZiAocmVjZWlwdC5wYXltZW50TWV0aG9kU3lzdGVtSWQgIT09IHBheW1lbnRNZXRob2Quc3lzdGVtSWQpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kU3lzdGVtSWQgPSBwYXltZW50TWV0aG9kLnN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChyZWNlaXB0LnBheW1lbnRNZXRob2ROYW1lICE9PSBwYXltZW50TWV0aG9kLm5hbWUpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kTmFtZSA9IHBheW1lbnRNZXRob2QubmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhY2NvdW50ID0gcGlja0FjY291bnQoe1xyXG4gICAgYWNjb3VudFN5c3RlbUlkOiByZWNlaXB0LmFjY291bnRTeXN0ZW1JZCxcclxuICAgIGJyYW5jaFN5c3RlbUlkOiByZWNlaXB0LmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgcGF5bWVudE1ldGhvZE5hbWU6IHBheW1lbnRNZXRob2Q/Lm5hbWUgPz8gcmVjZWlwdC5wYXltZW50TWV0aG9kTmFtZSxcclxuICB9KTtcclxuICBpZiAoYWNjb3VudCAmJiByZWNlaXB0LmFjY291bnRTeXN0ZW1JZCAhPT0gYWNjb3VudC5zeXN0ZW1JZCkge1xyXG4gICAgdXBkYXRlcy5hY2NvdW50U3lzdGVtSWQgPSBhY2NvdW50LnN5c3RlbUlkO1xyXG4gICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZWNlaXB0VHlwZSA9IHBpY2tSZWNlaXB0VHlwZSh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCxcclxuICAgIG5hbWU6IHJlY2VpcHQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAocmVjZWlwdFR5cGUpIHtcclxuICAgIGlmIChyZWNlaXB0LnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkICE9PSByZWNlaXB0VHlwZS5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkID0gcmVjZWlwdFR5cGUuc3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY2VpcHQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSAhPT0gcmVjZWlwdFR5cGUubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZU5hbWUgPSByZWNlaXB0VHlwZS5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghcmVjZWlwdC5jdXN0b21lck5hbWUgJiYgcmVjZWlwdC5wYXllck5hbWUpIHtcclxuICAgIHVwZGF0ZXMuY3VzdG9tZXJOYW1lID0gcmVjZWlwdC5wYXllck5hbWU7XHJcbiAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICghcmVjZWlwdC5jdXN0b21lclN5c3RlbUlkICYmIHJlY2VpcHQucGF5ZXJTeXN0ZW1JZCkge1xyXG4gICAgdXBkYXRlcy5jdXN0b21lclN5c3RlbUlkID0gcmVjZWlwdC5wYXllclN5c3RlbUlkO1xyXG4gICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbXV0YXRlZCA/IHsgLi4ucmVjZWlwdCwgLi4udXBkYXRlcyB9IDogcmVjZWlwdDtcclxufTtcclxuXHJcbmNvbnN0IGJhY2tmaWxsUmVjZWlwdE1ldGFkYXRhID0gKHJlY2VpcHRzOiBSZWNlaXB0W10pOiBSZWNlaXB0W10gPT4ge1xyXG4gIGxldCBtdXRhdGVkID0gZmFsc2U7XHJcbiAgY29uc3QgdXBkYXRlZCA9IHJlY2VpcHRzLm1hcChyZWNlaXB0ID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBlbnN1cmVSZWNlaXB0TWV0YWRhdGEocmVjZWlwdCk7XHJcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gcmVjZWlwdCkge1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gIH0pO1xyXG4gIHJldHVybiBtdXRhdGVkID8gdXBkYXRlZCA6IHJlY2VpcHRzO1xyXG59O1xyXG5cclxuY29uc3QgaW5pdGlhbFJlY2VpcHRzID0gYmFja2ZpbGxSZWNlaXB0TWV0YWRhdGEoaW5pdGlhbERhdGEubWFwKHJlY2VpcHQgPT4gKHtcclxuICAuLi5yZWNlaXB0LFxyXG4gIHN0YXR1czogbm9ybWFsaXplUmVjZWlwdFN0YXR1cyhyZWNlaXB0LnN0YXR1cyksXHJcbn0pKSk7XHJcblxyXG5sZXQgc3lzdGVtSWRDb3VudGVyID0gZ2V0TWF4U3lzdGVtSWRDb3VudGVyKGluaXRpYWxSZWNlaXB0cywgU1lTVEVNX0lEX1BSRUZJWCk7XHJcbmxldCBidXNpbmVzc0lkQ291bnRlciA9IGdldE1heEJ1c2luZXNzSWRDb3VudGVyKGluaXRpYWxSZWNlaXB0cywgQlVTSU5FU1NfSURfUFJFRklYKTtcclxuXHJcbmNvbnN0IGdldE5leHRTeXN0ZW1JZCA9ICgpOiBTeXN0ZW1JZCA9PiB7XHJcbiAgc3lzdGVtSWRDb3VudGVyICs9IDE7XHJcbiAgcmV0dXJuIGFzU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZChSRUNFSVBUX0VOVElUWSwgc3lzdGVtSWRDb3VudGVyKSk7XHJcbn07XHJcblxyXG5jb25zdCBlbnN1cmVSZWNlaXB0QnVzaW5lc3NJZCA9IChyZWNlaXB0czogUmVjZWlwdFtdLCBwcm92aWRlZD86IEJ1c2luZXNzSWQgfCBzdHJpbmcpOiBCdXNpbmVzc0lkID0+IHtcclxuICBpZiAocHJvdmlkZWQgJiYgYCR7cHJvdmlkZWR9YC50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGAke3Byb3ZpZGVkfWAudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCBwYXJzZWRDb3VudGVyID0gZXh0cmFjdENvdW50ZXJGcm9tQnVzaW5lc3NJZChub3JtYWxpemVkLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG4gICAgaWYgKHBhcnNlZENvdW50ZXIgPiBidXNpbmVzc0lkQ291bnRlcikge1xyXG4gICAgICBidXNpbmVzc0lkQ291bnRlciA9IHBhcnNlZENvdW50ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXNCdXNpbmVzc0lkKG5vcm1hbGl6ZWQpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSByZWNlaXB0cy5tYXAocmVjZWlwdCA9PiByZWNlaXB0LmlkIGFzIHN0cmluZykuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIGNvbnN0IHsgbmV4dElkLCB1cGRhdGVkQ291bnRlciB9ID0gZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkKFxyXG4gICAgQlVTSU5FU1NfSURfUFJFRklYLFxyXG4gICAgZXhpc3RpbmdJZHMsXHJcbiAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgIEJVU0lORVNTX0lEX0RJR0lUU1xyXG4gICk7XHJcbiAgYnVzaW5lc3NJZENvdW50ZXIgPSB1cGRhdGVkQ291bnRlcjtcclxuICByZXR1cm4gYXNCdXNpbmVzc0lkKG5leHRJZCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlUmVjZWlwdFN0b3JlID0gY3JlYXRlPFJlY2VpcHRTdG9yZT4oKShcclxuICBzdWJzY3JpYmVXaXRoU2VsZWN0b3IoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIGRhdGE6IGluaXRpYWxSZWNlaXB0cyxcclxuICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgIHN5c3RlbUlkQ291bnRlcixcclxuICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICBcclxuICAgICAgYWRkOiAoaXRlbTogUmVjZWlwdElucHV0KTogUmVjZWlwdCA9PiB7XHJcbiAgICAgICAgbGV0IGNyZWF0ZWRSZWNlaXB0OiBSZWNlaXB0IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgc2V0KHN0YXRlID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN5c3RlbUlkID0gZ2V0TmV4dFN5c3RlbUlkKCk7XHJcbiAgICAgICAgICBjb25zdCBpZCA9IGVuc3VyZVJlY2VpcHRCdXNpbmVzc0lkKHN0YXRlLmRhdGEsIGl0ZW0uaWQpO1xyXG4gICAgICAgICAgY29uc3QgY3JlYXRlZEJ5ID0gaXRlbS5jcmVhdGVkQnkgPz8gZ2V0Q3VycmVudFJlY2VpcHRBdXRob3IoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgbmV3UmVjZWlwdDogUmVjZWlwdCA9IHsgXHJcbiAgICAgICAgICAgIC4uLml0ZW0sIFxyXG4gICAgICAgICAgICBzeXN0ZW1JZCwgXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnksXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogaXRlbS5jcmVhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVJlY2VpcHRTdGF0dXMoaXRlbS5zdGF0dXMpLFxyXG4gICAgICAgICAgICBvcmRlckFsbG9jYXRpb25zOiBpdGVtLm9yZGVyQWxsb2NhdGlvbnMgPz8gW10sXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWNlaXB0ID0gZW5zdXJlUmVjZWlwdE1ldGFkYXRhKG5ld1JlY2VpcHQpO1xyXG4gICAgICAgICAgY3JlYXRlZFJlY2VpcHQgPSBub3JtYWxpemVkUmVjZWlwdDtcclxuXHJcbiAgICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgZGF0YTogWy4uLnN0YXRlLmRhdGEsIG5vcm1hbGl6ZWRSZWNlaXB0XSxcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIGlmIChjcmVhdGVkUmVjZWlwdCkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKCdjcmVhdGUnLCBjcmVhdGVkUmVjZWlwdCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVkUmVjZWlwdCE7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBhZGRNdWx0aXBsZTogKGl0ZW1zOiBSZWNlaXB0SW5wdXRbXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQ6IFJlY2VpcHRbXSA9IFtdO1xyXG4gICAgICAgIHNldChzdGF0ZSA9PiB7XHJcbiAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gWy4uLnN0YXRlLmRhdGEsIC4uLmNyZWF0ZWRdO1xyXG4gICAgICAgICAgICBjb25zdCBzeXN0ZW1JZCA9IGdldE5leHRTeXN0ZW1JZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGVuc3VyZVJlY2VpcHRCdXNpbmVzc0lkKGNvbnRleHQsIGl0ZW0uaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQnkgPSBpdGVtLmNyZWF0ZWRCeSA/PyBnZXRDdXJyZW50UmVjZWlwdEF1dGhvcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbmV3UmVjZWlwdDogUmVjZWlwdCA9IHsgXHJcbiAgICAgICAgICAgICAgLi4uaXRlbSwgXHJcbiAgICAgICAgICAgICAgc3lzdGVtSWQsIFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRCeSxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGl0ZW0uY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVJlY2VpcHRTdGF0dXMoaXRlbS5zdGF0dXMpLFxyXG4gICAgICAgICAgICAgIG9yZGVyQWxsb2NhdGlvbnM6IGl0ZW0ub3JkZXJBbGxvY2F0aW9ucyA/PyBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3JlYXRlZC5wdXNoKGVuc3VyZVJlY2VpcHRNZXRhZGF0YShuZXdSZWNlaXB0KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgIGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCAuLi5jcmVhdGVkXSxcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTeW5jIGFsbCB0byBBUElcclxuICAgICAgICBjcmVhdGVkLmZvckVhY2gocmVjZWlwdCA9PiB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoJ2NyZWF0ZScsIHJlY2VpcHQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBSZWNlaXB0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4uaXRlbSwgc3RhdHVzOiBub3JtYWxpemVSZWNlaXB0U3RhdHVzKGl0ZW0uc3RhdHVzKSwgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcclxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKHIgPT4gci5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQgPyB1cGRhdGVkIDogciksXHJcbiAgICAgICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIHN5bmNUb0FQSSgndXBkYXRlJywgdXBkYXRlZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICByZW1vdmU6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHtcclxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEuZmlsdGVyKHIgPT4gci5zeXN0ZW1JZCAhPT0gc3lzdGVtSWQpLFxyXG4gICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICBzeXN0ZW1JZENvdW50ZXJcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLy8gU3luYyB0byBBUElcclxuICAgICAgICBzeW5jVG9BUEkoJ2RlbGV0ZScsIHsgc3lzdGVtSWQgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBmaW5kQnlJZDogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBnZXQoKS5kYXRhLmZpbmQociA9PiByLnN5c3RlbUlkID09PSBzeXN0ZW1JZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBnZXRBY3RpdmU6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YS5maWx0ZXIociA9PiByLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgY2FuY2VsOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCByZWFzb24/OiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCByZWNlaXB0ID0gZ2V0KCkuZmluZEJ5SWQoc3lzdGVtSWQpO1xyXG4gICAgICAgIGlmIChyZWNlaXB0ICYmIHJlY2VpcHQuc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgY29uc3QgaGlzdG9yeUVudHJ5ID0gY3JlYXRlSGlzdG9yeUVudHJ5KFxyXG4gICAgICAgICAgICAnY2FuY2VsbGVkJyxcclxuICAgICAgICAgICAgYMSQw6MgaOG7p3kgcGhp4bq/dSB0aHUke3JlYXNvbiA/IGA6ICR7cmVhc29ufWAgOiAnJ31gLFxyXG4gICAgICAgICAgICB7IG9sZFZhbHVlOiAnSG/DoG4gdGjDoG5oJywgbmV3VmFsdWU6ICfEkMOjIGjhu6d5Jywgbm90ZTogcmVhc29uIH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGdldCgpLnVwZGF0ZShzeXN0ZW1JZCwge1xyXG4gICAgICAgICAgICAuLi5yZWNlaXB0LFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgICAgICBjYW5jZWxsZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBhY3Rpdml0eUhpc3Rvcnk6IFsuLi4ocmVjZWlwdC5hY3Rpdml0eUhpc3RvcnkgfHwgW10pLCBoaXN0b3J5RW50cnldLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgbG9hZEZyb21BUEk6IGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gTk9URTogVXNlIFJlYWN0IFF1ZXJ5IGhvb2tzIGZvciBwYWdpbmF0ZWQgZGF0YS4gVGhpcyBvbmx5IGxvYWRzIGluaXRpYWwgYmF0Y2guXHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3JlY2VpcHRzP2xpbWl0PTMwJyk7XHJcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm47XHJcbiAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgY29uc3QgYXBpRGF0YSA9IGpzb24uZGF0YSB8fCBbXTtcclxuICAgICAgICAgIGlmIChhcGlEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGJhY2tmaWxsUmVjZWlwdE1ldGFkYXRhKGFwaURhdGEubWFwKChyZWNlaXB0OiBSZWNlaXB0KSA9PiAoe1xyXG4gICAgICAgICAgICAgIC4uLnJlY2VpcHQsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBub3JtYWxpemVSZWNlaXB0U3RhdHVzKHJlY2VpcHQuc3RhdHVzKSxcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFN5c3RlbUNvdW50ZXIgPSBnZXRNYXhTeXN0ZW1JZENvdW50ZXIobm9ybWFsaXplZCwgU1lTVEVNX0lEX1BSRUZJWCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRCdXNpbmVzc0NvdW50ZXIgPSBnZXRNYXhCdXNpbmVzc0lkQ291bnRlcihub3JtYWxpemVkLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG4gICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIgPSBuZXh0U3lzdGVtQ291bnRlcjtcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIgPSBuZXh0QnVzaW5lc3NDb3VudGVyO1xyXG4gICAgICAgICAgICBzZXQoeyBcclxuICAgICAgICAgICAgICBkYXRhOiBub3JtYWxpemVkLCBcclxuICAgICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIsIFxyXG4gICAgICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgICAgIGluaXRpYWxpemVkOiB0cnVlIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldCh7IGluaXRpYWxpemVkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUmVjZWlwdHMgQVBJXSBsb2FkRnJvbUFQSSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSlcclxuICApXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3IiLCJmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQiLCJnZW5lcmF0ZVN5c3RlbUlkIiwiZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIiLCJnZXRNYXhTeXN0ZW1JZENvdW50ZXIiLCJleHRyYWN0Q291bnRlckZyb21CdXNpbmVzc0lkIiwiYXNTeXN0ZW1JZCIsImFzQnVzaW5lc3NJZCIsInBpY2tBY2NvdW50IiwicGlja1BheW1lbnRNZXRob2QiLCJwaWNrUmVjZWlwdFR5cGUiLCJwaWNrVGFyZ2V0R3JvdXAiLCJ1c2VFbXBsb3llZVN0b3JlIiwiZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCIsInN5bmNUb0FQSSIsImFjdGlvbiIsImRhdGEiLCJlbmRwb2ludCIsInN5c3RlbUlkIiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsIm9rIiwiY29uc29sZSIsImVycm9yIiwidGV4dCIsImdldEN1cnJlbnRVc2VySW5mbyIsImN1cnJlbnRVc2VyU3lzdGVtSWQiLCJlbXBsb3llZSIsImdldFN0YXRlIiwiZmluZCIsImUiLCJuYW1lIiwiZnVsbE5hbWUiLCJhdmF0YXIiLCJhdmF0YXJVcmwiLCJjcmVhdGVIaXN0b3J5RW50cnkiLCJkZXNjcmlwdGlvbiIsIm1ldGFkYXRhIiwiaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwidGltZXN0YW1wIiwiRGF0ZSIsInVzZXIiLCJTWVNURU1fQVVUSE9SIiwiZ2V0Q3VycmVudFJlY2VpcHRBdXRob3IiLCJ1c2VySWQiLCJSRUNFSVBUX0VOVElUWSIsIlNZU1RFTV9JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9ESUdJVFMiLCJub3JtYWxpemVSZWNlaXB0U3RhdHVzIiwic3RhdHVzIiwiZW5zdXJlUmVjZWlwdE1ldGFkYXRhIiwicmVjZWlwdCIsIm11dGF0ZWQiLCJ1cGRhdGVzIiwidGFyZ2V0R3JvdXAiLCJwYXllclR5cGVTeXN0ZW1JZCIsInBheWVyVHlwZU5hbWUiLCJwYXltZW50TWV0aG9kIiwicGF5bWVudE1ldGhvZFN5c3RlbUlkIiwicGF5bWVudE1ldGhvZE5hbWUiLCJhY2NvdW50IiwiYWNjb3VudFN5c3RlbUlkIiwiYnJhbmNoU3lzdGVtSWQiLCJyZWNlaXB0VHlwZSIsInBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkIiwicGF5bWVudFJlY2VpcHRUeXBlTmFtZSIsImN1c3RvbWVyTmFtZSIsInBheWVyTmFtZSIsImN1c3RvbWVyU3lzdGVtSWQiLCJwYXllclN5c3RlbUlkIiwiYmFja2ZpbGxSZWNlaXB0TWV0YWRhdGEiLCJyZWNlaXB0cyIsInVwZGF0ZWQiLCJtYXAiLCJub3JtYWxpemVkIiwiaW5pdGlhbFJlY2VpcHRzIiwiaW5pdGlhbERhdGEiLCJzeXN0ZW1JZENvdW50ZXIiLCJidXNpbmVzc0lkQ291bnRlciIsImdldE5leHRTeXN0ZW1JZCIsImVuc3VyZVJlY2VpcHRCdXNpbmVzc0lkIiwicHJvdmlkZWQiLCJ0cmltIiwibGVuZ3RoIiwidG9VcHBlckNhc2UiLCJwYXJzZWRDb3VudGVyIiwiZXhpc3RpbmdJZHMiLCJmaWx0ZXIiLCJCb29sZWFuIiwibmV4dElkIiwidXBkYXRlZENvdW50ZXIiLCJ1c2VSZWNlaXB0U3RvcmUiLCJzZXQiLCJnZXQiLCJpbml0aWFsaXplZCIsImFkZCIsIml0ZW0iLCJjcmVhdGVkUmVjZWlwdCIsInN0YXRlIiwiY3JlYXRlZEJ5IiwibmV3UmVjZWlwdCIsImNyZWF0ZWRBdCIsInRvSVNPU3RyaW5nIiwib3JkZXJBbGxvY2F0aW9ucyIsIm5vcm1hbGl6ZWRSZWNlaXB0IiwiY2F0Y2giLCJhZGRNdWx0aXBsZSIsIml0ZW1zIiwiY3JlYXRlZCIsImZvckVhY2giLCJjb250ZXh0IiwicHVzaCIsInVwZGF0ZSIsInVwZGF0ZWRBdCIsInIiLCJyZW1vdmUiLCJmaW5kQnlJZCIsImdldEFjdGl2ZSIsImNhbmNlbCIsInJlYXNvbiIsImhpc3RvcnlFbnRyeSIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJub3RlIiwiY2FuY2VsbGVkQXQiLCJhY3Rpdml0eUhpc3RvcnkiLCJsb2FkRnJvbUFQSSIsImpzb24iLCJhcGlEYXRhIiwibmV4dFN5c3RlbUNvdW50ZXIiLCJuZXh0QnVzaW5lc3NDb3VudGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/receipts/store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./features/sales-returns/store.ts":
/*!*****************************************!*\
  !*** ./features/sales-returns/store.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSalesReturnStore: () => (/* binding */ useSalesReturnStore)\n/* harmony export */ });\n/* harmony import */ var _lib_date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/date-utils */ \"(app-pages-browser)/./lib/date-utils.ts\");\n/* harmony import */ var _lib_store_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/store-factory */ \"(app-pages-browser)/./lib/store-factory.ts\");\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _orders_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../orders/store */ \"(app-pages-browser)/./features/orders/store.ts\");\n/* harmony import */ var _products_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../products/store */ \"(app-pages-browser)/./features/products/store.ts\");\n/* harmony import */ var _stock_history_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../stock-history/store */ \"(app-pages-browser)/./features/stock-history/store.ts\");\n/* harmony import */ var _customers_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../customers/store */ \"(app-pages-browser)/./features/customers/store.ts\");\n/* harmony import */ var _finance_document_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../finance/document-helpers */ \"(app-pages-browser)/./features/finance/document-helpers.ts\");\n/* harmony import */ var _settings_shipping_store__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../settings/shipping/store */ \"(app-pages-browser)/./features/settings/shipping/store.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _products_combo_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../products/combo-utils */ \"(app-pages-browser)/./features/products/combo-utils.ts\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n\n\n\n// Other stores\n\n\n\n\n\n\n\n\n\n/**\r\n * ✅ Helper: Expand combo return items to child products\r\n * When a combo is returned, we need to add stock back to child products\r\n */ const getReturnStockItems = (returnItems)=>{\n    const { findById } = _products_store__WEBPACK_IMPORTED_MODULE_4__.useProductStore.getState();\n    const expandedItems = [];\n    returnItems.forEach((item)=>{\n        const product = findById(item.productSystemId);\n        if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_10__.isComboProduct)(product) && product.comboItems) {\n            // Combo → expand to child products\n            product.comboItems.forEach((comboItem)=>{\n                const childProduct = findById(comboItem.productSystemId);\n                expandedItems.push({\n                    productSystemId: comboItem.productSystemId,\n                    productName: childProduct?.name || 'SP không xác định',\n                    quantity: comboItem.quantity * item.returnQuantity\n                });\n            });\n        } else {\n            // Regular product\n            expandedItems.push({\n                productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.productSystemId),\n                productName: item.productName,\n                quantity: item.returnQuantity\n            });\n        }\n    });\n    return expandedItems;\n};\nconst baseStore = (0,_lib_store_factory__WEBPACK_IMPORTED_MODULE_1__.createCrudStore)([], 'sales-returns', {\n    apiEndpoint: '/api/sales-returns'\n});\nconst originalAdd = baseStore.getState().add;\nconst augmentedMethods = {\n    addWithSideEffects: (item)=>{\n        const orderSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.orderSystemId);\n        const orderBusinessId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asBusinessId)(item.orderId);\n        const customerSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.customerSystemId);\n        const branchSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.branchSystemId);\n        const creatorSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.creatorSystemId ?? item.creatorId ?? 'SYSTEM');\n        const exchangeOrderSystemId = item.exchangeOrderSystemId ? (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.exchangeOrderSystemId) : undefined;\n        const accountSystemId = item.accountSystemId ? (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.accountSystemId) : undefined;\n        const paymentVoucherSystemId = item.paymentVoucherSystemId ? (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(item.paymentVoucherSystemId) : undefined;\n        const paymentVoucherSystemIds = item.paymentVoucherSystemIds?.map(_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId);\n        const receiptVoucherSystemIds = item.receiptVoucherSystemIds?.map(_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId);\n        const formattedItems = item.items.map((lineItem)=>({\n                ...lineItem,\n                productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(lineItem.productSystemId),\n                productId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asBusinessId)(lineItem.productId)\n            }));\n        const formattedPayments = item.payments?.map((payment)=>({\n                ...payment,\n                accountSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(payment.accountSystemId)\n            }));\n        const formattedRefunds = item.refunds?.map((refund)=>({\n                ...refund,\n                accountSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(refund.accountSystemId)\n            }));\n        const newItemData = {\n            id: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asBusinessId)(''),\n            orderSystemId,\n            orderId: orderBusinessId,\n            customerSystemId,\n            customerName: item.customerName,\n            branchSystemId,\n            branchName: item.branchName,\n            returnDate: item.returnDate,\n            reason: item.reason,\n            note: item.note,\n            notes: item.notes,\n            reference: item.reference,\n            items: formattedItems,\n            totalReturnValue: item.totalReturnValue,\n            isReceived: item.isReceived,\n            exchangeItems: item.exchangeItems ?? [],\n            exchangeOrderSystemId,\n            subtotalNew: item.subtotalNew,\n            shippingFeeNew: item.shippingFeeNew,\n            discountNew: item.discountNew,\n            discountNewType: item.discountNewType,\n            grandTotalNew: item.grandTotalNew,\n            deliveryMethod: item.deliveryMethod,\n            shippingPartnerId: item.shippingPartnerId,\n            shippingServiceId: item.shippingServiceId,\n            shippingAddress: item.shippingAddress,\n            packageInfo: item.packageInfo,\n            configuration: item.configuration,\n            finalAmount: item.finalAmount,\n            refundMethod: item.refundMethod,\n            refundAmount: item.refundAmount,\n            accountSystemId,\n            refunds: formattedRefunds,\n            payments: formattedPayments,\n            paymentVoucherSystemId,\n            paymentVoucherSystemIds,\n            receiptVoucherSystemIds,\n            creatorSystemId,\n            creatorName: item.creatorName\n        };\n        // --- Side Effects ---\n        const { update: updateOrder, findById: findOrderById, add: addOrder } = _orders_store__WEBPACK_IMPORTED_MODULE_3__.useOrderStore.getState();\n        const { updateInventory } = _products_store__WEBPACK_IMPORTED_MODULE_4__.useProductStore.getState();\n        const { addEntry: addStockHistory } = _stock_history_store__WEBPACK_IMPORTED_MODULE_5__.useStockHistoryStore.getState();\n        const { updateDebt, incrementReturnStats } = _customers_store__WEBPACK_IMPORTED_MODULE_6__.useCustomerStore.getState();\n        const order = findOrderById(newItemData.orderSystemId);\n        if (!order) return {\n            newReturn: null,\n            newOrderSystemId: null\n        };\n        // ✅ IMPORTANT: Create the return FIRST to get IDs for exchange order\n        const newReturn = originalAdd(newItemData);\n        if (!newReturn) return {\n            newReturn: null,\n            newOrderSystemId: null\n        };\n        // ✅ Update customer return stats\n        const totalReturnQty = newItemData.items.reduce((sum, item)=>sum + item.returnQuantity, 0);\n        if (totalReturnQty > 0) {\n            incrementReturnStats(newItemData.customerSystemId, totalReturnQty);\n        }\n        let newOrderSystemId;\n        // Create a new sales order for the exchange items\n        if (newItemData.exchangeItems && newItemData.exchangeItems.length > 0) {\n            console.log('🔄 [Sales Return] Creating exchange order...', {\n                exchangeItems: newItemData.exchangeItems,\n                finalAmount: newItemData.finalAmount,\n                payments: newItemData.payments\n            });\n            // ✅ Calculate payments for exchange order based on sales return logic\n            const exchangeOrderPayments = newItemData.finalAmount > 0 && newItemData.payments ? newItemData.payments.map((p)=>({\n                    method: p.method,\n                    accountSystemId: p.accountSystemId,\n                    amount: p.amount\n                })) : [];\n            // If company refunded customer (finalAmount < 0)\n            // The exchange order will have COD = grandTotal (shipper collects on delivery)\n            // No payments array needed - will be handled by COD in shipping\n            // ✅ Determine status and packagings based on delivery method\n            let finalMainStatus = 'Đặt hàng';\n            let finalDeliveryStatus = 'Chờ đóng gói';\n            const packagings = [];\n            const now = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.formatDateCustom)((0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)(), 'yyyy-MM-dd HH:mm');\n            // ✅ Helper to get next packaging systemId\n            const PACKAGING_SYSTEM_ID_PREFIX = 'PACKAGE';\n            const allOrders = _orders_store__WEBPACK_IMPORTED_MODULE_3__.useOrderStore.getState().data;\n            const allPackagings = allOrders.flatMap((o)=>o.packagings || []);\n            const maxPackagingCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_11__.getMaxSystemIdCounter)(allPackagings, PACKAGING_SYSTEM_ID_PREFIX);\n            let packagingCounter = maxPackagingCounter;\n            const getNextPackagingSystemId = ()=>{\n                packagingCounter++;\n                return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_11__.generateSystemId)('packaging', packagingCounter));\n            };\n            // Check if using shipping partner or pickup\n            const isPickup = newItemData.deliveryMethod === 'pickup';\n            const isShippingPartner = newItemData.shippingPartnerId && newItemData.shippingServiceId;\n            if (isPickup) {\n                // Nhận tại cửa hàng - Tạo packaging request ngay\n                finalMainStatus = 'Đang giao dịch';\n                finalDeliveryStatus = 'Chờ đóng gói';\n                packagings.push({\n                    systemId: getNextPackagingSystemId(),\n                    id: '',\n                    requestDate: now,\n                    requestingEmployeeId: creatorSystemId,\n                    requestingEmployeeName: newItemData.creatorName,\n                    status: 'Chờ đóng gói',\n                    printStatus: 'Chưa in',\n                    deliveryStatus: 'Chờ đóng gói'\n                });\n            } else if (isShippingPartner) {\n                // Đẩy qua hãng vận chuyển - Tạo packaging đã đóng gói với tracking\n                finalMainStatus = 'Đang giao dịch';\n                finalDeliveryStatus = 'Chờ lấy hàng';\n                // Get partner info\n                const { data: partners } = _settings_shipping_store__WEBPACK_IMPORTED_MODULE_8__.useShippingPartnerStore.getState();\n                const partner = partners.find((p)=>p.systemId === newItemData.shippingPartnerId);\n                const service = partner?.services.find((s)=>s.id === newItemData.shippingServiceId);\n                packagings.push({\n                    systemId: getNextPackagingSystemId(),\n                    id: '',\n                    requestDate: now,\n                    confirmDate: now,\n                    requestingEmployeeId: creatorSystemId,\n                    requestingEmployeeName: newItemData.creatorName,\n                    confirmingEmployeeId: creatorSystemId,\n                    confirmingEmployeeName: newItemData.creatorName,\n                    status: 'Đã đóng gói',\n                    deliveryStatus: 'Chờ lấy hàng',\n                    printStatus: 'Chưa in',\n                    deliveryMethod: 'Dịch vụ giao hàng',\n                    carrier: partner?.name,\n                    service: service?.name,\n                    trackingCode: newItemData.packageInfo?.trackingCode || `VC${Date.now()}`,\n                    shippingFeeToPartner: newItemData.shippingFeeNew,\n                    codAmount: 0,\n                    payer: 'Người nhận',\n                    weight: newItemData.packageInfo?.weight,\n                    dimensions: newItemData.packageInfo?.dimensions\n                });\n            }\n            // else: deliver-later → keep default 'Đặt hàng', 'Chờ đóng gói', no packagings\n            const newOrderPayload = {\n                id: '',\n                customerSystemId: order.customerSystemId,\n                customerName: order.customerName,\n                branchSystemId: order.branchSystemId,\n                branchName: order.branchName,\n                salespersonId: creatorSystemId,\n                salesperson: newItemData.creatorName,\n                orderDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.formatDateCustom)((0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)(), 'yyyy-MM-dd HH:mm'),\n                lineItems: newItemData.exchangeItems,\n                subtotal: newItemData.subtotalNew,\n                shippingFee: newItemData.shippingFeeNew,\n                tax: 0,\n                // ✅ IMPORTANT: grandTotal should be NET amount (after subtracting return value)\n                // grandTotal = subtotalNew + shippingFee - totalReturnValue\n                grandTotal: newItemData.finalAmount > 0 ? newItemData.finalAmount : newItemData.grandTotalNew,\n                // ✅ Store return value info for display\n                linkedSalesReturnId: newReturn.id,\n                linkedSalesReturnSystemId: newReturn.systemId,\n                linkedSalesReturnValue: newItemData.totalReturnValue,\n                payments: exchangeOrderPayments,\n                notes: `Đơn hàng đổi từ phiếu trả ${newReturn.id} của đơn hàng ${order.id}`,\n                sourceSalesReturnId: newReturn.id,\n                // ✅ Pass shipping info from form\n                deliveryMethod: newItemData.deliveryMethod === 'pickup' ? 'Nhận tại cửa hàng' : 'Dịch vụ giao hàng',\n                shippingPartnerId: newItemData.shippingPartnerId,\n                shippingServiceId: newItemData.shippingServiceId,\n                shippingAddress: newItemData.shippingAddress,\n                packageInfo: newItemData.packageInfo,\n                configuration: newItemData.configuration,\n                // ✅ Add required status fields based on delivery method\n                status: finalMainStatus,\n                paymentStatus: exchangeOrderPayments.length > 0 ? exchangeOrderPayments.reduce((sum, p)=>sum + p.amount, 0) >= newItemData.grandTotalNew ? 'Thanh toán toàn bộ' : 'Thanh toán 1 phần' : 'Chưa thanh toán',\n                deliveryStatus: finalDeliveryStatus,\n                printStatus: 'Chưa in',\n                stockOutStatus: 'Chưa xuất kho',\n                returnStatus: 'Chưa trả hàng',\n                codAmount: 0,\n                packagings: packagings\n            };\n            console.log('📦 [Sales Return] New order payload:', newOrderPayload);\n            const newOrder = addOrder(newOrderPayload);\n            console.log('✅ [Sales Return] New order created:', newOrder);\n            if (newOrder) {\n                newOrderSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(newOrder.systemId);\n                // ✅ Save exchange order systemId to sales return\n                newItemData.exchangeOrderSystemId = newOrderSystemId;\n                console.log('🎉 [Sales Return] Exchange order systemId:', newOrderSystemId);\n            } else {\n                console.error('❌ [Sales Return] Failed to create exchange order!');\n            }\n        }\n        // Adjust customer debt if needed\n        const creditAmount = newItemData.totalReturnValue - newItemData.grandTotalNew - (newItemData.refundAmount || 0);\n        if (creditAmount > 0) {\n            updateDebt(newItemData.customerSystemId, -creditAmount);\n        }\n        // ✅ newReturn already created above, use it directly\n        // ✅ NOW create vouchers with correct originalDocumentId\n        // Handle Financials AFTER creating the return\n        const finalAmount = newItemData.finalAmount;\n        if (finalAmount < 0 && newItemData.refunds && newItemData.refunds.length > 0) {\n            const createdVoucherIds = [];\n            newItemData.refunds.forEach((refund)=>{\n                if (!refund.amount || refund.amount <= 0) {\n                    return;\n                }\n                const { document, error } = (0,_finance_document_helpers__WEBPACK_IMPORTED_MODULE_7__.createPaymentDocument)({\n                    amount: refund.amount,\n                    description: `Hoàn tiền đổi/trả hàng từ đơn ${order.id} (Phiếu: ${newReturn.id}) qua ${refund.method}`,\n                    recipientName: newItemData.customerName,\n                    recipientSystemId: newItemData.customerSystemId,\n                    customerSystemId: newItemData.customerSystemId,\n                    customerName: newItemData.customerName,\n                    paymentMethodName: refund.method,\n                    accountSystemId: refund.accountSystemId,\n                    paymentTypeName: 'Hoàn tiền khách hàng',\n                    branchSystemId: newReturn.branchSystemId,\n                    branchName: newReturn.branchName,\n                    createdBy: creatorSystemId,\n                    originalDocumentId: newReturn.id,\n                    linkedSalesReturnSystemId: newReturn.systemId,\n                    linkedOrderSystemId: newReturn.orderSystemId,\n                    category: 'complaint_refund',\n                    affectsDebt: true\n                });\n                if (error) {\n                    console.error('[Sales Return] Failed to create payment voucher:', error);\n                    sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error(`Không thể tạo phiếu chi hoàn tiền: ${error}`);\n                    return;\n                }\n                if (document) {\n                    createdVoucherIds.push((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(document.systemId));\n                }\n            });\n            if (createdVoucherIds.length > 0) {\n                baseStore.getState().update(newReturn.systemId, {\n                    ...newReturn,\n                    paymentVoucherSystemIds: createdVoucherIds\n                });\n            }\n        } else if (finalAmount > 0 && newItemData.payments && newItemData.payments.length > 0) {\n            const createdVoucherIds = [];\n            newItemData.payments.forEach((payment)=>{\n                if (!payment.amount || payment.amount <= 0) {\n                    return;\n                }\n                const { document, error } = (0,_finance_document_helpers__WEBPACK_IMPORTED_MODULE_7__.createReceiptDocument)({\n                    amount: payment.amount,\n                    description: `Thu tiền chênh lệch đổi hàng từ đơn ${order.id} (Phiếu: ${newReturn.id})`,\n                    customerName: newReturn.customerName,\n                    customerSystemId: newItemData.customerSystemId,\n                    paymentMethodName: payment.method,\n                    accountSystemId: payment.accountSystemId,\n                    receiptTypeName: 'Thanh toán cho đơn hàng',\n                    branchSystemId: newReturn.branchSystemId,\n                    branchName: newReturn.branchName,\n                    createdBy: creatorSystemId,\n                    originalDocumentId: newReturn.id,\n                    linkedSalesReturnSystemId: newReturn.systemId,\n                    linkedOrderSystemId: newReturn.orderSystemId,\n                    category: 'sale',\n                    affectsDebt: false\n                });\n                if (error) {\n                    console.error('[Sales Return] Failed to create receipt voucher:', error);\n                    sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error(`Không thể tạo phiếu thu đổi hàng: ${error}`);\n                    return;\n                }\n                if (document) {\n                    createdVoucherIds.push((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_9__.asSystemId)(document.systemId));\n                }\n            });\n            if (createdVoucherIds.length > 0) {\n                baseStore.getState().update(newReturn.systemId, {\n                    ...newReturn,\n                    receiptVoucherSystemIds: createdVoucherIds\n                });\n            }\n        }\n        // ✅ Update inventory for returned items ONLY if isReceived = true\n        // ✅ For combo products, add stock to child products instead\n        if (newReturn.isReceived) {\n            console.log('✅ [Sales Return] Updating inventory - items received');\n            // Expand combo items to child products\n            const stockItems = getReturnStockItems(newReturn.items);\n            stockItems.forEach((item)=>{\n                if (item.quantity > 0) {\n                    const product = _products_store__WEBPACK_IMPORTED_MODULE_4__.useProductStore.getState().findById(item.productSystemId);\n                    const oldStock = product?.inventoryByBranch[newReturn.branchSystemId] || 0;\n                    updateInventory(item.productSystemId, newReturn.branchSystemId, item.quantity); // Add stock back\n                    addStockHistory({\n                        productId: item.productSystemId,\n                        date: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)().toISOString(),\n                        employeeName: newReturn.creatorName,\n                        action: 'Nhập hàng từ khách trả',\n                        quantityChange: item.quantity,\n                        newStockLevel: oldStock + item.quantity,\n                        documentId: newReturn.id,\n                        branchSystemId: newReturn.branchSystemId,\n                        branch: newReturn.branchName\n                    });\n                }\n            });\n        } else {\n            console.log('⏸️ [Sales Return] Inventory NOT updated - waiting for receipt confirmation');\n        }\n        // Update original order's return status\n        const previousReturnsForOrder = baseStore.getState().data.filter((r)=>r.orderSystemId === order.systemId);\n        const totalReturnedQty = previousReturnsForOrder.flatMap((r)=>r.items).reduce((sum, item)=>sum + item.returnQuantity, 0);\n        const totalOrderedQty = order.lineItems.reduce((sum, item)=>sum + item.quantity, 0);\n        const newReturnStatus = totalReturnedQty >= totalOrderedQty ? 'Trả hàng toàn bộ' : 'Trả hàng một phần';\n        updateOrder(order.systemId, {\n            ...order,\n            returnStatus: newReturnStatus\n        });\n        return {\n            newReturn,\n            newOrderSystemId\n        };\n    },\n    /**\r\n   * ✅ Confirm receipt of returned items and update inventory\r\n   * Use this when isReceived was false initially and items are now received\r\n   * ✅ For combo products, add stock to child products instead\r\n   */ confirmReceipt: (returnSystemId)=>{\n        const salesReturn = baseStore.getState().findById(returnSystemId);\n        if (!salesReturn) {\n            console.error('❌ [Sales Return] Return not found:', returnSystemId);\n            return {\n                success: false,\n                message: 'Không tìm thấy phiếu trả hàng'\n            };\n        }\n        if (salesReturn.isReceived) {\n            console.warn('⚠️ [Sales Return] Already received:', returnSystemId);\n            return {\n                success: false,\n                message: 'Hàng đã được nhận trước đó'\n            };\n        }\n        const { updateInventory } = _products_store__WEBPACK_IMPORTED_MODULE_4__.useProductStore.getState();\n        const { addEntry: addStockHistory } = _stock_history_store__WEBPACK_IMPORTED_MODULE_5__.useStockHistoryStore.getState();\n        // ✅ Expand combo items to child products\n        const stockItems = getReturnStockItems(salesReturn.items);\n        // Update inventory for all returned items (including expanded combo children)\n        stockItems.forEach((item)=>{\n            if (item.quantity > 0) {\n                const product = _products_store__WEBPACK_IMPORTED_MODULE_4__.useProductStore.getState().findById(item.productSystemId);\n                const oldStock = product?.inventoryByBranch[salesReturn.branchSystemId] || 0;\n                updateInventory(item.productSystemId, salesReturn.branchSystemId, item.quantity);\n                addStockHistory({\n                    productId: item.productSystemId,\n                    date: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)().toISOString(),\n                    employeeName: salesReturn.creatorName,\n                    action: 'Nhập hàng từ khách trả (xác nhận)',\n                    quantityChange: item.quantity,\n                    newStockLevel: oldStock + item.quantity,\n                    documentId: salesReturn.id,\n                    branchSystemId: salesReturn.branchSystemId,\n                    branch: salesReturn.branchName\n                });\n            }\n        });\n        // Update the return record\n        baseStore.getState().update(returnSystemId, {\n            ...salesReturn,\n            isReceived: true\n        });\n        console.log('✅ [Sales Return] Receipt confirmed and inventory updated:', returnSystemId);\n        return {\n            success: true,\n            message: 'Đã xác nhận nhận hàng và cập nhật tồn kho'\n        };\n    }\n};\n// Export typed hook\nconst useSalesReturnStore = ()=>{\n    const state = baseStore();\n    return {\n        ...state,\n        ...augmentedMethods\n    };\n};\n// Export getState for non-hook usage\nuseSalesReturnStore.getState = ()=>{\n    const state = baseStore.getState();\n    return {\n        ...state,\n        ...augmentedMethods\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3NhbGVzLXJldHVybnMvc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFrSTtBQUN4RTtBQUszQjtBQUUvQixlQUFlO0FBQ2lDO0FBQ0k7QUFDVTtBQUNSO0FBQ3FDO0FBQ3RCO0FBQ1E7QUFDcEI7QUFDb0I7QUFFN0U7OztDQUdDLEdBQ0QsTUFBTWdCLHNCQUFzQixDQUFDQztJQUN6QixNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHYiw0REFBZUEsQ0FBQ2MsUUFBUTtJQUM3QyxNQUFNQyxnQkFBd0YsRUFBRTtJQUVoR0gsWUFBWUksT0FBTyxDQUFDQyxDQUFBQTtRQUNoQixNQUFNQyxVQUFVTCxTQUFTSSxLQUFLRSxlQUFlO1FBQzdDLElBQUlELFdBQVdWLHNFQUFjQSxDQUFDVSxZQUFZQSxRQUFRRSxVQUFVLEVBQUU7WUFDMUQsbUNBQW1DO1lBQ25DRixRQUFRRSxVQUFVLENBQUNKLE9BQU8sQ0FBQ0ssQ0FBQUE7Z0JBQ3ZCLE1BQU1DLGVBQWVULFNBQVNRLFVBQVVGLGVBQWU7Z0JBQ3ZESixjQUFjUSxJQUFJLENBQUM7b0JBQ2ZKLGlCQUFpQkUsVUFBVUYsZUFBZTtvQkFDMUNLLGFBQWFGLGNBQWNHLFFBQVE7b0JBQ25DQyxVQUFVTCxVQUFVSyxRQUFRLEdBQUdULEtBQUtVLGNBQWM7Z0JBQ3REO1lBQ0o7UUFDSixPQUFPO1lBQ0gsa0JBQWtCO1lBQ2xCWixjQUFjUSxJQUFJLENBQUM7Z0JBQ2ZKLGlCQUFpQloseURBQVVBLENBQUNVLEtBQUtFLGVBQWU7Z0JBQ2hESyxhQUFhUCxLQUFLTyxXQUFXO2dCQUM3QkUsVUFBVVQsS0FBS1UsY0FBYztZQUNqQztRQUNKO0lBQ0o7SUFDQSxPQUFPWjtBQUNYO0FBRUEsTUFBTWEsWUFBWS9CLG1FQUFlQSxDQUFjLEVBQUUsRUFBRSxpQkFBaUI7SUFDbEVnQyxhQUFhO0FBQ2Y7QUFFQSxNQUFNQyxjQUFjRixVQUFVZCxRQUFRLEdBQUdpQixH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SUFDZCxPQUFPO1FBQ0wsR0FBRzhLLEtBQUs7UUFDUixHQUFHMUssZ0JBQWdCO0lBQ3JCO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUNyQ3lLLG9CQUFvQjNMLFFBQVEsR0FBRztJQUM3QixNQUFNNEwsUUFBUTlLLFVBQVVkLFFBQVE7SUFDaEMsT0FBTztRQUNMLEdBQUc0TCxLQUFLO1FBQ1IsR0FBRzFLLGdCQUFnQjtJQUNyQjtBQUNGIiwic291cmNlcyI6WyJEOlxcaHJtMlxcZmVhdHVyZXNcXHNhbGVzLXJldHVybnNcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdERhdGUsIGZvcm1hdERhdGVUaW1lLCBmb3JtYXREYXRlVGltZVNlY29uZHMsIGZvcm1hdERhdGVDdXN0b20sIHBhcnNlRGF0ZSwgZ2V0Q3VycmVudERhdGUgfSBmcm9tICdAL2xpYi9kYXRlLXV0aWxzJztcclxuaW1wb3J0IHsgY3JlYXRlQ3J1ZFN0b3JlIH0gZnJvbSAnLi4vLi4vbGliL3N0b3JlLWZhY3RvcnknO1xyXG5pbXBvcnQgdHlwZSB7IFNhbGVzUmV0dXJuLCBSZXR1cm5MaW5lSXRlbSB9IGZyb20gJy4vdHlwZXMnO1xyXG4vLyBSRU1PVkVEOiBpbXBvcnQgeyBkYXRhIGFzIGluaXRpYWxEYXRhIH0gZnJvbSAnLi9kYXRhJzsgLy8gTW9jayBkYXRhIG5vIGxvbmdlciB1c2VkIC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbmltcG9ydCB7IEdIVEtTZXJ2aWNlLCB0eXBlIEdIVEtDcmVhdGVPcmRlclBhcmFtcyB9IGZyb20gJy4uL3NldHRpbmdzL3NoaXBwaW5nL2ludGVncmF0aW9ucy9naHRrLXNlcnZpY2UnO1xyXG5pbXBvcnQgeyBsb2FkU2hpcHBpbmdDb25maWcgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMvc2hpcHBpbmctY29uZmlnLW1pZ3JhdGlvbic7XHJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAnc29ubmVyJztcclxuXHJcbi8vIE90aGVyIHN0b3Jlc1xyXG5pbXBvcnQgeyB1c2VPcmRlclN0b3JlIH0gZnJvbSAnLi4vb3JkZXJzL3N0b3JlJztcclxuaW1wb3J0IHsgdXNlUHJvZHVjdFN0b3JlIH0gZnJvbSAnLi4vcHJvZHVjdHMvc3RvcmUnO1xyXG5pbXBvcnQgeyB1c2VTdG9ja0hpc3RvcnlTdG9yZSB9IGZyb20gJy4uL3N0b2NrLWhpc3Rvcnkvc3RvcmUnO1xyXG5pbXBvcnQgeyB1c2VDdXN0b21lclN0b3JlIH0gZnJvbSAnLi4vY3VzdG9tZXJzL3N0b3JlJztcclxuaW1wb3J0IHsgY3JlYXRlUGF5bWVudERvY3VtZW50LCBjcmVhdGVSZWNlaXB0RG9jdW1lbnQgfSBmcm9tICcuLi9maW5hbmNlL2RvY3VtZW50LWhlbHBlcnMnO1xyXG5pbXBvcnQgeyB1c2VTaGlwcGluZ1BhcnRuZXJTdG9yZSB9IGZyb20gJy4uL3NldHRpbmdzL3NoaXBwaW5nL3N0b3JlJztcclxuaW1wb3J0IHsgYXNCdXNpbmVzc0lkLCBhc1N5c3RlbUlkLCB0eXBlIFN5c3RlbUlkIH0gZnJvbSAnLi4vLi4vbGliL2lkLXR5cGVzJztcclxuaW1wb3J0IHsgaXNDb21ib1Byb2R1Y3QgfSBmcm9tICcuLi9wcm9kdWN0cy9jb21iby11dGlscyc7XHJcbmltcG9ydCB7IGdlbmVyYXRlU3lzdGVtSWQsIGdldE1heFN5c3RlbUlkQ291bnRlciB9IGZyb20gJy4uLy4uL2xpYi9pZC11dGlscyc7XHJcblxyXG4vKipcclxuICog4pyFIEhlbHBlcjogRXhwYW5kIGNvbWJvIHJldHVybiBpdGVtcyB0byBjaGlsZCBwcm9kdWN0c1xyXG4gKiBXaGVuIGEgY29tYm8gaXMgcmV0dXJuZWQsIHdlIG5lZWQgdG8gYWRkIHN0b2NrIGJhY2sgdG8gY2hpbGQgcHJvZHVjdHNcclxuICovXHJcbmNvbnN0IGdldFJldHVyblN0b2NrSXRlbXMgPSAocmV0dXJuSXRlbXM6IFJldHVybkxpbmVJdGVtW10pID0+IHtcclxuICAgIGNvbnN0IHsgZmluZEJ5SWQgfSA9IHVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgY29uc3QgZXhwYW5kZWRJdGVtczogeyBwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkOyBwcm9kdWN0TmFtZTogc3RyaW5nOyBxdWFudGl0eTogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgXHJcbiAgICByZXR1cm5JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSBmaW5kQnlJZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICAgICAgaWYgKHByb2R1Y3QgJiYgaXNDb21ib1Byb2R1Y3QocHJvZHVjdCkgJiYgcHJvZHVjdC5jb21ib0l0ZW1zKSB7XHJcbiAgICAgICAgICAgIC8vIENvbWJvIOKGkiBleHBhbmQgdG8gY2hpbGQgcHJvZHVjdHNcclxuICAgICAgICAgICAgcHJvZHVjdC5jb21ib0l0ZW1zLmZvckVhY2goY29tYm9JdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvZHVjdCA9IGZpbmRCeUlkKGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0U3lzdGVtSWQ6IGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdE5hbWU6IGNoaWxkUHJvZHVjdD8ubmFtZSB8fCAnU1Aga2jDtG5nIHjDoWMgxJHhu4tuaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGNvbWJvSXRlbS5xdWFudGl0eSAqIGl0ZW0ucmV0dXJuUXVhbnRpdHlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZWd1bGFyIHByb2R1Y3RcclxuICAgICAgICAgICAgZXhwYW5kZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RTeXN0ZW1JZDogYXNTeXN0ZW1JZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCksXHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0TmFtZTogaXRlbS5wcm9kdWN0TmFtZSxcclxuICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnJldHVyblF1YW50aXR5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV4cGFuZGVkSXRlbXM7XHJcbn07XHJcblxyXG5jb25zdCBiYXNlU3RvcmUgPSBjcmVhdGVDcnVkU3RvcmU8U2FsZXNSZXR1cm4+KFtdLCAnc2FsZXMtcmV0dXJucycsIHtcclxuICBhcGlFbmRwb2ludDogJy9hcGkvc2FsZXMtcmV0dXJucycsXHJcbn0pO1xyXG5cclxuY29uc3Qgb3JpZ2luYWxBZGQgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5hZGQ7XHJcblxyXG5jb25zdCBhdWdtZW50ZWRNZXRob2RzID0ge1xyXG4gIGFkZFdpdGhTaWRlRWZmZWN0czogKGl0ZW06IE9taXQ8U2FsZXNSZXR1cm4sICdzeXN0ZW1JZCcgfCAnaWQnPiAmIHsgY3JlYXRvcklkOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgY29uc3Qgb3JkZXJTeXN0ZW1JZCA9IGFzU3lzdGVtSWQoaXRlbS5vcmRlclN5c3RlbUlkKTtcclxuICAgIGNvbnN0IG9yZGVyQnVzaW5lc3NJZCA9IGFzQnVzaW5lc3NJZChpdGVtLm9yZGVySWQpO1xyXG4gICAgY29uc3QgY3VzdG9tZXJTeXN0ZW1JZCA9IGFzU3lzdGVtSWQoaXRlbS5jdXN0b21lclN5c3RlbUlkKTtcclxuICAgIGNvbnN0IGJyYW5jaFN5c3RlbUlkID0gYXNTeXN0ZW1JZChpdGVtLmJyYW5jaFN5c3RlbUlkKTtcclxuICAgIGNvbnN0IGNyZWF0b3JTeXN0ZW1JZCA9IGFzU3lzdGVtSWQoaXRlbS5jcmVhdG9yU3lzdGVtSWQgPz8gaXRlbS5jcmVhdG9ySWQgPz8gJ1NZU1RFTScpO1xyXG4gICAgY29uc3QgZXhjaGFuZ2VPcmRlclN5c3RlbUlkID0gaXRlbS5leGNoYW5nZU9yZGVyU3lzdGVtSWQgPyBhc1N5c3RlbUlkKGl0ZW0uZXhjaGFuZ2VPcmRlclN5c3RlbUlkKSA6IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGFjY291bnRTeXN0ZW1JZCA9IGl0ZW0uYWNjb3VudFN5c3RlbUlkID8gYXNTeXN0ZW1JZChpdGVtLmFjY291bnRTeXN0ZW1JZCkgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBwYXltZW50Vm91Y2hlclN5c3RlbUlkID0gaXRlbS5wYXltZW50Vm91Y2hlclN5c3RlbUlkID8gYXNTeXN0ZW1JZChpdGVtLnBheW1lbnRWb3VjaGVyU3lzdGVtSWQpIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgcGF5bWVudFZvdWNoZXJTeXN0ZW1JZHMgPSBpdGVtLnBheW1lbnRWb3VjaGVyU3lzdGVtSWRzPy5tYXAoYXNTeXN0ZW1JZCk7XHJcbiAgICBjb25zdCByZWNlaXB0Vm91Y2hlclN5c3RlbUlkcyA9IGl0ZW0ucmVjZWlwdFZvdWNoZXJTeXN0ZW1JZHM/Lm1hcChhc1N5c3RlbUlkKTtcclxuXHJcbiAgICBjb25zdCBmb3JtYXR0ZWRJdGVtcyA9IGl0ZW0uaXRlbXMubWFwKGxpbmVJdGVtID0+ICh7XHJcbiAgICAgIC4uLmxpbmVJdGVtLFxyXG4gICAgICBwcm9kdWN0U3lzdGVtSWQ6IGFzU3lzdGVtSWQobGluZUl0ZW0ucHJvZHVjdFN5c3RlbUlkKSxcclxuICAgICAgcHJvZHVjdElkOiBhc0J1c2luZXNzSWQobGluZUl0ZW0ucHJvZHVjdElkKSxcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCBmb3JtYXR0ZWRQYXltZW50cyA9IGl0ZW0ucGF5bWVudHM/Lm1hcChwYXltZW50ID0+ICh7XHJcbiAgICAgIC4uLnBheW1lbnQsXHJcbiAgICAgIGFjY291bnRTeXN0ZW1JZDogYXNTeXN0ZW1JZChwYXltZW50LmFjY291bnRTeXN0ZW1JZCksXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgZm9ybWF0dGVkUmVmdW5kcyA9IGl0ZW0ucmVmdW5kcz8ubWFwKHJlZnVuZCA9PiAoe1xyXG4gICAgICAuLi5yZWZ1bmQsXHJcbiAgICAgIGFjY291bnRTeXN0ZW1JZDogYXNTeXN0ZW1JZChyZWZ1bmQuYWNjb3VudFN5c3RlbUlkKSxcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCBuZXdJdGVtRGF0YTogT21pdDxTYWxlc1JldHVybiwgJ3N5c3RlbUlkJz4gPSB7XHJcbiAgICAgIGlkOiBhc0J1c2luZXNzSWQoJycpLFxyXG4gICAgICBvcmRlclN5c3RlbUlkLFxyXG4gICAgICBvcmRlcklkOiBvcmRlckJ1c2luZXNzSWQsXHJcbiAgICAgIGN1c3RvbWVyU3lzdGVtSWQsXHJcbiAgICAgIGN1c3RvbWVyTmFtZTogaXRlbS5jdXN0b21lck5hbWUsXHJcbiAgICAgIGJyYW5jaFN5c3RlbUlkLFxyXG4gICAgICBicmFuY2hOYW1lOiBpdGVtLmJyYW5jaE5hbWUsXHJcbiAgICAgIHJldHVybkRhdGU6IGl0ZW0ucmV0dXJuRGF0ZSxcclxuICAgICAgcmVhc29uOiBpdGVtLnJlYXNvbixcclxuICAgICAgbm90ZTogaXRlbS5ub3RlLFxyXG4gICAgICBub3RlczogaXRlbS5ub3RlcyxcclxuICAgICAgcmVmZXJlbmNlOiBpdGVtLnJlZmVyZW5jZSxcclxuICAgICAgaXRlbXM6IGZvcm1hdHRlZEl0ZW1zLFxyXG4gICAgICB0b3RhbFJldHVyblZhbHVlOiBpdGVtLnRvdGFsUmV0dXJuVmFsdWUsXHJcbiAgICAgIGlzUmVjZWl2ZWQ6IGl0ZW0uaXNSZWNlaXZlZCxcclxuICAgICAgZXhjaGFuZ2VJdGVtczogaXRlbS5leGNoYW5nZUl0ZW1zID8/IFtdLFxyXG4gICAgICBleGNoYW5nZU9yZGVyU3lzdGVtSWQsXHJcbiAgICAgIHN1YnRvdGFsTmV3OiBpdGVtLnN1YnRvdGFsTmV3LFxyXG4gICAgICBzaGlwcGluZ0ZlZU5ldzogaXRlbS5zaGlwcGluZ0ZlZU5ldyxcclxuICAgICAgZGlzY291bnROZXc6IGl0ZW0uZGlzY291bnROZXcsXHJcbiAgICAgIGRpc2NvdW50TmV3VHlwZTogaXRlbS5kaXNjb3VudE5ld1R5cGUsXHJcbiAgICAgIGdyYW5kVG90YWxOZXc6IGl0ZW0uZ3JhbmRUb3RhbE5ldyxcclxuICAgICAgZGVsaXZlcnlNZXRob2Q6IGl0ZW0uZGVsaXZlcnlNZXRob2QsXHJcbiAgICAgIHNoaXBwaW5nUGFydG5lcklkOiBpdGVtLnNoaXBwaW5nUGFydG5lcklkLFxyXG4gICAgICBzaGlwcGluZ1NlcnZpY2VJZDogaXRlbS5zaGlwcGluZ1NlcnZpY2VJZCxcclxuICAgICAgc2hpcHBpbmdBZGRyZXNzOiBpdGVtLnNoaXBwaW5nQWRkcmVzcyxcclxuICAgICAgcGFja2FnZUluZm86IGl0ZW0ucGFja2FnZUluZm8sXHJcbiAgICAgIGNvbmZpZ3VyYXRpb246IGl0ZW0uY29uZmlndXJhdGlvbixcclxuICAgICAgZmluYWxBbW91bnQ6IGl0ZW0uZmluYWxBbW91bnQsXHJcbiAgICAgIHJlZnVuZE1ldGhvZDogaXRlbS5yZWZ1bmRNZXRob2QsXHJcbiAgICAgIHJlZnVuZEFtb3VudDogaXRlbS5yZWZ1bmRBbW91bnQsXHJcbiAgICAgIGFjY291bnRTeXN0ZW1JZCxcclxuICAgICAgcmVmdW5kczogZm9ybWF0dGVkUmVmdW5kcyxcclxuICAgICAgcGF5bWVudHM6IGZvcm1hdHRlZFBheW1lbnRzLFxyXG4gICAgICBwYXltZW50Vm91Y2hlclN5c3RlbUlkLFxyXG4gICAgICBwYXltZW50Vm91Y2hlclN5c3RlbUlkcyxcclxuICAgICAgcmVjZWlwdFZvdWNoZXJTeXN0ZW1JZHMsXHJcbiAgICAgIGNyZWF0b3JTeXN0ZW1JZCxcclxuICAgICAgY3JlYXRvck5hbWU6IGl0ZW0uY3JlYXRvck5hbWUsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIC0tLSBTaWRlIEVmZmVjdHMgLS0tXHJcbiAgICBjb25zdCB7IHVwZGF0ZTogdXBkYXRlT3JkZXIsIGZpbmRCeUlkOiBmaW5kT3JkZXJCeUlkLCBhZGQ6IGFkZE9yZGVyIH0gPSB1c2VPcmRlclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB7IHVwZGF0ZUludmVudG9yeSB9ID0gdXNlUHJvZHVjdFN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB7IGFkZEVudHJ5OiBhZGRTdG9ja0hpc3RvcnkgfSA9IHVzZVN0b2NrSGlzdG9yeVN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB7IHVwZGF0ZURlYnQsIGluY3JlbWVudFJldHVyblN0YXRzIH0gPSB1c2VDdXN0b21lclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBvcmRlciA9IGZpbmRPcmRlckJ5SWQobmV3SXRlbURhdGEub3JkZXJTeXN0ZW1JZCk7XHJcbiAgICBpZiAoIW9yZGVyKSByZXR1cm4geyBuZXdSZXR1cm46IG51bGwsIG5ld09yZGVyU3lzdGVtSWQ6IG51bGwgfTtcclxuXHJcbiAgICAvLyDinIUgSU1QT1JUQU5UOiBDcmVhdGUgdGhlIHJldHVybiBGSVJTVCB0byBnZXQgSURzIGZvciBleGNoYW5nZSBvcmRlclxyXG4gICAgY29uc3QgbmV3UmV0dXJuID0gb3JpZ2luYWxBZGQobmV3SXRlbURhdGEpO1xyXG4gICAgaWYgKCFuZXdSZXR1cm4pIHJldHVybiB7IG5ld1JldHVybjogbnVsbCwgbmV3T3JkZXJTeXN0ZW1JZDogbnVsbCB9O1xyXG5cclxuICAgIC8vIOKchSBVcGRhdGUgY3VzdG9tZXIgcmV0dXJuIHN0YXRzXHJcbiAgICBjb25zdCB0b3RhbFJldHVyblF0eSA9IG5ld0l0ZW1EYXRhLml0ZW1zLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnJldHVyblF1YW50aXR5LCAwKTtcclxuICAgIGlmICh0b3RhbFJldHVyblF0eSA+IDApIHtcclxuICAgICAgICBpbmNyZW1lbnRSZXR1cm5TdGF0cyhuZXdJdGVtRGF0YS5jdXN0b21lclN5c3RlbUlkLCB0b3RhbFJldHVyblF0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG5ld09yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG5ldyBzYWxlcyBvcmRlciBmb3IgdGhlIGV4Y2hhbmdlIGl0ZW1zXHJcbiAgICBpZiAobmV3SXRlbURhdGEuZXhjaGFuZ2VJdGVtcyAmJiBuZXdJdGVtRGF0YS5leGNoYW5nZUl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBbU2FsZXMgUmV0dXJuXSBDcmVhdGluZyBleGNoYW5nZSBvcmRlci4uLicsIHtcclxuICAgICAgICBleGNoYW5nZUl0ZW1zOiBuZXdJdGVtRGF0YS5leGNoYW5nZUl0ZW1zLFxyXG4gICAgICAgIGZpbmFsQW1vdW50OiBuZXdJdGVtRGF0YS5maW5hbEFtb3VudCxcclxuICAgICAgICBwYXltZW50czogbmV3SXRlbURhdGEucGF5bWVudHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgIC8vIOKchSBDYWxjdWxhdGUgcGF5bWVudHMgZm9yIGV4Y2hhbmdlIG9yZGVyIGJhc2VkIG9uIHNhbGVzIHJldHVybiBsb2dpY1xyXG4gICAgICBjb25zdCBleGNoYW5nZU9yZGVyUGF5bWVudHMgPVxyXG4gICAgICAgIG5ld0l0ZW1EYXRhLmZpbmFsQW1vdW50ID4gMCAmJiBuZXdJdGVtRGF0YS5wYXltZW50c1xyXG4gICAgICAgID8gbmV3SXRlbURhdGEucGF5bWVudHMubWFwKHAgPT4gKHtcclxuICAgICAgICAgIG1ldGhvZDogcC5tZXRob2QsXHJcbiAgICAgICAgICBhY2NvdW50U3lzdGVtSWQ6IHAuYWNjb3VudFN5c3RlbUlkLFxyXG4gICAgICAgICAgYW1vdW50OiBwLmFtb3VudCxcclxuICAgICAgICAgIH0pKVxyXG4gICAgICAgIDogW107XHJcbiAgICAgICAgLy8gSWYgY29tcGFueSByZWZ1bmRlZCBjdXN0b21lciAoZmluYWxBbW91bnQgPCAwKVxyXG4gICAgICAgIC8vIFRoZSBleGNoYW5nZSBvcmRlciB3aWxsIGhhdmUgQ09EID0gZ3JhbmRUb3RhbCAoc2hpcHBlciBjb2xsZWN0cyBvbiBkZWxpdmVyeSlcclxuICAgICAgICAvLyBObyBwYXltZW50cyBhcnJheSBuZWVkZWQgLSB3aWxsIGJlIGhhbmRsZWQgYnkgQ09EIGluIHNoaXBwaW5nXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g4pyFIERldGVybWluZSBzdGF0dXMgYW5kIHBhY2thZ2luZ3MgYmFzZWQgb24gZGVsaXZlcnkgbWV0aG9kXHJcbiAgICAgICAgbGV0IGZpbmFsTWFpblN0YXR1czogJ8SQ4bq3dCBow6BuZycgfCAnxJBhbmcgZ2lhbyBk4buLY2gnID0gJ8SQ4bq3dCBow6BuZyc7XHJcbiAgICAgICAgbGV0IGZpbmFsRGVsaXZlcnlTdGF0dXM6IHN0cmluZyA9ICdDaOG7nSDEkcOzbmcgZ8OzaSc7XHJcbiAgICAgICAgY29uc3QgcGFja2FnaW5nczogYW55W10gPSBbXTtcclxuICAgICAgICBjb25zdCBub3cgPSBmb3JtYXREYXRlQ3VzdG9tKGdldEN1cnJlbnREYXRlKCksICd5eXl5LU1NLWRkIEhIOm1tJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g4pyFIEhlbHBlciB0byBnZXQgbmV4dCBwYWNrYWdpbmcgc3lzdGVtSWRcclxuICAgICAgICBjb25zdCBQQUNLQUdJTkdfU1lTVEVNX0lEX1BSRUZJWCA9ICdQQUNLQUdFJztcclxuICAgICAgICBjb25zdCBhbGxPcmRlcnMgPSB1c2VPcmRlclN0b3JlLmdldFN0YXRlKCkuZGF0YTtcclxuICAgICAgICBjb25zdCBhbGxQYWNrYWdpbmdzID0gYWxsT3JkZXJzLmZsYXRNYXAobyA9PiBvLnBhY2thZ2luZ3MgfHwgW10pO1xyXG4gICAgICAgIGNvbnN0IG1heFBhY2thZ2luZ0NvdW50ZXIgPSBnZXRNYXhTeXN0ZW1JZENvdW50ZXIoYWxsUGFja2FnaW5ncywgUEFDS0FHSU5HX1NZU1RFTV9JRF9QUkVGSVgpO1xyXG4gICAgICAgIGxldCBwYWNrYWdpbmdDb3VudGVyID0gbWF4UGFja2FnaW5nQ291bnRlcjtcclxuICAgICAgICBjb25zdCBnZXROZXh0UGFja2FnaW5nU3lzdGVtSWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHBhY2thZ2luZ0NvdW50ZXIrKztcclxuICAgICAgICAgICAgcmV0dXJuIGFzU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZCgncGFja2FnaW5nJywgcGFja2FnaW5nQ291bnRlcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgc2hpcHBpbmcgcGFydG5lciBvciBwaWNrdXBcclxuICAgICAgY29uc3QgaXNQaWNrdXAgPSBuZXdJdGVtRGF0YS5kZWxpdmVyeU1ldGhvZCA9PT0gJ3BpY2t1cCc7XHJcbiAgICAgIGNvbnN0IGlzU2hpcHBpbmdQYXJ0bmVyID0gbmV3SXRlbURhdGEuc2hpcHBpbmdQYXJ0bmVySWQgJiYgbmV3SXRlbURhdGEuc2hpcHBpbmdTZXJ2aWNlSWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGlzUGlja3VwKSB7XHJcbiAgICAgICAgICAgIC8vIE5o4bqtbiB04bqhaSBj4butYSBow6BuZyAtIFThuqFvIHBhY2thZ2luZyByZXF1ZXN0IG5nYXlcclxuICAgICAgICAgICAgZmluYWxNYWluU3RhdHVzID0gJ8SQYW5nIGdpYW8gZOG7i2NoJztcclxuICAgICAgICAgICAgZmluYWxEZWxpdmVyeVN0YXR1cyA9ICdDaOG7nSDEkcOzbmcgZ8OzaSc7XHJcbiAgICAgICAgICAgIHBhY2thZ2luZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkKCksIC8vIOKchSBVc2UgcHJvcGVyIGZvcm1hdCBQQUNLQUdFMDAwMDAxXHJcbiAgICAgICAgICAgICAgICBpZDogJycsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0ZTogbm93LFxyXG4gICAgICAgICAgcmVxdWVzdGluZ0VtcGxveWVlSWQ6IGNyZWF0b3JTeXN0ZW1JZCxcclxuICAgICAgICAgIHJlcXVlc3RpbmdFbXBsb3llZU5hbWU6IG5ld0l0ZW1EYXRhLmNyZWF0b3JOYW1lLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnQ2jhu50gxJHDs25nIGfDs2knLFxyXG4gICAgICAgICAgICAgICAgcHJpbnRTdGF0dXM6ICdDaMawYSBpbicsXHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ0No4budIMSRw7NuZyBnw7NpJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1NoaXBwaW5nUGFydG5lcikge1xyXG4gICAgICAgICAgICAvLyDEkOG6qXkgcXVhIGjDo25nIHbhuq1uIGNodXnhu4NuIC0gVOG6oW8gcGFja2FnaW5nIMSRw6MgxJHDs25nIGfDs2kgduG7m2kgdHJhY2tpbmdcclxuICAgICAgICAgICAgZmluYWxNYWluU3RhdHVzID0gJ8SQYW5nIGdpYW8gZOG7i2NoJztcclxuICAgICAgICAgICAgZmluYWxEZWxpdmVyeVN0YXR1cyA9ICdDaOG7nSBs4bqleSBow6BuZyc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBHZXQgcGFydG5lciBpbmZvXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcGFydG5lcnMgfSA9IHVzZVNoaXBwaW5nUGFydG5lclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRuZXIgPSBwYXJ0bmVycy5maW5kKHAgPT4gcC5zeXN0ZW1JZCA9PT0gbmV3SXRlbURhdGEuc2hpcHBpbmdQYXJ0bmVySWQpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcGFydG5lcj8uc2VydmljZXMuZmluZChzID0+IHMuaWQgPT09IG5ld0l0ZW1EYXRhLnNoaXBwaW5nU2VydmljZUlkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHBhY2thZ2luZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkKCksIC8vIOKchSBVc2UgcHJvcGVyIGZvcm1hdCBQQUNLQUdFMDAwMDAxXHJcbiAgICAgICAgICAgICAgICBpZDogJycsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0ZTogbm93LFxyXG4gICAgICAgICAgICAgICAgY29uZmlybURhdGU6IG5vdyxcclxuICAgICAgICAgICAgICByZXF1ZXN0aW5nRW1wbG95ZWVJZDogY3JlYXRvclN5c3RlbUlkLFxyXG4gICAgICAgICAgICAgIHJlcXVlc3RpbmdFbXBsb3llZU5hbWU6IG5ld0l0ZW1EYXRhLmNyZWF0b3JOYW1lLFxyXG4gICAgICAgICAgICAgIGNvbmZpcm1pbmdFbXBsb3llZUlkOiBjcmVhdG9yU3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgY29uZmlybWluZ0VtcGxveWVlTmFtZTogbmV3SXRlbURhdGEuY3JlYXRvck5hbWUsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICfEkMOjIMSRw7NuZyBnw7NpJyxcclxuICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnQ2jhu50gbOG6pXkgaMOgbmcnLFxyXG4gICAgICAgICAgICAgICAgcHJpbnRTdGF0dXM6ICdDaMawYSBpbicsXHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyeU1ldGhvZDogJ0Thu4tjaCB24bulIGdpYW8gaMOgbmcnLFxyXG4gICAgICAgICAgICAgICAgY2FycmllcjogcGFydG5lcj8ubmFtZSxcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2U/Lm5hbWUsXHJcbiAgICAgICAgICAgICAgdHJhY2tpbmdDb2RlOiBuZXdJdGVtRGF0YS5wYWNrYWdlSW5mbz8udHJhY2tpbmdDb2RlIHx8IGBWQyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgICAgIHNoaXBwaW5nRmVlVG9QYXJ0bmVyOiBuZXdJdGVtRGF0YS5zaGlwcGluZ0ZlZU5ldyxcclxuICAgICAgICAgICAgICAgIGNvZEFtb3VudDogMCwgLy8gV2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHBheW1lbnRzXHJcbiAgICAgICAgICAgICAgICBwYXllcjogJ05nxrDhu51pIG5o4bqtbicsXHJcbiAgICAgICAgICAgICAgd2VpZ2h0OiBuZXdJdGVtRGF0YS5wYWNrYWdlSW5mbz8ud2VpZ2h0LFxyXG4gICAgICAgICAgICAgIGRpbWVuc2lvbnM6IG5ld0l0ZW1EYXRhLnBhY2thZ2VJbmZvPy5kaW1lbnNpb25zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZTogZGVsaXZlci1sYXRlciDihpIga2VlcCBkZWZhdWx0ICfEkOG6t3QgaMOgbmcnLCAnQ2jhu50gxJHDs25nIGfDs2knLCBubyBwYWNrYWdpbmdzXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3T3JkZXJQYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBpZDogJycsIC8vIOKchSBFbXB0eSBzdHJpbmcgdHJpZ2dlcnMgYXV0by1nZW5lcmF0aW9uIG9mIGJ1c2luZXNzIElEIChESC4uLilcclxuICAgICAgICAgICAgY3VzdG9tZXJTeXN0ZW1JZDogb3JkZXIuY3VzdG9tZXJTeXN0ZW1JZCxcclxuICAgICAgICAgICAgY3VzdG9tZXJOYW1lOiBvcmRlci5jdXN0b21lck5hbWUsXHJcbiAgICAgICAgICAgIGJyYW5jaFN5c3RlbUlkOiBvcmRlci5icmFuY2hTeXN0ZW1JZCwgLy8g4pyFIFVzZSBzeXN0ZW1JZCBvbmx5XHJcbiAgICAgICAgICAgIGJyYW5jaE5hbWU6IG9yZGVyLmJyYW5jaE5hbWUsXHJcbiAgICAgICAgICAgIHNhbGVzcGVyc29uSWQ6IGNyZWF0b3JTeXN0ZW1JZCxcclxuICAgICAgICAgICAgc2FsZXNwZXJzb246IG5ld0l0ZW1EYXRhLmNyZWF0b3JOYW1lLFxyXG4gICAgICAgICAgICBvcmRlckRhdGU6IGZvcm1hdERhdGVDdXN0b20oZ2V0Q3VycmVudERhdGUoKSwgJ3l5eXktTU0tZGQgSEg6bW0nKSxcclxuICAgICAgICAgICAgbGluZUl0ZW1zOiBuZXdJdGVtRGF0YS5leGNoYW5nZUl0ZW1zLFxyXG4gICAgICAgICAgICBzdWJ0b3RhbDogbmV3SXRlbURhdGEuc3VidG90YWxOZXcsXHJcbiAgICAgICAgICAgIHNoaXBwaW5nRmVlOiBuZXdJdGVtRGF0YS5zaGlwcGluZ0ZlZU5ldyxcclxuICAgICAgICAgICAgdGF4OiAwLFxyXG4gICAgICAgICAgICAvLyDinIUgSU1QT1JUQU5UOiBncmFuZFRvdGFsIHNob3VsZCBiZSBORVQgYW1vdW50IChhZnRlciBzdWJ0cmFjdGluZyByZXR1cm4gdmFsdWUpXHJcbiAgICAgICAgICAgIC8vIGdyYW5kVG90YWwgPSBzdWJ0b3RhbE5ldyArIHNoaXBwaW5nRmVlIC0gdG90YWxSZXR1cm5WYWx1ZVxyXG4gICAgICAgICAgICBncmFuZFRvdGFsOiBuZXdJdGVtRGF0YS5maW5hbEFtb3VudCA+IDAgPyBuZXdJdGVtRGF0YS5maW5hbEFtb3VudCA6IG5ld0l0ZW1EYXRhLmdyYW5kVG90YWxOZXcsXHJcbiAgICAgICAgICAgIC8vIOKchSBTdG9yZSByZXR1cm4gdmFsdWUgaW5mbyBmb3IgZGlzcGxheVxyXG4gICAgICAgICAgICBsaW5rZWRTYWxlc1JldHVybklkOiBuZXdSZXR1cm4uaWQsIC8vIOKchSBGaXhlZDogVXNlIG5ld1JldHVybi5pZCAoYnVzaW5lc3MgSUQpXHJcbiAgICAgICAgICAgIGxpbmtlZFNhbGVzUmV0dXJuU3lzdGVtSWQ6IG5ld1JldHVybi5zeXN0ZW1JZCwgLy8g4pyFIEFkZCBzeXN0ZW1JZCBmb3IgbGlua2luZ1xyXG4gICAgICAgICAgICBsaW5rZWRTYWxlc1JldHVyblZhbHVlOiBuZXdJdGVtRGF0YS50b3RhbFJldHVyblZhbHVlLCAvLyBWYWx1ZSBvZiByZXR1cm5lZCBpdGVtc1xyXG4gICAgICAgICAgICBwYXltZW50czogZXhjaGFuZ2VPcmRlclBheW1lbnRzLCAvLyDinIUgU2V0IHBheW1lbnRzIGJhc2VkIG9uIHNhbGVzIHJldHVybiBzY2VuYXJpb1xyXG4gICAgICAgICAgICBub3RlczogYMSQxqFuIGjDoG5nIMSR4buVaSB04burIHBoaeG6v3UgdHLhuqMgJHtuZXdSZXR1cm4uaWR9IGPhu6dhIMSRxqFuIGjDoG5nICR7b3JkZXIuaWR9YCwgLy8g4pyFIEZpeGVkOiBVc2UgbmV3UmV0dXJuLmlkXHJcbiAgICAgICAgICAgIHNvdXJjZVNhbGVzUmV0dXJuSWQ6IG5ld1JldHVybi5pZCwgLy8g4pyFIEZpeGVkOiBVc2UgbmV3UmV0dXJuLmlkXHJcbiAgICAgICAgICAgIC8vIOKchSBQYXNzIHNoaXBwaW5nIGluZm8gZnJvbSBmb3JtXHJcbiAgICAgICAgICAgIGRlbGl2ZXJ5TWV0aG9kOiBuZXdJdGVtRGF0YS5kZWxpdmVyeU1ldGhvZCA9PT0gJ3BpY2t1cCcgPyAnTmjhuq1uIHThuqFpIGPhu61hIGjDoG5nJyA6ICdE4buLY2ggduG7pSBnaWFvIGjDoG5nJyxcclxuICAgICAgICAgICAgc2hpcHBpbmdQYXJ0bmVySWQ6IG5ld0l0ZW1EYXRhLnNoaXBwaW5nUGFydG5lcklkLFxyXG4gICAgICAgICAgICBzaGlwcGluZ1NlcnZpY2VJZDogbmV3SXRlbURhdGEuc2hpcHBpbmdTZXJ2aWNlSWQsXHJcbiAgICAgICAgICAgIHNoaXBwaW5nQWRkcmVzczogbmV3SXRlbURhdGEuc2hpcHBpbmdBZGRyZXNzLFxyXG4gICAgICAgICAgICBwYWNrYWdlSW5mbzogbmV3SXRlbURhdGEucGFja2FnZUluZm8sXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IG5ld0l0ZW1EYXRhLmNvbmZpZ3VyYXRpb24sXHJcbiAgICAgICAgICAgIC8vIOKchSBBZGQgcmVxdWlyZWQgc3RhdHVzIGZpZWxkcyBiYXNlZCBvbiBkZWxpdmVyeSBtZXRob2RcclxuICAgICAgICAgICAgc3RhdHVzOiBmaW5hbE1haW5TdGF0dXMsXHJcbiAgICAgICAgICAgIHBheW1lbnRTdGF0dXM6IGV4Y2hhbmdlT3JkZXJQYXltZW50cy5sZW5ndGggPiAwID8gXHJcbiAgICAgICAgICAgICAgKGV4Y2hhbmdlT3JkZXJQYXltZW50cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5hbW91bnQsIDApID49IG5ld0l0ZW1EYXRhLmdyYW5kVG90YWxOZXcgPyAnVGhhbmggdG/DoW4gdG/DoG4gYuG7mScgOiAnVGhhbmggdG/DoW4gMSBwaOG6p24nKSBcclxuICAgICAgICAgICAgICAgIDogJ0NoxrBhIHRoYW5oIHRvw6FuJyBhcyBjb25zdCxcclxuICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6IGZpbmFsRGVsaXZlcnlTdGF0dXMsXHJcbiAgICAgICAgICAgIHByaW50U3RhdHVzOiAnQ2jGsGEgaW4nIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICBzdG9ja091dFN0YXR1czogJ0NoxrBhIHh14bqldCBraG8nIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICByZXR1cm5TdGF0dXM6ICdDaMawYSB0cuG6oyBow6BuZycgYXMgY29uc3QsXHJcbiAgICAgICAgICAgIGNvZEFtb3VudDogMCwgLy8gV2lsbCBiZSBjYWxjdWxhdGVkIGJ5IFNoaXBwaW5nSW50ZWdyYXRpb24gYmFzZWQgb24gcGF5bWVudHNcclxuICAgICAgICAgICAgcGFja2FnaW5nczogcGFja2FnaW5ncyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIFtTYWxlcyBSZXR1cm5dIE5ldyBvcmRlciBwYXlsb2FkOicsIG5ld09yZGVyUGF5bG9hZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3T3JkZXIgPSBhZGRPcmRlcihuZXdPcmRlclBheWxvYWQgYXMgYW55KTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFtTYWxlcyBSZXR1cm5dIE5ldyBvcmRlciBjcmVhdGVkOicsIG5ld09yZGVyKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAobmV3T3JkZXIpIHtcclxuICAgICAgICAgIG5ld09yZGVyU3lzdGVtSWQgPSBhc1N5c3RlbUlkKG5ld09yZGVyLnN5c3RlbUlkKTtcclxuICAgICAgICAgIC8vIOKchSBTYXZlIGV4Y2hhbmdlIG9yZGVyIHN5c3RlbUlkIHRvIHNhbGVzIHJldHVyblxyXG4gICAgICAgICAgKG5ld0l0ZW1EYXRhIGFzIFNhbGVzUmV0dXJuKS5leGNoYW5nZU9yZGVyU3lzdGVtSWQgPSBuZXdPcmRlclN5c3RlbUlkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfjokgW1NhbGVzIFJldHVybl0gRXhjaGFuZ2Ugb3JkZXIgc3lzdGVtSWQ6JywgbmV3T3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTYWxlcyBSZXR1cm5dIEZhaWxlZCB0byBjcmVhdGUgZXhjaGFuZ2Ugb3JkZXIhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkanVzdCBjdXN0b21lciBkZWJ0IGlmIG5lZWRlZFxyXG4gICAgY29uc3QgY3JlZGl0QW1vdW50ID0gbmV3SXRlbURhdGEudG90YWxSZXR1cm5WYWx1ZSAtIG5ld0l0ZW1EYXRhLmdyYW5kVG90YWxOZXcgLSAobmV3SXRlbURhdGEucmVmdW5kQW1vdW50IHx8IDApO1xyXG4gICAgaWYgKGNyZWRpdEFtb3VudCA+IDApIHtcclxuICAgICAgdXBkYXRlRGVidChuZXdJdGVtRGF0YS5jdXN0b21lclN5c3RlbUlkLCAtY3JlZGl0QW1vdW50KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8g4pyFIG5ld1JldHVybiBhbHJlYWR5IGNyZWF0ZWQgYWJvdmUsIHVzZSBpdCBkaXJlY3RseVxyXG4gICAgLy8g4pyFIE5PVyBjcmVhdGUgdm91Y2hlcnMgd2l0aCBjb3JyZWN0IG9yaWdpbmFsRG9jdW1lbnRJZFxyXG4gICAgLy8gSGFuZGxlIEZpbmFuY2lhbHMgQUZURVIgY3JlYXRpbmcgdGhlIHJldHVyblxyXG4gICAgY29uc3QgZmluYWxBbW91bnQgPSBuZXdJdGVtRGF0YS5maW5hbEFtb3VudDtcclxuXHJcbiAgICBpZiAoZmluYWxBbW91bnQgPCAwICYmIG5ld0l0ZW1EYXRhLnJlZnVuZHMgJiYgbmV3SXRlbURhdGEucmVmdW5kcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZWRWb3VjaGVySWRzOiBTeXN0ZW1JZFtdID0gW107XHJcblxyXG4gICAgICBuZXdJdGVtRGF0YS5yZWZ1bmRzLmZvckVhY2gocmVmdW5kID0+IHtcclxuICAgICAgICBpZiAoIXJlZnVuZC5hbW91bnQgfHwgcmVmdW5kLmFtb3VudCA8PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7IGRvY3VtZW50LCBlcnJvciB9ID0gY3JlYXRlUGF5bWVudERvY3VtZW50KHtcclxuICAgICAgICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgSG/DoG4gdGnhu4FuIMSR4buVaS90cuG6oyBow6BuZyB04burIMSRxqFuICR7b3JkZXIuaWR9IChQaGnhur91OiAke25ld1JldHVybi5pZH0pIHF1YSAke3JlZnVuZC5tZXRob2R9YCxcclxuICAgICAgICAgIHJlY2lwaWVudE5hbWU6IG5ld0l0ZW1EYXRhLmN1c3RvbWVyTmFtZSxcclxuICAgICAgICAgIHJlY2lwaWVudFN5c3RlbUlkOiBuZXdJdGVtRGF0YS5jdXN0b21lclN5c3RlbUlkLFxyXG4gICAgICAgICAgY3VzdG9tZXJTeXN0ZW1JZDogbmV3SXRlbURhdGEuY3VzdG9tZXJTeXN0ZW1JZCxcclxuICAgICAgICAgIGN1c3RvbWVyTmFtZTogbmV3SXRlbURhdGEuY3VzdG9tZXJOYW1lLFxyXG4gICAgICAgICAgcGF5bWVudE1ldGhvZE5hbWU6IHJlZnVuZC5tZXRob2QsXHJcbiAgICAgICAgICBhY2NvdW50U3lzdGVtSWQ6IHJlZnVuZC5hY2NvdW50U3lzdGVtSWQsXHJcbiAgICAgICAgICBwYXltZW50VHlwZU5hbWU6ICdIb8OgbiB0aeG7gW4ga2jDoWNoIGjDoG5nJyxcclxuICAgICAgICAgIGJyYW5jaFN5c3RlbUlkOiBuZXdSZXR1cm4uYnJhbmNoU3lzdGVtSWQsXHJcbiAgICAgICAgICBicmFuY2hOYW1lOiBuZXdSZXR1cm4uYnJhbmNoTmFtZSxcclxuICAgICAgICAgIGNyZWF0ZWRCeTogY3JlYXRvclN5c3RlbUlkLFxyXG4gICAgICAgICAgb3JpZ2luYWxEb2N1bWVudElkOiBuZXdSZXR1cm4uaWQsXHJcbiAgICAgICAgICBsaW5rZWRTYWxlc1JldHVyblN5c3RlbUlkOiBuZXdSZXR1cm4uc3lzdGVtSWQsXHJcbiAgICAgICAgICBsaW5rZWRPcmRlclN5c3RlbUlkOiBuZXdSZXR1cm4ub3JkZXJTeXN0ZW1JZCxcclxuICAgICAgICAgIGNhdGVnb3J5OiAnY29tcGxhaW50X3JlZnVuZCcsXHJcbiAgICAgICAgICBhZmZlY3RzRGVidDogdHJ1ZSwgLy8g4pyFIEhvw6BuIHRp4buBbiBraMOhY2ggaMOgbmcg4bqjbmggaMaw4bufbmcgY8O0bmcgbuG7oyAoZ2nhuqNtIGPDtG5nIG7hu6MpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1NhbGVzIFJldHVybl0gRmFpbGVkIHRvIGNyZWF0ZSBwYXltZW50IHZvdWNoZXI6JywgZXJyb3IpO1xyXG4gICAgICAgICAgdG9hc3QuZXJyb3IoYEtow7RuZyB0aOG7gyB04bqhbyBwaGnhur91IGNoaSBob8OgbiB0aeG7gW46ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgICAgIGNyZWF0ZWRWb3VjaGVySWRzLnB1c2goYXNTeXN0ZW1JZChkb2N1bWVudC5zeXN0ZW1JZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoY3JlYXRlZFZvdWNoZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZShuZXdSZXR1cm4uc3lzdGVtSWQsIHtcclxuICAgICAgICAgIC4uLm5ld1JldHVybixcclxuICAgICAgICAgIHBheW1lbnRWb3VjaGVyU3lzdGVtSWRzOiBjcmVhdGVkVm91Y2hlcklkcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChmaW5hbEFtb3VudCA+IDAgJiYgbmV3SXRlbURhdGEucGF5bWVudHMgJiYgbmV3SXRlbURhdGEucGF5bWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBjcmVhdGVkVm91Y2hlcklkczogU3lzdGVtSWRbXSA9IFtdO1xyXG5cclxuICAgICAgbmV3SXRlbURhdGEucGF5bWVudHMuZm9yRWFjaChwYXltZW50ID0+IHtcclxuICAgICAgICBpZiAoIXBheW1lbnQuYW1vdW50IHx8IHBheW1lbnQuYW1vdW50IDw9IDApIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQsIGVycm9yIH0gPSBjcmVhdGVSZWNlaXB0RG9jdW1lbnQoe1xyXG4gICAgICAgICAgYW1vdW50OiBwYXltZW50LmFtb3VudCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVGh1IHRp4buBbiBjaMOqbmggbOG7h2NoIMSR4buVaSBow6BuZyB04burIMSRxqFuICR7b3JkZXIuaWR9IChQaGnhur91OiAke25ld1JldHVybi5pZH0pYCxcclxuICAgICAgICAgIGN1c3RvbWVyTmFtZTogbmV3UmV0dXJuLmN1c3RvbWVyTmFtZSxcclxuICAgICAgICAgIGN1c3RvbWVyU3lzdGVtSWQ6IG5ld0l0ZW1EYXRhLmN1c3RvbWVyU3lzdGVtSWQsXHJcbiAgICAgICAgICBwYXltZW50TWV0aG9kTmFtZTogcGF5bWVudC5tZXRob2QsXHJcbiAgICAgICAgICBhY2NvdW50U3lzdGVtSWQ6IHBheW1lbnQuYWNjb3VudFN5c3RlbUlkLFxyXG4gICAgICAgICAgcmVjZWlwdFR5cGVOYW1lOiAnVGhhbmggdG/DoW4gY2hvIMSRxqFuIGjDoG5nJyxcclxuICAgICAgICAgIGJyYW5jaFN5c3RlbUlkOiBuZXdSZXR1cm4uYnJhbmNoU3lzdGVtSWQsXHJcbiAgICAgICAgICBicmFuY2hOYW1lOiBuZXdSZXR1cm4uYnJhbmNoTmFtZSxcclxuICAgICAgICAgIGNyZWF0ZWRCeTogY3JlYXRvclN5c3RlbUlkLFxyXG4gICAgICAgICAgb3JpZ2luYWxEb2N1bWVudElkOiBuZXdSZXR1cm4uaWQsXHJcbiAgICAgICAgICBsaW5rZWRTYWxlc1JldHVyblN5c3RlbUlkOiBuZXdSZXR1cm4uc3lzdGVtSWQsXHJcbiAgICAgICAgICBsaW5rZWRPcmRlclN5c3RlbUlkOiBuZXdSZXR1cm4ub3JkZXJTeXN0ZW1JZCxcclxuICAgICAgICAgIGNhdGVnb3J5OiAnc2FsZScsXHJcbiAgICAgICAgICBhZmZlY3RzRGVidDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1NhbGVzIFJldHVybl0gRmFpbGVkIHRvIGNyZWF0ZSByZWNlaXB0IHZvdWNoZXI6JywgZXJyb3IpO1xyXG4gICAgICAgICAgdG9hc3QuZXJyb3IoYEtow7RuZyB0aOG7gyB04bqhbyBwaGnhur91IHRodSDEkeG7lWkgaMOgbmc6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcclxuICAgICAgICAgIGNyZWF0ZWRWb3VjaGVySWRzLnB1c2goYXNTeXN0ZW1JZChkb2N1bWVudC5zeXN0ZW1JZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoY3JlYXRlZFZvdWNoZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZShuZXdSZXR1cm4uc3lzdGVtSWQsIHtcclxuICAgICAgICAgIC4uLm5ld1JldHVybixcclxuICAgICAgICAgIHJlY2VpcHRWb3VjaGVyU3lzdGVtSWRzOiBjcmVhdGVkVm91Y2hlcklkcyxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOKchSBVcGRhdGUgaW52ZW50b3J5IGZvciByZXR1cm5lZCBpdGVtcyBPTkxZIGlmIGlzUmVjZWl2ZWQgPSB0cnVlXHJcbiAgICAvLyDinIUgRm9yIGNvbWJvIHByb2R1Y3RzLCBhZGQgc3RvY2sgdG8gY2hpbGQgcHJvZHVjdHMgaW5zdGVhZFxyXG4gICAgaWYgKG5ld1JldHVybi5pc1JlY2VpdmVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBbU2FsZXMgUmV0dXJuXSBVcGRhdGluZyBpbnZlbnRvcnkgLSBpdGVtcyByZWNlaXZlZCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEV4cGFuZCBjb21ibyBpdGVtcyB0byBjaGlsZCBwcm9kdWN0c1xyXG4gICAgICAgIGNvbnN0IHN0b2NrSXRlbXMgPSBnZXRSZXR1cm5TdG9ja0l0ZW1zKG5ld1JldHVybi5pdGVtcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RvY2tJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgaWYgKGl0ZW0ucXVhbnRpdHkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSB1c2VQcm9kdWN0U3RvcmUuZ2V0U3RhdGUoKS5maW5kQnlJZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0b2NrID0gcHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2hbbmV3UmV0dXJuLmJyYW5jaFN5c3RlbUlkXSB8fCAwO1xyXG4gICAgICAgICAgICB1cGRhdGVJbnZlbnRvcnkoaXRlbS5wcm9kdWN0U3lzdGVtSWQsIG5ld1JldHVybi5icmFuY2hTeXN0ZW1JZCwgaXRlbS5xdWFudGl0eSk7IC8vIEFkZCBzdG9jayBiYWNrXHJcbiAgICAgICAgICAgIGFkZFN0b2NrSGlzdG9yeSh7XHJcbiAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RTeXN0ZW1JZCxcclxuICAgICAgICAgICAgICBkYXRlOiBnZXRDdXJyZW50RGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgZW1wbG95ZWVOYW1lOiBuZXdSZXR1cm4uY3JlYXRvck5hbWUsXHJcbiAgICAgICAgICAgICAgYWN0aW9uOiAnTmjhuq1wIGjDoG5nIHThu6sga2jDoWNoIHRy4bqjJyxcclxuICAgICAgICAgICAgICBxdWFudGl0eUNoYW5nZTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgICBuZXdTdG9ja0xldmVsOiBvbGRTdG9jayArIGl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgZG9jdW1lbnRJZDogbmV3UmV0dXJuLmlkLCAvLyDinIUgVXNlIGJ1c2luZXNzIElEIGZvciBkb2N1bWVudCByZWZlcmVuY2VcclxuICAgICAgICAgICAgICBicmFuY2hTeXN0ZW1JZDogbmV3UmV0dXJuLmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgICAgICAgICAgIGJyYW5jaDogbmV3UmV0dXJuLmJyYW5jaE5hbWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4o+477iPIFtTYWxlcyBSZXR1cm5dIEludmVudG9yeSBOT1QgdXBkYXRlZCAtIHdhaXRpbmcgZm9yIHJlY2VpcHQgY29uZmlybWF0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIG9yaWdpbmFsIG9yZGVyJ3MgcmV0dXJuIHN0YXR1c1xyXG4gICAgY29uc3QgcHJldmlvdXNSZXR1cm5zRm9yT3JkZXIgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbHRlcihyID0+IHIub3JkZXJTeXN0ZW1JZCA9PT0gb3JkZXIuc3lzdGVtSWQpO1xyXG4gICAgY29uc3QgdG90YWxSZXR1cm5lZFF0eSA9IHByZXZpb3VzUmV0dXJuc0Zvck9yZGVyLmZsYXRNYXAociA9PiByLml0ZW1zKS5yZWR1Y2UoKHN1bSwgaXRlbSkgPT4gc3VtICsgaXRlbS5yZXR1cm5RdWFudGl0eSwgMCk7XHJcbiAgICBjb25zdCB0b3RhbE9yZGVyZWRRdHkgPSBvcmRlci5saW5lSXRlbXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIGl0ZW0ucXVhbnRpdHksIDApO1xyXG4gICAgY29uc3QgbmV3UmV0dXJuU3RhdHVzID0gdG90YWxSZXR1cm5lZFF0eSA+PSB0b3RhbE9yZGVyZWRRdHkgPyAnVHLhuqMgaMOgbmcgdG/DoG4gYuG7mScgOiAnVHLhuqMgaMOgbmcgbeG7mXQgcGjhuqduJztcclxuICAgIHVwZGF0ZU9yZGVyKG9yZGVyLnN5c3RlbUlkLCB7IC4uLm9yZGVyLCByZXR1cm5TdGF0dXM6IG5ld1JldHVyblN0YXR1cyB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgbmV3UmV0dXJuLCBuZXdPcmRlclN5c3RlbUlkIH07XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiDinIUgQ29uZmlybSByZWNlaXB0IG9mIHJldHVybmVkIGl0ZW1zIGFuZCB1cGRhdGUgaW52ZW50b3J5XHJcbiAgICogVXNlIHRoaXMgd2hlbiBpc1JlY2VpdmVkIHdhcyBmYWxzZSBpbml0aWFsbHkgYW5kIGl0ZW1zIGFyZSBub3cgcmVjZWl2ZWRcclxuICAgKiDinIUgRm9yIGNvbWJvIHByb2R1Y3RzLCBhZGQgc3RvY2sgdG8gY2hpbGQgcHJvZHVjdHMgaW5zdGVhZFxyXG4gICAqL1xyXG4gIGNvbmZpcm1SZWNlaXB0OiAocmV0dXJuU3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICBjb25zdCBzYWxlc1JldHVybiA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmZpbmRCeUlkKHJldHVyblN5c3RlbUlkKTtcclxuICAgIGlmICghc2FsZXNSZXR1cm4pIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTYWxlcyBSZXR1cm5dIFJldHVybiBub3QgZm91bmQ6JywgcmV0dXJuU3lzdGVtSWQpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ0tow7RuZyB0w6xtIHRo4bqleSBwaGnhur91IHRy4bqjIGjDoG5nJyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoc2FsZXNSZXR1cm4uaXNSZWNlaXZlZCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBbU2FsZXMgUmV0dXJuXSBBbHJlYWR5IHJlY2VpdmVkOicsIHJldHVyblN5c3RlbUlkKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdIw6BuZyDEkcOjIMSRxrDhu6NjIG5o4bqtbiB0csaw4bubYyDEkcOzJyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB7IHVwZGF0ZUludmVudG9yeSB9ID0gdXNlUHJvZHVjdFN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCB7IGFkZEVudHJ5OiBhZGRTdG9ja0hpc3RvcnkgfSA9IHVzZVN0b2NrSGlzdG9yeVN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBcclxuICAgIC8vIOKchSBFeHBhbmQgY29tYm8gaXRlbXMgdG8gY2hpbGQgcHJvZHVjdHNcclxuICAgIGNvbnN0IHN0b2NrSXRlbXMgPSBnZXRSZXR1cm5TdG9ja0l0ZW1zKHNhbGVzUmV0dXJuLml0ZW1zKTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIGludmVudG9yeSBmb3IgYWxsIHJldHVybmVkIGl0ZW1zIChpbmNsdWRpbmcgZXhwYW5kZWQgY29tYm8gY2hpbGRyZW4pXHJcbiAgICBzdG9ja0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLnF1YW50aXR5ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSB1c2VQcm9kdWN0U3RvcmUuZ2V0U3RhdGUoKS5maW5kQnlJZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICAgICAgY29uc3Qgb2xkU3RvY2sgPSBwcm9kdWN0Py5pbnZlbnRvcnlCeUJyYW5jaFtzYWxlc1JldHVybi5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICB1cGRhdGVJbnZlbnRvcnkoaXRlbS5wcm9kdWN0U3lzdGVtSWQsIHNhbGVzUmV0dXJuLmJyYW5jaFN5c3RlbUlkLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICBhZGRTdG9ja0hpc3Rvcnkoe1xyXG4gICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RTeXN0ZW1JZCxcclxuICAgICAgICAgIGRhdGU6IGdldEN1cnJlbnREYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIGVtcGxveWVlTmFtZTogc2FsZXNSZXR1cm4uY3JlYXRvck5hbWUsXHJcbiAgICAgICAgICBhY3Rpb246ICdOaOG6rXAgaMOgbmcgdOG7qyBraMOhY2ggdHLhuqMgKHjDoWMgbmjhuq1uKScsXHJcbiAgICAgICAgICBxdWFudGl0eUNoYW5nZTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgIG5ld1N0b2NrTGV2ZWw6IG9sZFN0b2NrICsgaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgIGRvY3VtZW50SWQ6IHNhbGVzUmV0dXJuLmlkLFxyXG4gICAgICAgICAgYnJhbmNoU3lzdGVtSWQ6IHNhbGVzUmV0dXJuLmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgICAgICAgYnJhbmNoOiBzYWxlc1JldHVybi5icmFuY2hOYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gcmVjb3JkXHJcbiAgICBiYXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGUocmV0dXJuU3lzdGVtSWQsIHtcclxuICAgICAgLi4uc2FsZXNSZXR1cm4sXHJcbiAgICAgIGlzUmVjZWl2ZWQ6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ+KchSBbU2FsZXMgUmV0dXJuXSBSZWNlaXB0IGNvbmZpcm1lZCBhbmQgaW52ZW50b3J5IHVwZGF0ZWQ6JywgcmV0dXJuU3lzdGVtSWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ8SQw6MgeMOhYyBuaOG6rW4gbmjhuq1uIGjDoG5nIHbDoCBj4bqtcCBuaOG6rXQgdOG7k24ga2hvJyB9O1xyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBFeHBvcnQgdHlwZWQgaG9va1xyXG5leHBvcnQgY29uc3QgdXNlU2FsZXNSZXR1cm5TdG9yZSA9ICgpOiBhbnkgPT4ge1xyXG4gIGNvbnN0IHN0YXRlID0gYmFzZVN0b3JlKCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgLi4uYXVnbWVudGVkTWV0aG9kcyxcclxuICB9O1xyXG59O1xyXG5cclxuLy8gRXhwb3J0IGdldFN0YXRlIGZvciBub24taG9vayB1c2FnZVxyXG51c2VTYWxlc1JldHVyblN0b3JlLmdldFN0YXRlID0gKCk6IGFueSA9PiB7XHJcbiAgY29uc3Qgc3RhdGUgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKTtcclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICAuLi5hdWdtZW50ZWRNZXRob2RzLFxyXG4gIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJmb3JtYXREYXRlQ3VzdG9tIiwiZ2V0Q3VycmVudERhdGUiLCJjcmVhdGVDcnVkU3RvcmUiLCJ0b2FzdCIsInVzZU9yZGVyU3RvcmUiLCJ1c2VQcm9kdWN0U3RvcmUiLCJ1c2VTdG9ja0hpc3RvcnlTdG9yZSIsInVzZUN1c3RvbWVyU3RvcmUiLCJjcmVhdGVQYXltZW50RG9jdW1lbnQiLCJjcmVhdGVSZWNlaXB0RG9jdW1lbnQiLCJ1c2VTaGlwcGluZ1BhcnRuZXJTdG9yZSIsImFzQnVzaW5lc3NJZCIsImFzU3lzdGVtSWQiLCJpc0NvbWJvUHJvZHVjdCIsImdlbmVyYXRlU3lzdGVtSWQiLCJnZXRNYXhTeXN0ZW1JZENvdW50ZXIiLCJnZXRSZXR1cm5TdG9ja0l0ZW1zIiwicmV0dXJuSXRlbXMiLCJmaW5kQnlJZCIsImdldFN0YXRlIiwiZXhwYW5kZWRJdGVtcyIsImZvckVhY2giLCJpdGVtIiwicHJvZHVjdCIsInByb2R1Y3RTeXN0ZW1JZCIsImNvbWJvSXRlbXMiLCJjb21ib0l0ZW0iLCJjaGlsZFByb2R1Y3QiLCJwdXNoIiwicHJvZHVjdE5hbWUiLCJuYW1lIiwicXVhbnRpdHkiLCJyZXR1cm5RdWFudGl0eSIsImJhc2VTdG9yZSIsImFwaUVuZHBvaW50Iiwib3JpZ2luYWxBZGQiLCJhZGQiLCJhdWdtZW50ZWRNZXRob2RzIiwiYWRkV2l0aFNpZGVFZmZlY3RzIiwib3JkZXJTeXN0ZW1JZCIsIm9yZGVyQnVzaW5lc3NJZCIsIm9yZGVySWQiLCJjdXN0b21lclN5c3RlbUlkIiwiYnJhbmNoU3lzdGVtSWQiLCJjcmVhdG9yU3lzdGVtSWQiLCJjcmVhdG9ySWQiLCJleGNoYW5nZU9yZGVyU3lzdGVtSWQiLCJ1bmRlZmluZWQiLCJhY2NvdW50U3lzdGVtSWQiLCJwYXltZW50Vm91Y2hlclN5c3RlbUlkIiwicGF5bWVudFZvdWNoZXJTeXN0ZW1JZHMiLCJtYXAiLCJyZWNlaXB0Vm91Y2hlclN5c3RlbUlkcyIsImZvcm1hdHRlZEl0ZW1zIiwiaXRlbXMiLCJsaW5lSXRlbSIsInByb2R1Y3RJZCIsImZvcm1hdHRlZFBheW1lbnRzIiwicGF5bWVudHMiLCJwYXltZW50IiwiZm9ybWF0dGVkUmVmdW5kcyIsInJlZnVuZHMiLCJyZWZ1bmQiLCJuZXdJdGVtRGF0YSIsImlkIiwiY3VzdG9tZXJOYW1lIiwiYnJhbmNoTmFtZSIsInJldHVybkRhdGUiLCJyZWFzb24iLCJub3RlIiwibm90ZXMiLCJyZWZlcmVuY2UiLCJ0b3RhbFJldHVyblZhbHVlIiwiaXNSZWNlaXZlZCIsImV4Y2hhbmdlSXRlbXMiLCJzdWJ0b3RhbE5ldyIsInNoaXBwaW5nRmVlTmV3IiwiZGlzY291bnROZXciLCJkaXNjb3VudE5ld1R5cGUiLCJncmFuZFRvdGFsTmV3IiwiZGVsaXZlcnlNZXRob2QiLCJzaGlwcGluZ1BhcnRuZXJJZCIsInNoaXBwaW5nU2VydmljZUlkIiwic2hpcHBpbmdBZGRyZXNzIiwicGFja2FnZUluZm8iLCJjb25maWd1cmF0aW9uIiwiZmluYWxBbW91bnQiLCJyZWZ1bmRNZXRob2QiLCJyZWZ1bmRBbW91bnQiLCJjcmVhdG9yTmFtZSIsInVwZGF0ZSIsInVwZGF0ZU9yZGVyIiwiZmluZE9yZGVyQnlJZCIsImFkZE9yZGVyIiwidXBkYXRlSW52ZW50b3J5IiwiYWRkRW50cnkiLCJhZGRTdG9ja0hpc3RvcnkiLCJ1cGRhdGVEZWJ0IiwiaW5jcmVtZW50UmV0dXJuU3RhdHMiLCJvcmRlciIsIm5ld1JldHVybiIsIm5ld09yZGVyU3lzdGVtSWQiLCJ0b3RhbFJldHVyblF0eSIsInJlZHVjZSIsInN1bSIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJleGNoYW5nZU9yZGVyUGF5bWVudHMiLCJwIiwibWV0aG9kIiwiYW1vdW50IiwiZmluYWxNYWluU3RhdHVzIiwiZmluYWxEZWxpdmVyeVN0YXR1cyIsInBhY2thZ2luZ3MiLCJub3ciLCJQQUNLQUdJTkdfU1lTVEVNX0lEX1BSRUZJWCIsImFsbE9yZGVycyIsImRhdGEiLCJhbGxQYWNrYWdpbmdzIiwiZmxhdE1hcCIsIm8iLCJtYXhQYWNrYWdpbmdDb3VudGVyIiwicGFja2FnaW5nQ291bnRlciIsImdldE5leHRQYWNrYWdpbmdTeXN0ZW1JZCIsImlzUGlja3VwIiwiaXNTaGlwcGluZ1BhcnRuZXIiLCJzeXN0ZW1JZCIsInJlcXVlc3REYXRlIiwicmVxdWVzdGluZ0VtcGxveWVlSWQiLCJyZXF1ZXN0aW5nRW1wbG95ZWVOYW1lIiwic3RhdHVzIiwicHJpbnRTdGF0dXMiLCJkZWxpdmVyeVN0YXR1cyIsInBhcnRuZXJzIiwicGFydG5lciIsImZpbmQiLCJzZXJ2aWNlIiwic2VydmljZXMiLCJzIiwiY29uZmlybURhdGUiLCJjb25maXJtaW5nRW1wbG95ZWVJZCIsImNvbmZpcm1pbmdFbXBsb3llZU5hbWUiLCJjYXJyaWVyIiwidHJhY2tpbmdDb2RlIiwiRGF0ZSIsInNoaXBwaW5nRmVlVG9QYXJ0bmVyIiwiY29kQW1vdW50IiwicGF5ZXIiLCJ3ZWlnaHQiLCJkaW1lbnNpb25zIiwibmV3T3JkZXJQYXlsb2FkIiwic2FsZXNwZXJzb25JZCIsInNhbGVzcGVyc29uIiwib3JkZXJEYXRlIiwibGluZUl0ZW1zIiwic3VidG90YWwiLCJzaGlwcGluZ0ZlZSIsInRheCIsImdyYW5kVG90YWwiLCJsaW5rZWRTYWxlc1JldHVybklkIiwibGlua2VkU2FsZXNSZXR1cm5TeXN0ZW1JZCIsImxpbmtlZFNhbGVzUmV0dXJuVmFsdWUiLCJzb3VyY2VTYWxlc1JldHVybklkIiwicGF5bWVudFN0YXR1cyIsInN0b2NrT3V0U3RhdHVzIiwicmV0dXJuU3RhdHVzIiwibmV3T3JkZXIiLCJlcnJvciIsImNyZWRpdEFtb3VudCIsImNyZWF0ZWRWb3VjaGVySWRzIiwiZG9jdW1lbnQiLCJkZXNjcmlwdGlvbiIsInJlY2lwaWVudE5hbWUiLCJyZWNpcGllbnRTeXN0ZW1JZCIsInBheW1lbnRNZXRob2ROYW1lIiwicGF5bWVudFR5cGVOYW1lIiwiY3JlYXRlZEJ5Iiwib3JpZ2luYWxEb2N1bWVudElkIiwibGlua2VkT3JkZXJTeXN0ZW1JZCIsImNhdGVnb3J5IiwiYWZmZWN0c0RlYnQiLCJyZWNlaXB0VHlwZU5hbWUiLCJzdG9ja0l0ZW1zIiwib2xkU3RvY2siLCJpbnZlbnRvcnlCeUJyYW5jaCIsImRhdGUiLCJ0b0lTT1N0cmluZyIsImVtcGxveWVlTmFtZSIsImFjdGlvbiIsInF1YW50aXR5Q2hhbmdlIiwibmV3U3RvY2tMZXZlbCIsImRvY3VtZW50SWQiLCJicmFuY2giLCJwcmV2aW91c1JldHVybnNGb3JPcmRlciIsImZpbHRlciIsInIiLCJ0b3RhbFJldHVybmVkUXR5IiwidG90YWxPcmRlcmVkUXR5IiwibmV3UmV0dXJuU3RhdHVzIiwiY29uZmlybVJlY2VpcHQiLCJyZXR1cm5TeXN0ZW1JZCIsInNhbGVzUmV0dXJuIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJ3YXJuIiwidXNlU2FsZXNSZXR1cm5TdG9yZSIsInN0YXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/sales-returns/store.ts\n"));

/***/ })

});