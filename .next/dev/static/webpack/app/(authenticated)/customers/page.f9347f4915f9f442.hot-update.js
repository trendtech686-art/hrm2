"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/customers/page",{

/***/ "(app-pages-browser)/./features/orders/store.ts":
/*!**********************************!*\
  !*** ./features/orders/store.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOrderStore: () => (/* binding */ useOrderStore)\n/* harmony export */ });\n/* harmony import */ var _lib_date_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/date-utils */ \"(app-pages-browser)/./lib/date-utils.ts\");\n/* harmony import */ var _lib_api_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/api-config */ \"(app-pages-browser)/./lib/api-config.ts\");\n/* harmony import */ var _lib_store_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/store-factory */ \"(app-pages-browser)/./lib/store-factory.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _employees_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../employees/store */ \"(app-pages-browser)/./features/employees/store.ts\");\n/* harmony import */ var _products_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../products/store */ \"(app-pages-browser)/./features/products/store.ts\");\n/* harmony import */ var _products_combo_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../products/combo-utils */ \"(app-pages-browser)/./features/products/combo-utils.ts\");\n/* harmony import */ var _stock_history_store__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../stock-history/store */ \"(app-pages-browser)/./features/stock-history/store.ts\");\n/* harmony import */ var _customers_store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../customers/store */ \"(app-pages-browser)/./features/customers/store.ts\");\n/* harmony import */ var _settings_receipt_types_store__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../settings/receipt-types/store */ \"(app-pages-browser)/./features/settings/receipt-types/store.ts\");\n/* harmony import */ var _cashbook_store__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../cashbook/store */ \"(app-pages-browser)/./features/cashbook/store.ts\");\n/* harmony import */ var _receipts_store__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../receipts/store */ \"(app-pages-browser)/./features/receipts/store.ts\");\n/* harmony import */ var _sales_returns_store__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../sales-returns/store */ \"(app-pages-browser)/./features/sales-returns/store.ts\");\n/* harmony import */ var _finance_document_helpers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../finance/document-helpers */ \"(app-pages-browser)/./features/finance/document-helpers.ts\");\n/* harmony import */ var _shipments_store__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../shipments/store */ \"(app-pages-browser)/./features/shipments/store.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n/* harmony import */ var _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../settings/sales/sales-management-store */ \"(app-pages-browser)/./features/settings/sales/sales-management-store.ts\");\n/* harmony import */ var _lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../lib/activity-history-helper */ \"(app-pages-browser)/./lib/activity-history-helper.ts\");\n// persist middleware removed - database is now source of truth\n\n\n\n\n\n\n// REMOVED: Voucher store no longer exists - using Payment/Receipt stores instead\n\n\n\n\n\n// REMOVED: import type { Voucher } from '../vouchers/types';\n\n\n\n\n\n\n\n\n// ‚úÖ Helper to get branch systemId\nconst getBranchId = (order)=>order.branchSystemId;\nconst deliveryStatusesBlockedForCancellation = [\n    'ƒêang giao h√†ng',\n    'ƒê√£ giao h√†ng',\n    'Ch·ªù giao l·∫°i'\n];\nconst IN_STORE_PICKUP_PREFIX = 'INSTORE';\nconst PACKAGING_CODE_PREFIX = 'DG';\nconst PACKAGING_SYSTEM_ID_PREFIX = 'PACKAGE';\n// ‚úÖ Track packaging systemId counter globally\nlet packagingSystemIdCounter = 0;\n// ‚úÖ Initialize counter from all existing packagings across all orders\nconst initPackagingCounter = (orders)=>{\n    const allPackagings = orders.flatMap((o)=>o.packagings || []);\n    packagingSystemIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_4__.getMaxSystemIdCounter)(allPackagings, PACKAGING_SYSTEM_ID_PREFIX);\n};\n// ‚úÖ Generate next packaging systemId\nconst getNextPackagingSystemId = ()=>{\n    packagingSystemIdCounter++;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_4__.generateSystemId)('packaging', packagingSystemIdCounter));\n};\nconst getPackagingSuffixFromOrderId = (orderId)=>{\n    if (!orderId) return '';\n    const rawValue = `${orderId}`;\n    const suffix = rawValue.replace(/^[A-Z-]+/, '');\n    return suffix || rawValue;\n};\n// Count only active packagings (not cancelled) for numbering\nconst getActivePackagingCount = (packagings)=>{\n    return packagings.filter((p)=>p.status !== 'H·ªßy ƒë√≥ng g√≥i').length;\n};\nconst buildPackagingBusinessId = (orderId, activeIndex, activeCount)=>{\n    const suffix = getPackagingSuffixFromOrderId(orderId);\n    const baseCode = `${PACKAGING_CODE_PREFIX}${suffix || '000000'}`;\n    // Only add suffix if there are multiple active packagings\n    if (activeCount > 1 && activeIndex > 0) {\n        const paddedIndex = String(activeIndex + 1).padStart(2, '0');\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asBusinessId)(`${baseCode}-${paddedIndex}`);\n    }\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asBusinessId)(baseCode);\n};\nconst getReturnedValueForOrder = (orderSystemId)=>{\n    return _sales_returns_store__WEBPACK_IMPORTED_MODULE_13__.useSalesReturnStore.getState().data.filter((sr)=>sr.orderSystemId === orderSystemId).reduce((sum, sr)=>sum + sr.totalReturnValue, 0);\n};\nconst calculateActualDebt = (order)=>{\n    const totalReturnedValue = getReturnedValueForOrder(order.systemId);\n    return Math.max(order.grandTotal - totalReturnedValue, 0);\n};\nconst calculateTotalPaid = (payments)=>{\n    return payments.reduce((sum, payment)=>sum + payment.amount, 0);\n};\nconst getOrderOutstandingAmount = (order)=>{\n    const actualDebt = calculateActualDebt(order);\n    const totalPaid = calculateTotalPaid(order.payments ?? []);\n    return Math.max(actualDebt - totalPaid, 0);\n};\nconst applyPaymentToOrder = (order, payment)=>{\n    const updatedPayments = [\n        ...order.payments ?? [],\n        payment\n    ];\n    const totalPaid = calculateTotalPaid(updatedPayments);\n    const actualDebt = calculateActualDebt(order);\n    let newPaymentStatus = 'Ch∆∞a thanh to√°n';\n    if (totalPaid >= actualDebt) {\n        newPaymentStatus = 'Thanh to√°n to√†n b·ªô';\n    } else if (totalPaid > 0) {\n        newPaymentStatus = 'Thanh to√°n 1 ph·∫ßn';\n    }\n    const wasCompleted = order.status === 'Ho√†n th√†nh';\n    let newStatus = order.status;\n    let newCompletedDate = order.completedDate;\n    if (newPaymentStatus === 'Thanh to√°n to√†n b·ªô' && order.deliveryStatus === 'ƒê√£ giao h√†ng') {\n        newStatus = 'Ho√†n th√†nh';\n        newCompletedDate = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n        if (!wasCompleted) {\n            const { incrementOrderStats } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n            incrementOrderStats(order.customerSystemId, order.grandTotal);\n        }\n    }\n    const { updateDebtTransactionPayment } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n    updateDebtTransactionPayment(order.customerSystemId, order.id, payment.amount);\n    return {\n        ...order,\n        payments: updatedPayments,\n        paymentStatus: newPaymentStatus,\n        status: newStatus,\n        completedDate: newCompletedDate,\n        paidAmount: totalPaid\n    };\n};\nconst shouldAutoAllocateReceipt = (receipt)=>{\n    return receipt.status === 'completed' && receipt.affectsDebt && !!receipt.customerSystemId && !receipt.linkedOrderSystemId;\n};\nconst getAllocatedAmount = (receipt)=>{\n    return receipt.orderAllocations?.reduce((sum, allocation)=>sum + allocation.amount, 0) ?? 0;\n};\nconst autoAllocateReceiptToOrders = (receipt)=>{\n    if (!shouldAutoAllocateReceipt(receipt)) {\n        return;\n    }\n    const remainingAmount = receipt.amount - getAllocatedAmount(receipt);\n    if (remainingAmount <= 0) {\n        return;\n    }\n    const candidateOrders = baseStore.getState().data.filter((order)=>order.customerSystemId === receipt.customerSystemId && order.status !== 'ƒê√£ h·ªßy').map((order)=>({\n            order,\n            outstanding: getOrderOutstandingAmount(order)\n        })).filter((entry)=>entry.outstanding > 0).sort((a, b)=>{\n        const aTime = a.order.orderDate ? new Date(a.order.orderDate).getTime() : 0;\n        const bTime = b.order.orderDate ? new Date(b.order.orderDate).getTime() : 0;\n        return aTime - bTime;\n    });\n    if (!candidateOrders.length) {\n        return;\n    }\n    let amountToDistribute = remainingAmount;\n    const updatedOrders = new Map();\n    const allocationEntries = [];\n    for (const { order } of candidateOrders){\n        if (amountToDistribute <= 0) {\n            break;\n        }\n        const currentOrderState = updatedOrders.get(order.systemId) ?? order;\n        const outstanding = getOrderOutstandingAmount(currentOrderState);\n        if (outstanding <= 0) {\n            continue;\n        }\n        const allocationAmount = Math.min(outstanding, amountToDistribute);\n        if (allocationAmount <= 0) {\n            continue;\n        }\n        const paymentEntry = {\n            systemId: receipt.systemId,\n            id: receipt.id,\n            date: receipt.date,\n            amount: allocationAmount,\n            method: receipt.paymentMethodName,\n            createdBy: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(receipt.createdBy),\n            description: receipt.description ?? `Thanh to√°n t·ª´ phi·∫øu thu ${receipt.id}`\n        };\n        const updatedOrder = applyPaymentToOrder(currentOrderState, paymentEntry);\n        updatedOrders.set(order.systemId, updatedOrder);\n        allocationEntries.push({\n            orderSystemId: order.systemId,\n            orderId: order.id,\n            amount: allocationAmount\n        });\n        amountToDistribute -= allocationAmount;\n    }\n    if (!allocationEntries.length) {\n        return;\n    }\n    baseStore.setState((state)=>{\n        const data = state.data.map((order)=>updatedOrders.get(order.systemId) ?? order);\n        return {\n            data\n        };\n    });\n    const receiptStore = _receipts_store__WEBPACK_IMPORTED_MODULE_12__.useReceiptStore.getState();\n    const latestReceipt = receiptStore.findById(receipt.systemId);\n    if (!latestReceipt) {\n        return;\n    }\n    receiptStore.update(receipt.systemId, {\n        ...latestReceipt,\n        orderAllocations: [\n            ...latestReceipt.orderAllocations ?? [],\n            ...allocationEntries\n        ]\n    });\n};\nconst ensureOrderPackagingIdentifiers = (order)=>{\n    if (!order.packagings || order.packagings.length === 0) {\n        return null;\n    }\n    // Count only active packagings for proper numbering\n    const activePackagings = order.packagings.filter((p)=>p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n    const activeCount = activePackagings.length;\n    let changed = false;\n    let activeIndex = 0;\n    const updatedPackagings = order.packagings.map((pkg, idx)=>{\n        const isCancelled = pkg.status === 'H·ªßy ƒë√≥ng g√≥i';\n        const hasId = typeof pkg.id === 'string' && pkg.id.trim().length > 0;\n        // ‚úÖ Check for temp systemId or old format (PKG_)\n        const hasTempOrOldSystemId = pkg.systemId?.startsWith('PKG_TEMP_') || pkg.systemId?.startsWith('PKG_');\n        const hasValidSystemId = pkg.systemId?.startsWith(PACKAGING_SYSTEM_ID_PREFIX);\n        const shouldFixTracking = pkg.deliveryMethod === 'Nh·∫≠n t·∫°i c·ª≠a h√†ng' && pkg.trackingCode === `${IN_STORE_PICKUP_PREFIX}-`;\n        // For cancelled packagings, keep existing ID\n        if (isCancelled) {\n            if (!hasId || hasTempOrOldSystemId && !hasValidSystemId) {\n                // Still need to assign an ID if missing\n                const nextPkg = {\n                    ...pkg\n                };\n                if (!hasId) {\n                    nextPkg.id = buildPackagingBusinessId(order.id, 0, 1);\n                }\n                if (hasTempOrOldSystemId && !hasValidSystemId) {\n                    nextPkg.systemId = getNextPackagingSystemId();\n                }\n                changed = true;\n                return nextPkg;\n            }\n            return pkg;\n        }\n        // For active packagings, use activeIndex for numbering\n        const currentActiveIndex = activeIndex;\n        activeIndex++;\n        if (hasId && !shouldFixTracking && hasValidSystemId) {\n            return pkg;\n        }\n        const nextPkg = {\n            ...pkg\n        };\n        if (!hasId) {\n            nextPkg.id = buildPackagingBusinessId(order.id, currentActiveIndex, activeCount);\n            changed = true;\n        }\n        // ‚úÖ Fix temporary/old systemId to proper format PACKAGE000001\n        if (hasTempOrOldSystemId && !hasValidSystemId) {\n            nextPkg.systemId = getNextPackagingSystemId();\n            changed = true;\n        }\n        if (shouldFixTracking) {\n            const resolvedId = nextPkg.id ?? buildPackagingBusinessId(order.id, currentActiveIndex, activeCount);\n            nextPkg.trackingCode = `${IN_STORE_PICKUP_PREFIX}-${resolvedId}`;\n            changed = true;\n        }\n        return nextPkg;\n    });\n    return changed ? {\n        ...order,\n        packagings: updatedPackagings\n    } : null;\n};\nconst ensureCancellationAllowed = (order, actionLabel)=>{\n    if (!order) return false;\n    const { allowCancelAfterExport } = _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__.useSalesManagementSettingsStore.getState();\n    if (allowCancelAfterExport) {\n        return true;\n    }\n    const hasLeftWarehouse = order.stockOutStatus === 'Xu·∫•t kho to√†n b·ªô' || deliveryStatusesBlockedForCancellation.includes(order.deliveryStatus);\n    if (hasLeftWarehouse) {\n        alert(`Kh√¥ng th·ªÉ ${actionLabel} v√¨ ƒë∆°n h√†ng ƒë√£ xu·∫•t kho. V√†o C·∫•u h√¨nh b√°n h√†ng -> Thi·∫øt l·∫≠p qu·∫£n l√Ω b√°n h√†ng v√† b·∫≠t \"Cho ph√©p h·ªßy ƒë∆°n h√†ng sau khi xu·∫•t kho\".`);\n        return false;\n    }\n    return true;\n};\nconst processLineItemStock = (lineItem, branchSystemId, operation, orderQuantity = 1 // S·ªë l∆∞·ª£ng ƒë·∫∑t c·ªßa line item\n)=>{\n    const { findById: findProductById, commitStock, uncommitStock, dispatchStock, completeDelivery, returnStockFromTransit } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n    const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(lineItem.productSystemId));\n    // X√°c ƒë·ªãnh danh s√°ch items c·∫ßn x·ª≠ l√Ω (SP con n·∫øu combo, ho·∫∑c ch√≠nh SP n·∫øu th∆∞·ªùng)\n    const itemsToProcess = [];\n    if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n        // Combo: x·ª≠ l√Ω t·∫•t c·∫£ SP con\n        product.comboItems.forEach((comboItem)=>{\n            itemsToProcess.push({\n                productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId),\n                quantity: orderQuantity * comboItem.quantity\n            });\n        });\n    } else {\n        // S·∫£n ph·∫©m th∆∞·ªùng\n        itemsToProcess.push({\n            productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(lineItem.productSystemId),\n            quantity: orderQuantity\n        });\n    }\n    // Th·ª±c hi·ªán operation cho t·ª´ng item\n    itemsToProcess.forEach((item)=>{\n        const branchId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(branchSystemId);\n        switch(operation){\n            case 'commit':\n                commitStock(item.productSystemId, branchId, item.quantity);\n                break;\n            case 'uncommit':\n                uncommitStock(item.productSystemId, branchId, item.quantity);\n                break;\n            case 'dispatch':\n                dispatchStock(item.productSystemId, branchId, item.quantity);\n                break;\n            case 'complete':\n                completeDelivery(item.productSystemId, branchId, item.quantity);\n                break;\n            case 'return':\n                returnStockFromTransit(item.productSystemId, branchId, item.quantity);\n                break;\n        }\n    });\n    return itemsToProcess; // Return ƒë·ªÉ c√≥ th·ªÉ d√πng cho stock history\n};\n/**\r\n * ‚úÖ Helper ƒë·ªÉ l·∫•y danh s√°ch stock items t·ª´ line items (m·ªü r·ªông combo th√†nh SP con)\r\n * D√πng trong webhook GHTK ho·∫∑c c√°c thao t√°c batch\r\n */ const getComboStockItems = (lineItems)=>{\n    const { findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n    const stockItems = [];\n    lineItems.forEach((item)=>{\n        const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId));\n        if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n            // Combo: m·ªü r·ªông th√†nh SP con\n            product.comboItems.forEach((comboItem)=>{\n                stockItems.push({\n                    productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId),\n                    quantity: item.quantity * comboItem.quantity\n                });\n            });\n        } else {\n            // S·∫£n ph·∫©m th∆∞·ªùng\n            stockItems.push({\n                productSystemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId),\n                quantity: item.quantity\n            });\n        }\n    });\n    return stockItems;\n};\nconst createOrderRefundVoucher = (order, amount, employeeId)=>{\n    const lastPositivePayment = [\n        ...order.payments ?? []\n    ].reverse().find((p)=>p.amount > 0);\n    const { document, error } = (0,_finance_document_helpers__WEBPACK_IMPORTED_MODULE_14__.createPaymentDocument)({\n        amount,\n        description: `Ho√†n ti·ªÅn do h·ªßy ƒë∆°n ${order.id}`,\n        recipientName: order.customerName,\n        recipientSystemId: order.customerSystemId,\n        customerSystemId: order.customerSystemId,\n        customerName: order.customerName,\n        branchSystemId: order.branchSystemId,\n        branchName: order.branchName,\n        createdBy: employeeId,\n        paymentMethodName: lastPositivePayment?.method || 'Ti·ªÅn m·∫∑t',\n        paymentTypeName: 'Ho√†n ti·ªÅn kh√°ch h√†ng',\n        originalDocumentId: order.id,\n        linkedOrderSystemId: order.systemId,\n        affectsDebt: true,\n        category: 'other'\n    });\n    if (!document) {\n        console.error('[cancelOrder] Kh√¥ng th·ªÉ t·∫°o phi·∫øu chi ho√†n ti·ªÅn', error);\n        return null;\n    }\n    return document;\n};\n// REMOVED: initialDataOmit transformation - database is source of truth\nconst initialData = [];\nconst baseStore = (0,_lib_store_factory__WEBPACK_IMPORTED_MODULE_2__.createCrudStore)([], 'orders', {\n    businessIdField: 'id',\n    apiEndpoint: '/api/orders',\n    getCurrentUser: ()=>{\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)((0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_16__.getCurrentUserSystemId)());\n    }\n});\n// ‚úÖ API Sync helpers\nconst API_ENDPOINT = '/api/orders';\nconst syncToApi = {\n    create: async (order)=>{\n        try {\n            const response = await fetch(API_ENDPOINT, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(order)\n            });\n            if (!response.ok) console.warn('[Order API] Create sync failed');\n            else console.log('[Order API] Created:', order.systemId);\n        } catch (e) {\n            console.warn('[Order API] Create sync error:', e);\n        }\n    },\n    update: async (systemId, updates)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'PATCH',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(updates)\n            });\n            if (!response.ok) console.warn('[Order API] Update sync failed');\n            else console.log('[Order API] Updated:', systemId);\n        } catch (e) {\n            console.warn('[Order API] Update sync error:', e);\n        }\n    },\n    delete: async (systemId, hard = false)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}`, {\n                method: 'DELETE',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    hard\n                })\n            });\n            if (!response.ok) console.warn('[Order API] Delete sync failed');\n            else console.log('[Order API] Deleted:', systemId);\n        } catch (e) {\n            console.warn('[Order API] Delete sync error:', e);\n        }\n    },\n    restore: async (systemId)=>{\n        try {\n            const response = await fetch(`${API_ENDPOINT}/${systemId}/restore`, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) console.warn('[Order API] Restore sync failed');\n            else console.log('[Order API] Restored:', systemId);\n        } catch (e) {\n            console.warn('[Order API] Restore sync error:', e);\n        }\n    }\n};\n// ‚úÖ Wrap base store methods with API sync\nconst originalAdd = baseStore.getState().add;\nconst originalUpdate = baseStore.getState().update;\nconst originalRemove = baseStore.getState().remove;\nconst originalHardDelete = baseStore.getState().hardDelete;\nconst originalRestore = baseStore.getState().restore;\nbaseStore.setState({\n    add: (item)=>{\n        const result = originalAdd(item);\n        syncToApi.create(result);\n        return result;\n    },\n    update: (systemId, updates)=>{\n        originalUpdate(systemId, updates);\n        syncToApi.update(systemId, updates);\n    },\n    remove: (systemId)=>{\n        originalRemove(systemId);\n        syncToApi.delete(systemId, false);\n    },\n    hardDelete: (systemId)=>{\n        originalHardDelete(systemId);\n        syncToApi.delete(systemId, true);\n    },\n    restore: (systemId)=>{\n        originalRestore(systemId);\n        syncToApi.restore(systemId);\n    }\n});\n// ‚úÖ MIGRATION: Ensure all orders have paidAmount field (backward compatibility)\nbaseStore.setState((state)=>({\n        data: state.data.map((order)=>({\n                ...order,\n                paidAmount: order.paidAmount ?? 0\n            }))\n    }));\n// ‚úÖ MIGRATION: Merge seed data - add new orders from initialData if not exist in persisted store\nbaseStore.setState((state)=>{\n    const existingIds = new Set(state.data.map((o)=>o.systemId));\n    const newOrders = initialData.filter((o)=>!existingIds.has(o.systemId));\n    if (newOrders.length > 0) {\n        return {\n            data: [\n                ...state.data,\n                ...newOrders\n            ]\n        };\n    }\n    return state;\n});\n// ‚úÖ MIGRATION: Fix order status - orders with full payment and delivery should be \"Ho√†n th√†nh\"\nbaseStore.setState((state)=>({\n        data: state.data.map((order)=>{\n            // If order is already completed or cancelled, skip\n            if (order.status === 'Ho√†n th√†nh' || order.status === 'ƒê√£ h·ªßy') {\n                return order;\n            }\n            // Check if all active packagings are delivered\n            const activePackagings = order.packagings.filter((p)=>p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n            const isAllDelivered = activePackagings.length > 0 && activePackagings.every((p)=>p.deliveryStatus === 'ƒê√£ giao h√†ng');\n            // If fully paid and fully delivered, update status to \"Ho√†n th√†nh\"\n            if (order.paymentStatus === 'Thanh to√°n to√†n b·ªô' && (isAllDelivered || order.deliveryStatus === 'ƒê√£ giao h√†ng')) {\n                return {\n                    ...order,\n                    status: 'Ho√†n th√†nh',\n                    completedDate: order.completedDate || (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date())\n                };\n            }\n            return order;\n        })\n    }));\nconst originalAddWithStock = baseStore.getState().add;\nbaseStore.setState({\n    add: (item)=>{\n        const { commitStock, findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n        const userInfo = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.getCurrentUserInfo)();\n        const newItem = originalAddWithStock(item);\n        if (newItem) {\n            const hydratedPackagings = ensureOrderPackagingIdentifiers(newItem);\n            if (hydratedPackagings) {\n                Object.assign(newItem, hydratedPackagings);\n                baseStore.setState((state)=>({\n                        data: state.data.map((order)=>order.systemId === hydratedPackagings.systemId ? hydratedPackagings : order)\n                    }));\n            }\n            newItem.lineItems.forEach((li)=>{\n                const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(li.productSystemId));\n                // ‚úÖ X·ª≠ l√Ω combo: commit stock c·ªßa SP con thay v√¨ combo\n                if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n                    product.comboItems.forEach((comboItem)=>{\n                        // Commit stock = s·ªë l∆∞·ª£ng combo √ó s·ªë l∆∞·ª£ng SP con trong combo\n                        const totalQuantity = li.quantity * comboItem.quantity;\n                        commitStock((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId), (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(newItem.branchSystemId), totalQuantity);\n                    });\n                } else {\n                    // S·∫£n ph·∫©m th∆∞·ªùng: commit stock nh∆∞ b√¨nh th∆∞·ªùng\n                    commitStock((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(li.productSystemId), (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(newItem.branchSystemId), li.quantity);\n                }\n            });\n            // ‚úÖ C·∫≠p nh·∫≠t lastPurchaseDate khi t·∫°o ƒë∆°n m·ªõi (ƒë·ªÉ SLA/churn risk ho·∫°t ƒë·ªông ƒë√∫ng)\n            if (newItem.customerSystemId) {\n                const { update: updateCustomer, findById: findCustomer } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n                const customer = findCustomer(newItem.customerSystemId);\n                if (customer) {\n                    updateCustomer(newItem.customerSystemId, {\n                        lastPurchaseDate: new Date().toISOString().split('T')[0]\n                    });\n                }\n            }\n            // ‚úÖ Add activity history entry\n            const historyEntry = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.createCreatedEntry)(userInfo, `${userInfo.name} ƒë√£ t·∫°o ƒë∆°n h√†ng ${newItem.id} cho kh√°ch h√†ng ${newItem.customerName} (T·ªïng: ${newItem.grandTotal.toLocaleString('vi-VN')}ƒë)`);\n            baseStore.setState((state)=>({\n                    data: state.data.map((order)=>order.systemId === newItem.systemId ? {\n                            ...order,\n                            activityHistory: [\n                                historyEntry\n                            ]\n                        } : order)\n                }));\n        }\n        return newItem;\n    }\n});\nconst backfillPackagingIdentifiers = ()=>{\n    const currentState = baseStore.getState();\n    let changed = false;\n    const updatedData = currentState.data.map((order)=>{\n        const updatedOrder = ensureOrderPackagingIdentifiers(order);\n        if (updatedOrder) {\n            changed = true;\n            return updatedOrder;\n        }\n        return order;\n    });\n    if (changed) {\n        baseStore.setState({\n            data: updatedData\n        });\n    }\n};\nbackfillPackagingIdentifiers();\nconst augmentedMethods = {\n    cancelOrder: (systemId, employeeId, options)=>{\n        const { reason, restock = true } = options ?? {};\n        const currentOrder = baseStore.getState().data.find((o)=>o.systemId === systemId);\n        if (!ensureCancellationAllowed(currentOrder, 'h·ªßy ƒë∆°n h√†ng')) {\n            return;\n        }\n        baseStore.setState((state)=>{\n            const orderToCancel = state.data.find((o)=>o.systemId === systemId);\n            if (!orderToCancel || orderToCancel.status === 'ƒê√£ h·ªßy') {\n                return state;\n            }\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const now = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            const cancellationReason = reason && reason.trim().length > 0 ? reason.trim() : orderToCancel.cancellationReason || `H·ªßy b·ªüi ${employee?.fullName || 'H·ªá th·ªëng'}`;\n            // ‚úÖ Uncommit stock (h·ªó tr·ª£ combo)\n            if (restock) {\n                orderToCancel.lineItems.forEach((item)=>{\n                    processLineItemStock(item, orderToCancel.branchSystemId, 'uncommit', item.quantity);\n                });\n            }\n            const hasDispatchedStock = orderToCancel.stockOutStatus === 'Xu·∫•t kho to√†n b·ªô' || [\n                'Ch·ªù l·∫•y h√†ng',\n                'ƒêang giao h√†ng',\n                'ƒê√£ giao h√†ng',\n                'Ch·ªù giao l·∫°i'\n            ].includes(orderToCancel.deliveryStatus);\n            // ‚úÖ Return stock from transit (h·ªó tr·ª£ combo)\n            if (restock && hasDispatchedStock) {\n                orderToCancel.lineItems.forEach((item)=>{\n                    processLineItemStock(item, orderToCancel.branchSystemId, 'return', item.quantity);\n                });\n            }\n            const existingPayments = orderToCancel.payments ?? [];\n            const netCollected = existingPayments.reduce((sum, payment)=>sum + payment.amount, 0);\n            let refundPaymentEntry = null;\n            const refundAmount = netCollected > 0 ? netCollected : 0;\n            if (refundAmount > 0) {\n                const refundVoucher = createOrderRefundVoucher(orderToCancel, refundAmount, employeeId);\n                if (!refundVoucher) {\n                    alert('Kh√¥ng th·ªÉ t·∫°o phi·∫øu chi ho√†n ti·ªÅn. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh t√†i ch√≠nh tr∆∞·ªõc khi h·ªßy ƒë∆°n.');\n                    return state;\n                }\n                refundPaymentEntry = {\n                    systemId: refundVoucher.systemId,\n                    id: refundVoucher.id,\n                    date: refundVoucher.date,\n                    amount: -refundAmount,\n                    method: refundVoucher.paymentMethodName,\n                    createdBy: employeeId,\n                    description: `Ho√†n ti·ªÅn khi h·ªßy ƒë∆°n ${orderToCancel.id}`\n                };\n            }\n            const updatedPayments = refundPaymentEntry ? [\n                ...existingPayments,\n                refundPaymentEntry\n            ] : existingPayments;\n            const updatedPaidAmount = Math.max(0, (orderToCancel.paidAmount ?? 0) - refundAmount);\n            const updatedPackagings = orderToCancel.packagings.map((pkg)=>{\n                if (pkg.status === 'H·ªßy ƒë√≥ng g√≥i' && pkg.deliveryStatus === 'ƒê√£ h·ªßy') {\n                    return pkg;\n                }\n                return {\n                    ...pkg,\n                    status: 'H·ªßy ƒë√≥ng g√≥i',\n                    deliveryStatus: 'ƒê√£ h·ªßy',\n                    cancelDate: now,\n                    cancelReason: pkg.cancelReason ?? cancellationReason,\n                    cancelingEmployeeId: employeeId,\n                    cancelingEmployeeName: employee?.fullName || 'H·ªá th·ªëng'\n                };\n            });\n            const updatedOrder = {\n                ...orderToCancel,\n                status: 'ƒê√£ h·ªßy',\n                cancelledDate: now,\n                cancellationReason,\n                deliveryStatus: 'ƒê√£ h·ªßy',\n                stockOutStatus: restock ? 'Ch∆∞a xu·∫•t kho' : orderToCancel.stockOutStatus,\n                payments: updatedPayments,\n                paidAmount: updatedPaidAmount,\n                paymentStatus: refundPaymentEntry ? 'Ch∆∞a thanh to√°n' : orderToCancel.paymentStatus,\n                packagings: updatedPackagings,\n                cancellationMetadata: {\n                    restockItems: restock,\n                    notifyCustomer: false,\n                    emailNotifiedAt: undefined\n                },\n                activityHistory: (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.appendHistoryEntry)(orderToCancel.activityHistory, (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.createHistoryEntry)('cancelled', (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.getCurrentUserInfo)(), `${employee?.fullName || 'H·ªá th·ªëng'} ƒë√£ h·ªßy ƒë∆°n h√†ng. L√Ω do: ${cancellationReason}${refundAmount > 0 ? `. Ho√†n ti·ªÅn: ${refundAmount.toLocaleString('vi-VN')}ƒë` : ''}`))\n            };\n            // ‚úÖ Remove debt transaction from customer\n            _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState().removeDebtTransaction(orderToCancel.customerSystemId, orderToCancel.id);\n            return {\n                data: state.data.map((o)=>o.systemId === systemId ? updatedOrder : o)\n            };\n        });\n    },\n    addPayment: (orderSystemId, paymentData, employeeId)=>{\n        // --- Side effects must happen outside setState ---\n        const order = baseStore.getState().findById(orderSystemId);\n        const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n        if (!order || !employee) {\n            console.error(\"Order or employee not found for payment.\");\n            return;\n        }\n        const { document: createdReceipt, error } = (0,_finance_document_helpers__WEBPACK_IMPORTED_MODULE_14__.createReceiptDocument)({\n            amount: paymentData.amount,\n            description: `Thanh to√°n cho ƒë∆°n h√†ng ${order.id}`,\n            customerName: order.customerName,\n            customerSystemId: order.customerSystemId,\n            branchSystemId: order.branchSystemId,\n            branchName: order.branchName,\n            createdBy: employeeId,\n            paymentMethodName: paymentData.method,\n            receiptTypeName: 'Thanh to√°n cho ƒë∆°n h√†ng',\n            originalDocumentId: order.id,\n            linkedOrderSystemId: order.systemId,\n            affectsDebt: true\n        });\n        if (!createdReceipt) {\n            console.error('Failed to create receipt', error);\n            alert('Kh√¥ng th·ªÉ t·∫°o phi·∫øu thu cho ƒë∆°n h√†ng. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh ch·ª©ng t·ª´.');\n            return;\n        }\n        // 2. Now, update the order state with the created receipt info\n        baseStore.setState((state)=>{\n            const orderIndex = state.data.findIndex((o)=>o.systemId === orderSystemId);\n            if (orderIndex === -1) return state;\n            const orderToUpdate = state.data[orderIndex];\n            const newPayment = {\n                systemId: createdReceipt.systemId,\n                id: createdReceipt.id,\n                date: createdReceipt.date,\n                amount: createdReceipt.amount,\n                method: createdReceipt.paymentMethodName,\n                createdBy: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(createdReceipt.createdBy),\n                description: createdReceipt.description\n            };\n            const updatedOrder = applyPaymentToOrder(orderToUpdate, newPayment);\n            // ‚úÖ Add activity history entry\n            updatedOrder.activityHistory = (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.appendHistoryEntry)(orderToUpdate.activityHistory, (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.createHistoryEntry)('payment_made', (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.getCurrentUserInfo)(), `${employee?.fullName || 'Nh√¢n vi√™n'} ƒë√£ thanh to√°n ${paymentData.amount.toLocaleString('vi-VN')}ƒë b·∫±ng ${paymentData.method}`));\n            const newData = [\n                ...state.data\n            ];\n            newData[orderIndex] = updatedOrder;\n            return {\n                data: newData\n            };\n        });\n    },\n    requestPackaging: (orderSystemId, employeeId, assignedEmployeeId)=>{\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const assignedEmployee = assignedEmployeeId ? _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(assignedEmployeeId) : null;\n            // Count only active packagings for proper numbering\n            const activePackagings = order.packagings.filter((p)=>p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n            const activeCountAfterInsert = activePackagings.length + 1;\n            const newActiveIndex = activePackagings.length; // This will be the index in active packagings\n            const newPackaging = {\n                systemId: getNextPackagingSystemId(),\n                id: buildPackagingBusinessId(order.id, newActiveIndex, activeCountAfterInsert),\n                requestDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                requestingEmployeeId: employeeId,\n                requestingEmployeeName: employee?.fullName || 'N/A',\n                assignedEmployeeId,\n                assignedEmployeeName: assignedEmployee?.fullName,\n                status: 'Ch·ªù ƒë√≥ng g√≥i',\n                printStatus: 'Ch∆∞a in'\n            };\n            const updatedOrder = {\n                ...order,\n                packagings: [\n                    ...order.packagings,\n                    newPackaging\n                ],\n                deliveryStatus: 'Ch·ªù ƒë√≥ng g√≥i'\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    confirmPackaging: (orderSystemId, packagingSystemId, employeeId)=>{\n        // ‚úÖ Check negative packing setting\n        const { allowNegativePacking } = _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__.useSalesManagementSettingsStore.getState();\n        if (!allowNegativePacking) {\n            const order = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n            if (order) {\n                const { findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n                for (const item of order.lineItems){\n                    const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId));\n                    if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n                        for (const comboItem of product.comboItems){\n                            const childProduct = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId));\n                            const requiredQty = item.quantity * comboItem.quantity;\n                            const currentStock = childProduct?.inventoryByBranch?.[order.branchSystemId] || 0;\n                            if (currentStock < requiredQty) {\n                                alert(`Kh√¥ng th·ªÉ ƒë√≥ng g√≥i: S·∫£n ph·∫©m \"${childProduct?.name}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${requiredQty})`);\n                                return baseStore.getState();\n                            }\n                        }\n                    } else {\n                        const currentStock = product?.inventoryByBranch?.[order.branchSystemId] || 0;\n                        if (currentStock < item.quantity) {\n                            alert(`Kh√¥ng th·ªÉ ƒë√≥ng g√≥i: S·∫£n ph·∫©m \"${item.productName}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${item.quantity})`);\n                            return baseStore.getState();\n                        }\n                    }\n                }\n            }\n        }\n        baseStore.setState((state)=>{\n            const dataCopy = [\n                ...state.data\n            ];\n            const orderIndex = dataCopy.findIndex((o)=>o.systemId === orderSystemId);\n            if (orderIndex === -1) return state;\n            const orderCopy = {\n                ...dataCopy[orderIndex]\n            };\n            const packagingIndex = orderCopy.packagings.findIndex((p)=>p.systemId === packagingSystemId);\n            if (packagingIndex === -1) return state;\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const packagingsCopy = [\n                ...orderCopy.packagings\n            ];\n            packagingsCopy[packagingIndex] = {\n                ...packagingsCopy[packagingIndex],\n                status: 'ƒê√£ ƒë√≥ng g√≥i',\n                confirmDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                confirmingEmployeeId: employeeId,\n                confirmingEmployeeName: employee?.fullName || 'N/A'\n            };\n            orderCopy.packagings = packagingsCopy;\n            orderCopy.deliveryStatus = 'ƒê√£ ƒë√≥ng g√≥i';\n            dataCopy[orderIndex] = orderCopy;\n            return {\n                data: dataCopy\n            };\n        });\n    },\n    cancelPackagingRequest: (orderSystemId, packagingSystemId, employeeId, reason)=>{\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const updatedPackagings = order.packagings.map((p)=>{\n                if (p.systemId === packagingSystemId) {\n                    return {\n                        ...p,\n                        status: 'H·ªßy ƒë√≥ng g√≥i',\n                        cancelDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                        cancelingEmployeeId: employeeId,\n                        cancelingEmployeeName: employee?.fullName || 'N/A',\n                        cancelReason: reason\n                    };\n                }\n                return p;\n            });\n            const isAnyActivePackaging = updatedPackagings.some((p)=>p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: isAnyActivePackaging ? order.deliveryStatus : 'Ch·ªù ƒë√≥ng g√≥i'\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    processInStorePickup: (orderSystemId, packagingSystemId)=>{\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            const totalCount = order.packagings.length;\n            const updatedPackagings = order.packagings.map((p, index)=>{\n                if (p.systemId === packagingSystemId) {\n                    const hasId = typeof p.id === 'string' && p.id.trim().length > 0;\n                    const resolvedId = hasId ? p.id : buildPackagingBusinessId(order.id, index, totalCount);\n                    return {\n                        ...p,\n                        id: resolvedId,\n                        deliveryMethod: 'Nh·∫≠n t·∫°i c·ª≠a h√†ng',\n                        deliveryStatus: 'ƒê√£ ƒë√≥ng g√≥i'\n                    };\n                }\n                return p;\n            });\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: 'ƒê√£ ƒë√≥ng g√≥i'\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    confirmInStorePickup: (orderSystemId, packagingSystemId, employeeId)=>{\n        console.log('üü¢ [confirmInStorePickup] Called with:', {\n            orderSystemId,\n            packagingSystemId,\n            employeeId\n        });\n        // ‚úÖ Check negative stock out setting\n        const { allowNegativeStockOut } = _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__.useSalesManagementSettingsStore.getState();\n        if (!allowNegativeStockOut) {\n            const order = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n            if (order) {\n                const { findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n                for (const item of order.lineItems){\n                    const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId));\n                    if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n                        for (const comboItem of product.comboItems){\n                            const childProduct = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId));\n                            const requiredQty = item.quantity * comboItem.quantity;\n                            const currentStock = childProduct?.inventoryByBranch?.[order.branchSystemId] || 0;\n                            if (currentStock < requiredQty) {\n                                alert(`Kh√¥ng th·ªÉ xu·∫•t kho: S·∫£n ph·∫©m \"${childProduct?.name}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${requiredQty})`);\n                                return baseStore.getState();\n                            }\n                        }\n                    } else {\n                        const currentStock = product?.inventoryByBranch?.[order.branchSystemId] || 0;\n                        if (currentStock < item.quantity) {\n                            alert(`Kh√¥ng th·ªÉ xu·∫•t kho: S·∫£n ph·∫©m \"${item.productName}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${item.quantity})`);\n                            return baseStore.getState();\n                        }\n                    }\n                }\n            }\n        }\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) {\n                console.error('‚ùå [confirmInStorePickup] Order not found:', orderSystemId);\n                return state;\n            }\n            console.log('üìã [confirmInStorePickup] Order found:', order.id);\n            console.log('üìã [confirmInStorePickup] Line items:', order.lineItems.length);\n            // Stock logic\n            const { addEntry: addStockHistory } = _stock_history_store__WEBPACK_IMPORTED_MODULE_8__.useStockHistoryStore.getState();\n            const employeeData = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const now = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            order.lineItems.forEach((item, index)=>{\n                console.log(`üì¶ [confirmInStorePickup] Dispatching item ${index + 1}:`, {\n                    productSystemId: item.productSystemId,\n                    productName: item.productName,\n                    quantity: item.quantity,\n                    branchSystemId: getBranchId(order)\n                });\n                // ‚úÖ Dispatch stock (h·ªó tr·ª£ combo - s·∫Ω dispatch SP con)\n                const processedItems = processLineItemStock(item, getBranchId(order), 'dispatch', item.quantity);\n                // ‚úÖ Add stock history entry for each processed item (SP con n·∫øu combo)\n                processedItems.forEach((processedItem)=>{\n                    const product = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState().findById(processedItem.productSystemId);\n                    const currentStock = product?.inventoryByBranch?.[getBranchId(order)] || 0;\n                    addStockHistory({\n                        date: now,\n                        productId: processedItem.productSystemId,\n                        action: 'Xu·∫•t kho (ƒê∆°n h√†ng)',\n                        quantityChange: -processedItem.quantity,\n                        newStockLevel: currentStock,\n                        documentId: order.id,\n                        branchSystemId: getBranchId(order),\n                        branch: order.branchName,\n                        employeeName: employeeData?.fullName || 'H·ªá th·ªëng'\n                    });\n                });\n            });\n            // Status update logic - will be updated with trackingCode after shipment creation\n            let updatedPackagings = order.packagings.map((p)=>{\n                if (p.systemId === packagingSystemId) {\n                    return {\n                        ...p,\n                        deliveryStatus: 'ƒê√£ giao h√†ng',\n                        deliveredDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date())\n                    };\n                }\n                return p;\n            });\n            const isAllDelivered = updatedPackagings.every((p)=>p.status === 'H·ªßy ƒë√≥ng g√≥i' || p.deliveryStatus === 'ƒê√£ giao h√†ng');\n            let newStatus = order.status === 'ƒê·∫∑t h√†ng' ? 'ƒêang giao d·ªãch' : order.status;\n            let newCompletedDate = order.completedDate;\n            if (isAllDelivered && order.paymentStatus === 'Thanh to√°n to√†n b·ªô') {\n                newStatus = 'Ho√†n th√†nh';\n                newCompletedDate = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            }\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            // ‚úÖ Create shipment record for INSTORE pickup\n            const packaging = order.packagings.find((p)=>p.systemId === packagingSystemId);\n            let newShipment = null;\n            if (packaging) {\n                const { createShipment, updateShipment } = _shipments_store__WEBPACK_IMPORTED_MODULE_15__.useShipmentStore.getState();\n                newShipment = createShipment({\n                    packagingSystemId: packagingSystemId,\n                    orderSystemId: orderSystemId,\n                    orderId: order.id,\n                    trackingCode: '',\n                    carrier: 'Nh·∫≠n t·∫°i c·ª≠a h√†ng',\n                    service: 'Nh·∫≠n t·∫°i c·ª≠a h√†ng',\n                    deliveryStatus: 'ƒê√£ giao h√†ng',\n                    printStatus: 'Ch∆∞a in',\n                    reconciliationStatus: 'Ch∆∞a ƒë·ªëi so√°t',\n                    shippingFeeToPartner: 0,\n                    codAmount: 0,\n                    payer: 'Ng∆∞·ªùi g·ª≠i',\n                    createdAt: now,\n                    dispatchedAt: now,\n                    deliveredAt: now\n                });\n                // Update shipment trackingCode to use its own business ID\n                if (newShipment) {\n                    updateShipment(newShipment.systemId, {\n                        trackingCode: newShipment.id\n                    });\n                    // Update packaging with shipment trackingCode\n                    updatedPackagings = updatedPackagings.map((p)=>{\n                        if (p.systemId === packagingSystemId) {\n                            return {\n                                ...p,\n                                trackingCode: newShipment.id\n                            };\n                        }\n                        return p;\n                    });\n                }\n                console.log('‚úÖ [confirmInStorePickup] Shipment created:', newShipment?.id);\n            }\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: 'ƒê√£ giao h√†ng',\n                status: newStatus,\n                completedDate: newCompletedDate,\n                stockOutStatus: 'Xu·∫•t kho to√†n b·ªô',\n                dispatchedDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                dispatchedByEmployeeId: employeeId,\n                dispatchedByEmployeeName: employee?.fullName\n            };\n            console.log('‚úÖ [confirmInStorePickup] Stock dispatched successfully');\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    confirmPartnerShipment: async (orderSystemId, packagingSystemId, shipmentData)=>{\n        try {\n            const order = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n            if (!order) {\n                return {\n                    success: false,\n                    message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng'\n                };\n            }\n            // ‚úÖ Check negative packing setting (covers creating shipment)\n            const { allowNegativePacking } = _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__.useSalesManagementSettingsStore.getState();\n            if (!allowNegativePacking) {\n                const { findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n                for (const item of order.lineItems){\n                    const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId));\n                    if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n                        for (const comboItem of product.comboItems){\n                            const childProduct = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId));\n                            const requiredQty = item.quantity * comboItem.quantity;\n                            const currentStock = childProduct?.inventoryByBranch?.[order.branchSystemId] || 0;\n                            if (currentStock < requiredQty) {\n                                return {\n                                    success: false,\n                                    message: `Kh√¥ng th·ªÉ t·∫°o v·∫≠n ƒë∆°n: S·∫£n ph·∫©m \"${childProduct?.name}\" kh√¥ng ƒë·ªß t·ªìn kho`\n                                };\n                            }\n                        }\n                    } else {\n                        const currentStock = product?.inventoryByBranch?.[order.branchSystemId] || 0;\n                        if (currentStock < item.quantity) {\n                            return {\n                                success: false,\n                                message: `Kh√¥ng th·ªÉ t·∫°o v·∫≠n ƒë∆°n: S·∫£n ph·∫©m \"${item.productName}\" kh√¥ng ƒë·ªß t·ªìn kho`\n                            };\n                        }\n                    }\n                }\n            }\n            // ‚úÖ Get GHTK preview params from window (set by ShippingIntegration)\n            const ghtkParams = window.__ghtkPreviewParams;\n            if (!ghtkParams) {\n                return {\n                    success: false,\n                    message: 'Thi·∫øu th√¥ng tin v·∫≠n chuy·ªÉn. Vui l√≤ng ch·ªçn d·ªãch v·ª• v·∫≠n chuy·ªÉn.'\n                };\n            }\n            // ‚úÖ Import GHTK service dynamically\n            const { GHTKService } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_features_settings_shipping_integrations_ghtk-service_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../settings/shipping/integrations/ghtk-service */ \"(app-pages-browser)/./features/settings/shipping/integrations/ghtk-service.ts\"));\n            const { getGHTKCredentials } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_utils_get-shipping-credentials_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../../lib/utils/get-shipping-credentials */ \"(app-pages-browser)/./lib/utils/get-shipping-credentials.ts\"));\n            const { apiToken, partnerCode } = getGHTKCredentials();\n            const ghtkService = new GHTKService(apiToken, partnerCode);\n            console.log('üì§ [confirmPartnerShipment] Calling GHTK API with params:', ghtkParams);\n            // ‚úÖ Call real GHTK API\n            const result = await ghtkService.createOrder(ghtkParams);\n            if (!result.success || !result.order) {\n                throw new Error(result.message || 'Kh√¥ng th·ªÉ t·∫°o ƒë∆°n v·∫≠n chuy·ªÉn');\n            }\n            // ‚úÖ Update order with real tracking code from GHTK\n            const trackingCode = result.order.label;\n            const ghtkTrackingId = result.order.tracking_id;\n            const estimatedPickTime = result.order.estimated_pick_time;\n            const estimatedDeliverTime = result.order.estimated_deliver_time;\n            baseStore.setState((state)=>{\n                const updatedPackagings = order.packagings.map((p)=>{\n                    if (p.systemId === packagingSystemId) {\n                        return {\n                            ...p,\n                            deliveryMethod: 'D·ªãch v·ª• giao h√†ng',\n                            deliveryStatus: 'Ch·ªù l·∫•y h√†ng',\n                            carrier: 'GHTK',\n                            service: result.order?.fee ? `${result.order.fee}ƒë` : 'Standard',\n                            trackingCode: trackingCode,\n                            shippingFeeToPartner: parseInt(result.order?.fee || '0') || 0,\n                            codAmount: ghtkParams.pick_money || 0,\n                            payer: ghtkParams.is_freeship === 1 ? 'Ng∆∞·ªùi g·ª≠i' : 'Ng∆∞·ªùi nh·∫≠n',\n                            noteToShipper: ghtkParams.note || '',\n                            weight: ghtkParams.weight,\n                            dimensions: `${ghtkParams.products?.[0]?.length || 10}√ó${ghtkParams.products?.[0]?.width || 10}√ó${ghtkParams.products?.[0]?.height || 10}`,\n                            // ‚úÖ Store GHTK specific data\n                            ghtkTrackingId: String(ghtkTrackingId),\n                            estimatedPickTime: estimatedPickTime,\n                            estimatedDeliverTime: estimatedDeliverTime\n                        };\n                    }\n                    return p;\n                });\n                const updatedOrder = {\n                    ...order,\n                    packagings: updatedPackagings,\n                    deliveryStatus: 'Ch·ªù l·∫•y h√†ng',\n                    status: 'ƒêang giao d·ªãch'\n                };\n                return {\n                    data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n                };\n            });\n            console.log('‚úÖ [confirmPartnerShipment] GHTK order created successfully:', {\n                trackingCode,\n                ghtkTrackingId,\n                estimatedPickTime,\n                estimatedDeliverTime\n            });\n            return {\n                success: true,\n                message: `T·∫°o v·∫≠n ƒë∆°n th√†nh c√¥ng! M√£ v·∫≠n ƒë∆°n: ${trackingCode}`\n            };\n        } catch (error) {\n            console.error('‚ùå [confirmPartnerShipment] Error:', error);\n            let errorMessage = 'Vui l√≤ng th·ª≠ l·∫°i';\n            if (error instanceof Error) {\n                errorMessage = error.message;\n            }\n            return {\n                success: false,\n                message: `L·ªói t·∫°o ƒë∆°n v·∫≠n chuy·ªÉn: ${errorMessage}`\n            };\n        }\n    },\n    dispatchFromWarehouse: (orderSystemId, packagingSystemId, employeeId)=>{\n        // ‚úÖ Check negative stock out setting\n        const { allowNegativeStockOut } = _settings_sales_sales_management_store__WEBPACK_IMPORTED_MODULE_17__.useSalesManagementSettingsStore.getState();\n        if (!allowNegativeStockOut) {\n            const order = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n            if (order) {\n                const { findById: findProductById } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n                for (const item of order.lineItems){\n                    const product = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(item.productSystemId));\n                    if (product && (0,_products_combo_utils__WEBPACK_IMPORTED_MODULE_7__.isComboProduct)(product) && product.comboItems) {\n                        for (const comboItem of product.comboItems){\n                            const childProduct = findProductById((0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(comboItem.productSystemId));\n                            const requiredQty = item.quantity * comboItem.quantity;\n                            const currentStock = childProduct?.inventoryByBranch?.[order.branchSystemId] || 0;\n                            if (currentStock < requiredQty) {\n                                alert(`Kh√¥ng th·ªÉ xu·∫•t kho: S·∫£n ph·∫©m \"${childProduct?.name}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${requiredQty})`);\n                                return baseStore.getState();\n                            }\n                        }\n                    } else {\n                        const currentStock = product?.inventoryByBranch?.[order.branchSystemId] || 0;\n                        if (currentStock < item.quantity) {\n                            alert(`Kh√¥ng th·ªÉ xu·∫•t kho: S·∫£n ph·∫©m \"${item.productName}\" kh√¥ng ƒë·ªß t·ªìn kho (C√≥: ${currentStock}, C·∫ßn: ${item.quantity})`);\n                            return baseStore.getState();\n                        }\n                    }\n                }\n            }\n        }\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            const { addEntry: addStockHistory } = _stock_history_store__WEBPACK_IMPORTED_MODULE_8__.useStockHistoryStore.getState();\n            const employeeData = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const now = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            order.lineItems.forEach((item)=>{\n                // ‚úÖ Dispatch stock (h·ªó tr·ª£ combo - s·∫Ω dispatch SP con)\n                const processedItems = processLineItemStock(item, getBranchId(order), 'dispatch', item.quantity);\n                // ‚úÖ Add stock history entry for each processed item\n                processedItems.forEach((processedItem)=>{\n                    const product = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState().findById(processedItem.productSystemId);\n                    const currentStock = product?.inventoryByBranch?.[getBranchId(order)] || 0;\n                    addStockHistory({\n                        date: now,\n                        productId: processedItem.productSystemId,\n                        action: 'Xu·∫•t kho (ƒê∆°n h√†ng)',\n                        quantityChange: -processedItem.quantity,\n                        newStockLevel: currentStock,\n                        documentId: order.id,\n                        branchSystemId: getBranchId(order),\n                        branch: order.branchName,\n                        employeeName: employeeData?.fullName || 'H·ªá th·ªëng'\n                    });\n                });\n            });\n            const now2 = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            const updatedPackagings = order.packagings.map((p)=>p.systemId === packagingSystemId ? {\n                    ...p,\n                    deliveryStatus: 'ƒêang giao h√†ng'\n                } : p);\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: 'ƒêang giao h√†ng',\n                stockOutStatus: 'Xu·∫•t kho to√†n b·ªô',\n                dispatchedDate: now2,\n                dispatchedByEmployeeId: employeeId,\n                dispatchedByEmployeeName: employeeData?.fullName,\n                status: order.status === 'ƒê·∫∑t h√†ng' ? 'ƒêang giao d·ªãch' : order.status\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    completeDelivery: (orderSystemId, packagingSystemId, employeeId)=>{\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            // ‚úÖ Complete delivery (h·ªó tr·ª£ combo - s·∫Ω complete SP con)\n            order.lineItems.forEach((item)=>{\n                processLineItemStock(item, getBranchId(order), 'complete', item.quantity);\n            });\n            const updatedPackagings = order.packagings.map((p)=>p.systemId === packagingSystemId ? {\n                    ...p,\n                    deliveryStatus: 'ƒê√£ giao h√†ng',\n                    deliveredDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date())\n                } : p);\n            const isAllDelivered = updatedPackagings.every((p)=>p.status === 'H·ªßy ƒë√≥ng g√≥i' || p.deliveryStatus === 'ƒê√£ giao h√†ng');\n            let newStatus = order.status;\n            let newCompletedDate = order.completedDate;\n            // ‚úÖ Khi t·∫•t c·∫£ ƒë∆°n ƒë√£ giao ‚Üí t·∫°o c√¥ng n·ª£ (n·∫øu c√≥) v√† c·∫≠p nh·∫≠t stats\n            if (isAllDelivered && order.status !== 'Ho√†n th√†nh') {\n                // T√≠nh c√¥ng n·ª£ c√≤n l·∫°i\n                const totalPaid = (order.payments || []).reduce((sum, p)=>sum + p.amount, 0);\n                const debtAmount = Math.max(0, order.grandTotal - totalPaid);\n                // ‚úÖ T·∫°o c√¥ng n·ª£ CH·ªà KHI giao h√†ng th√†nh c√¥ng\n                if (debtAmount > 0) {\n                    const { addDebtTransaction } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n                    const dueDate = new Date();\n                    dueDate.setDate(dueDate.getDate() + 30);\n                    addDebtTransaction(order.customerSystemId, {\n                        systemId: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(`DEBT_${order.systemId}`),\n                        orderId: order.id,\n                        orderDate: order.orderDate.split('T')[0],\n                        amount: debtAmount,\n                        dueDate: dueDate.toISOString().split('T')[0],\n                        isPaid: false,\n                        remainingAmount: debtAmount,\n                        notes: 'C√¥ng n·ª£ t·ª´ ƒë∆°n h√†ng ƒë√£ giao th√†nh c√¥ng'\n                    });\n                }\n                // Update customer stats\n                const { incrementOrderStats } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n                incrementOrderStats(order.customerSystemId, order.grandTotal);\n            }\n            // Check if order is fully complete (delivered + fully paid)\n            if (isAllDelivered && order.paymentStatus === 'Thanh to√°n to√†n b·ªô') {\n                newStatus = 'Ho√†n th√†nh';\n                newCompletedDate = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n            }\n            const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: 'ƒê√£ giao h√†ng',\n                status: newStatus,\n                completedDate: newCompletedDate,\n                activityHistory: (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.appendHistoryEntry)(order.activityHistory, (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.createHistoryEntry)('status_changed', (0,_lib_activity_history_helper__WEBPACK_IMPORTED_MODULE_18__.getCurrentUserInfo)(), `${employee?.fullName || 'Nh√¢n vi√™n'} ƒë√£ x√°c nh·∫≠n giao h√†ng th√†nh c√¥ng${newStatus === 'Ho√†n th√†nh' ? '. ƒê∆°n h√†ng ho√†n th√†nh' : ''}`))\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    failDelivery: (orderSystemId, packagingSystemId, employeeId, reason)=>{\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            const { incrementFailedDeliveryStats } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n            // ‚úÖ Return stock from transit (h·ªó tr·ª£ combo - s·∫Ω return SP con)\n            order.lineItems.forEach((item)=>{\n                processLineItemStock(item, getBranchId(order), 'return', item.quantity);\n            });\n            // ‚úÖ Update customer failed delivery stats\n            incrementFailedDeliveryStats(order.customerSystemId);\n            const updatedPackagings = order.packagings.map((p)=>p.systemId === packagingSystemId ? {\n                    ...p,\n                    deliveryStatus: 'Ch·ªù giao l·∫°i',\n                    notes: `Giao th·∫•t b·∫°i: ${reason}`\n                } : p);\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: 'Ch·ªù giao l·∫°i'\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    // ‚úÖ H·ªßy giao h√†ng - KH√îNG tr·∫£ h√†ng v·ªÅ kho (h√†ng b·ªã th·∫•t tung/shipper gi·ªØ)\n    cancelDeliveryOnly: (orderSystemId, packagingSystemId, employeeId, reason)=>{\n        const currentOrder = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n        if (!ensureCancellationAllowed(currentOrder, 'h·ªßy giao h√†ng')) {\n            return;\n        }\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            // ‚úÖ Get employee info for canceller\n            const employeeData = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const updatedPackagings = order.packagings.map((p)=>p.systemId === packagingSystemId ? {\n                    ...p,\n                    status: 'H·ªßy ƒë√≥ng g√≥i',\n                    deliveryStatus: 'ƒê√£ h·ªßy',\n                    cancelReason: `H·ªßy giao h√†ng: ${reason}`,\n                    cancelDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    cancelingEmployeeId: employeeId,\n                    cancelingEmployeeName: employeeData?.fullName || 'H·ªá th·ªëng'\n                } : p);\n            // ‚úÖ Check if all packagings are cancelled, update order status accordingly\n            const allCancelled = updatedPackagings.every((p)=>p.deliveryStatus === 'ƒê√£ h·ªßy' || p.status === 'H·ªßy ƒë√≥ng g√≥i');\n            const hasAnyActive = updatedPackagings.some((p)=>p.deliveryStatus && p.deliveryStatus !== 'ƒê√£ h·ªßy' && p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n            let newOrderStatus = order.status;\n            let newDeliveryStatus = order.deliveryStatus;\n            if (allCancelled) {\n                // All packagings cancelled ‚Üí order goes back to pending state\n                newOrderStatus = 'ƒêang giao d·ªãch';\n                newDeliveryStatus = 'Ch∆∞a giao h√†ng';\n            } else if (hasAnyActive) {\n                // Some packagings still active ‚Üí keep current delivery status of remaining active packaging\n                const activePackaging = updatedPackagings.find((p)=>p.deliveryStatus && p.deliveryStatus !== 'ƒê√£ h·ªßy');\n                if (activePackaging?.deliveryStatus) {\n                    newDeliveryStatus = activePackaging.deliveryStatus;\n                }\n            }\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                status: newOrderStatus,\n                deliveryStatus: newDeliveryStatus\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    // ‚úÖ H·ªßy giao v√† nh·∫≠n l·∫°i h√†ng - TR·∫¢ h√†ng v·ªÅ kho (ƒë√£ nh·∫≠n l·∫°i t·ª´ shipper)\n    cancelDelivery: (orderSystemId, packagingSystemId, employeeId, reason)=>{\n        const currentOrder = baseStore.getState().data.find((o)=>o.systemId === orderSystemId);\n        if (!ensureCancellationAllowed(currentOrder, 'h·ªßy giao h√†ng')) {\n            return;\n        }\n        baseStore.setState((state)=>{\n            const order = state.data.find((o)=>o.systemId === orderSystemId);\n            if (!order) return state;\n            // ‚úÖ TR·∫¢ h√†ng t·ª´ \"ƒëang giao\" v·ªÅ \"t·ªìn kho\" (h·ªó tr·ª£ combo - s·∫Ω return SP con)\n            order.lineItems.forEach((item)=>{\n                processLineItemStock(item, getBranchId(order), 'return', item.quantity);\n            });\n            // ‚úÖ Get employee info for canceller\n            const employeeData = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n            const updatedPackagings = order.packagings.map((p)=>p.systemId === packagingSystemId ? {\n                    ...p,\n                    status: 'H·ªßy ƒë√≥ng g√≥i',\n                    deliveryStatus: 'ƒê√£ h·ªßy',\n                    cancelReason: `H·ªßy giao h√†ng: ${reason}`,\n                    cancelDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    cancelingEmployeeId: employeeId,\n                    cancelingEmployeeName: employeeData?.fullName || 'H·ªá th·ªëng'\n                } : p);\n            // ‚úÖ Check if all packagings are cancelled, update order status accordingly\n            const allCancelled = updatedPackagings.every((p)=>p.deliveryStatus === 'ƒê√£ h·ªßy' || p.status === 'H·ªßy ƒë√≥ng g√≥i');\n            const hasAnyActive = updatedPackagings.some((p)=>p.deliveryStatus && p.deliveryStatus !== 'ƒê√£ h·ªßy' && p.status !== 'H·ªßy ƒë√≥ng g√≥i');\n            let newOrderStatus = order.status;\n            let newDeliveryStatus = order.deliveryStatus;\n            if (allCancelled) {\n                // All packagings cancelled ‚Üí order goes back to pending state\n                newOrderStatus = 'ƒêang giao d·ªãch';\n                newDeliveryStatus = 'Ch∆∞a giao h√†ng';\n            } else if (hasAnyActive) {\n                // Some packagings still active ‚Üí keep current delivery status of remaining active packaging\n                const activePackaging = updatedPackagings.find((p)=>p.deliveryStatus && p.deliveryStatus !== 'ƒê√£ h·ªßy');\n                if (activePackaging?.deliveryStatus) {\n                    newDeliveryStatus = activePackaging.deliveryStatus;\n                }\n            }\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                status: newOrderStatus,\n                deliveryStatus: newDeliveryStatus\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n            };\n        });\n    },\n    confirmCodReconciliation: (shipments, employeeId)=>{\n        const { add: addReceipt } = _receipts_store__WEBPACK_IMPORTED_MODULE_12__.useReceiptStore.getState();\n        const { accounts } = _cashbook_store__WEBPACK_IMPORTED_MODULE_11__.useCashbookStore.getState();\n        const { data: receiptTypes } = _settings_receipt_types_store__WEBPACK_IMPORTED_MODULE_10__.useReceiptTypeStore.getState();\n        const employee = _employees_store__WEBPACK_IMPORTED_MODULE_5__.useEmployeeStore.getState().findById(employeeId);\n        const allOrders = baseStore.getState().data;\n        const totalByPartnerAndBranch = {};\n        shipments.forEach((shipment)=>{\n            const order = allOrders.find((o)=>o.systemId === shipment.orderSystemId);\n            if (!order || !shipment.carrier) return;\n            const key = `${shipment.carrier}-${getBranchId(order)}`;\n            if (!totalByPartnerAndBranch[key]) {\n                totalByPartnerAndBranch[key] = {\n                    total: 0,\n                    ids: [],\n                    branchSystemId: getBranchId(order),\n                    branchName: order.branchName,\n                    partnerName: shipment.carrier,\n                    shipmentSystemIds: []\n                };\n            }\n            totalByPartnerAndBranch[key].total += shipment.codAmount || 0;\n            totalByPartnerAndBranch[key].ids.push(shipment.trackingCode || shipment.id);\n            totalByPartnerAndBranch[key].shipmentSystemIds.push(shipment.systemId);\n        });\n        const createdReceipts = [];\n        Object.values(totalByPartnerAndBranch).forEach((group)=>{\n            const account = accounts.find((acc)=>acc.type === 'bank' && acc.branchSystemId === group.branchSystemId) || accounts.find((acc)=>acc.type === 'bank');\n            const category = receiptTypes.find((c)=>c.id === 'DOISOATCOD');\n            if (account && category) {\n                const newReceiptData = {\n                    id: '',\n                    date: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    amount: group.total,\n                    payerType: 'ƒê·ªëi t√°c v·∫≠n chuy·ªÉn',\n                    payerName: group.partnerName,\n                    description: `ƒê·ªëi so√°t COD cho c√°c v·∫≠n ƒë∆°n: ${group.ids.join(', ')}`,\n                    paymentMethod: 'Chuy·ªÉn kho·∫£n',\n                    accountSystemId: account.systemId,\n                    originalDocumentId: group.ids.join(', '),\n                    createdBy: employee?.fullName || 'N/A',\n                    branchSystemId: group.branchSystemId,\n                    branchName: group.branchName,\n                    paymentReceiptTypeSystemId: category.systemId,\n                    paymentReceiptTypeName: category.name,\n                    status: 'completed',\n                    createdAt: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    updatedAt: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    affectsDebt: false\n                };\n                const newReceipt = addReceipt(newReceiptData);\n                if (newReceipt) {\n                    createdReceipts.push({\n                        ...newReceipt,\n                        shipmentSystemIds: group.shipmentSystemIds\n                    });\n                }\n            }\n        });\n        baseStore.setState((state)=>{\n            const updates = new Map();\n            shipments.forEach((shipment)=>{\n                const receiptForShipment = createdReceipts.find((v)=>v.shipmentSystemIds.includes(shipment.systemId));\n                if (!receiptForShipment || !shipment.codAmount || shipment.codAmount <= 0) return;\n                const orderSystemId = shipment.orderSystemId;\n                const orderUpdates = updates.get(orderSystemId) || {\n                    newPayments: [],\n                    reconciledShipmentIds: []\n                };\n                const newPayment = {\n                    systemId: receiptForShipment.systemId,\n                    id: receiptForShipment.id,\n                    date: receiptForShipment.date,\n                    method: 'ƒê·ªëi so√°t COD',\n                    amount: shipment.codAmount || 0,\n                    createdBy: (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)('SYSTEM'),\n                    description: `Thanh to√°n COD cho v·∫≠n ƒë∆°n ${shipment.trackingCode || shipment.id}`\n                };\n                orderUpdates.newPayments.push(newPayment);\n                orderUpdates.reconciledShipmentIds.push(shipment.systemId);\n                updates.set(orderSystemId, orderUpdates);\n            });\n            if (updates.size === 0) return state;\n            const newData = state.data.map((order)=>{\n                if (updates.has(order.systemId)) {\n                    const orderUpdates = updates.get(order.systemId);\n                    let updatedOrder = {\n                        ...order\n                    };\n                    updatedOrder.packagings = updatedOrder.packagings.map((p)=>orderUpdates.reconciledShipmentIds.includes(p.systemId) ? {\n                            ...p,\n                            reconciliationStatus: 'ƒê√£ ƒë·ªëi so√°t'\n                        } : p);\n                    for (const payment of orderUpdates.newPayments){\n                        updatedOrder = applyPaymentToOrder(updatedOrder, payment);\n                    }\n                    return updatedOrder;\n                }\n                return order;\n            });\n            return {\n                data: newData\n            };\n        });\n    },\n    // ============================================\n    // GHTK INTEGRATION METHODS\n    // ============================================\n    /**\r\n     * Process GHTK webhook update\r\n     * Called when GHTK pushes status update or from tracking API\r\n     */ processGHTKWebhook: (webhookData)=>{\n        baseStore.setState((state)=>{\n            // Find order by tracking code or partner_id\n            const order = state.data.find((o)=>o.packagings.some((p)=>p.trackingCode === webhookData.label_id || p.systemId === webhookData.partner_id || o.systemId === webhookData.partner_id));\n            if (!order) {\n                console.warn('[GHTK Webhook] Order not found for:', {\n                    label_id: webhookData.label_id,\n                    partner_id: webhookData.partner_id\n                });\n                return state;\n            }\n            // Import status mapping\n            const { getGHTKStatusInfo, getGHTKReasonText } = __webpack_require__(/*! ../../lib/ghtk-constants */ \"(app-pages-browser)/./lib/ghtk-constants.ts\");\n            const statusMapping = getGHTKStatusInfo(webhookData.status_id);\n            if (!statusMapping) {\n                console.warn('[GHTK Webhook] Unknown status:', webhookData.status_id);\n                return state;\n            }\n            console.log('[GHTK Webhook] Processing update:', {\n                order: order.id,\n                trackingCode: webhookData.label_id,\n                statusId: webhookData.status_id,\n                statusText: statusMapping.statusText,\n                deliveryStatus: statusMapping.deliveryStatus\n            });\n            // Update packaging with new status\n            const updatedPackagings = order.packagings.map((p)=>{\n                if (p.trackingCode !== webhookData.label_id && p.systemId !== webhookData.partner_id) {\n                    return p;\n                }\n                return {\n                    ...p,\n                    deliveryStatus: statusMapping.deliveryStatus,\n                    partnerStatus: statusMapping.statusText,\n                    ghtkStatusId: webhookData.status_id,\n                    ghtkReasonCode: webhookData.reason_code,\n                    ghtkReasonText: webhookData.reason ? webhookData.reason : webhookData.reason_code ? getGHTKReasonText(webhookData.reason_code) : undefined,\n                    actualWeight: webhookData.weight,\n                    actualFee: webhookData.fee,\n                    lastSyncedAt: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                    // Update reconciliation status if status = 6 (ƒê√£ ƒë·ªëi so√°t)\n                    reconciliationStatus: webhookData.status_id === 6 ? 'ƒê√£ ƒë·ªëi so√°t' : p.reconciliationStatus,\n                    // Update delivered date if status = 5 or 6\n                    deliveredDate: [\n                        5,\n                        6\n                    ].includes(webhookData.status_id) && !p.deliveredDate ? (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()) : p.deliveredDate\n                };\n            });\n            // Handle stock updates based on status\n            if (statusMapping.shouldUpdateStock && statusMapping.stockAction) {\n                const { dispatchStock, completeDelivery: productCompleteDelivery, returnStockFromTransit } = _products_store__WEBPACK_IMPORTED_MODULE_6__.useProductStore.getState();\n                const { incrementFailedDeliveryStats } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n                // ‚úÖ Expand combo items to child products\n                const stockItems = getComboStockItems(order.lineItems);\n                stockItems.forEach((item)=>{\n                    switch(statusMapping.stockAction){\n                        case 'dispatch':\n                            // Status 3: ƒê√£ l·∫•y h√†ng -> Move to transit\n                            dispatchStock(item.productSystemId, (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(getBranchId(order)), item.quantity);\n                            break;\n                        case 'complete':\n                            // Status 5: ƒê√£ giao h√†ng -> Complete delivery\n                            productCompleteDelivery(item.productSystemId, (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(getBranchId(order)), item.quantity);\n                            break;\n                        case 'return':\n                            // Status -1, 7, 9, 13, 20: Failed/Returned -> Return stock\n                            returnStockFromTransit(item.productSystemId, (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_3__.asSystemId)(getBranchId(order)), item.quantity);\n                            break;\n                    }\n                });\n                // ‚úÖ Increment failed delivery stats for customer if return (moved outside loop)\n                if (statusMapping.stockAction === 'return') {\n                    const failureStatuses = [\n                        7,\n                        9,\n                        13,\n                        20,\n                        21\n                    ];\n                    const currentPackaging = order.packagings.find((p)=>p.trackingCode === webhookData.label_id);\n                    const previousStatusId = currentPackaging?.ghtkStatusId;\n                    if (failureStatuses.includes(webhookData.status_id) && (!previousStatusId || !failureStatuses.includes(previousStatusId))) {\n                        incrementFailedDeliveryStats(order.customerSystemId);\n                    }\n                }\n                console.log('[GHTK Webhook] Stock updated:', {\n                    action: statusMapping.stockAction,\n                    items: stockItems.length\n                });\n            }\n            // Determine order-level delivery status\n            const allPackagingsDelivered = updatedPackagings.every((p)=>p.status === 'H·ªßy ƒë√≥ng g√≥i' || p.deliveryStatus === 'ƒê√£ giao h√†ng');\n            let newOrderDeliveryStatus = order.deliveryStatus;\n            let newOrderStatus = order.status;\n            let newCompletedDate = order.completedDate;\n            let newStockOutStatus = order.stockOutStatus;\n            // Update order delivery status\n            if (allPackagingsDelivered) {\n                newOrderDeliveryStatus = 'ƒê√£ giao h√†ng';\n                // Auto-complete order if delivered + paid\n                if (order.paymentStatus === 'Thanh to√°n to√†n b·ªô' && order.status !== 'Ho√†n th√†nh') {\n                    newOrderStatus = 'Ho√†n th√†nh';\n                    newCompletedDate = (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date());\n                    // Update customer stats\n                    const { incrementOrderStats } = _customers_store__WEBPACK_IMPORTED_MODULE_9__.useCustomerStore.getState();\n                    incrementOrderStats(order.customerSystemId, order.grandTotal);\n                    console.log('[GHTK Webhook] Order completed:', order.id);\n                }\n            } else if (statusMapping.statusId === 3) {\n                // Status 3: ƒê√£ l·∫•y h√†ng\n                newOrderDeliveryStatus = 'ƒêang giao h√†ng';\n                newStockOutStatus = 'Xu·∫•t kho to√†n b·ªô';\n            } else if ([\n                4,\n                10\n            ].includes(statusMapping.statusId)) {\n                // Status 4, 10: ƒêang giao\n                newOrderDeliveryStatus = 'ƒêang giao h√†ng';\n            }\n            const updatedOrder = {\n                ...order,\n                packagings: updatedPackagings,\n                deliveryStatus: newOrderDeliveryStatus,\n                status: newOrderStatus,\n                completedDate: newCompletedDate,\n                stockOutStatus: newStockOutStatus\n            };\n            return {\n                data: state.data.map((o)=>o.systemId === order.systemId ? updatedOrder : o)\n            };\n        });\n    },\n    /**\r\n     * Cancel GHTK shipment\r\n     * ‚ö†Ô∏è Ch·ªâ h·ªßy ƒë∆∞·ª£c khi ƒë∆°n ·ªü tr·∫°ng th√°i: 1, 2, 12 (Ch∆∞a ti·∫øp nh·∫≠n, ƒê√£ ti·∫øp nh·∫≠n, ƒêang l·∫•y h√†ng)\r\n     */ cancelGHTKShipment: async (orderSystemId, packagingSystemId, trackingCode)=>{\n        try {\n            console.log('[GHTK] Cancelling shipment:', trackingCode);\n            // ‚úÖ L·∫•y credentials t·ª´ shipping_partners_config\n            const { getGHTKCredentials } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_utils_get-shipping-credentials_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../../lib/utils/get-shipping-credentials */ \"(app-pages-browser)/./lib/utils/get-shipping-credentials.ts\"));\n            let credentials;\n            try {\n                credentials = getGHTKCredentials();\n            } catch (error) {\n                return {\n                    success: false,\n                    message: error.message || 'Ch∆∞a c·∫•u h√¨nh GHTK. Vui l√≤ng v√†o C√†i ƒë·∫∑t ‚Üí ƒê·ªëi t√°c v·∫≠n chuy·ªÉn.'\n                };\n            }\n            const response = await fetch((0,_lib_api_config__WEBPACK_IMPORTED_MODULE_1__.getApiUrl)('/shipping/ghtk/cancel-order'), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    trackingCode,\n                    apiToken: credentials.apiToken,\n                    partnerCode: credentials.partnerCode\n                })\n            });\n            const data = await response.json();\n            // ‚úÖ Ki·ªÉm tra response t·ª´ GHTK\n            if (!response.ok) {\n                throw new Error(data.message || data.error || 'Failed to cancel GHTK shipment');\n            }\n            // ‚úÖ GHTK tr·∫£ success: false khi kh√¥ng th·ªÉ h·ªßy (ƒë√£ l·∫•y h√†ng)\n            if (data.success === false) {\n                console.log('[GHTK] Cannot cancel:', data.message);\n                return {\n                    success: false,\n                    message: data.message || 'Kh√¥ng th·ªÉ h·ªßy ƒë∆°n h√†ng'\n                };\n            }\n            console.log('[GHTK] Cancellation successful:', data.message);\n            // ‚úÖ CH·ªà update state khi GHTK x√°c nh·∫≠n h·ªßy th√†nh c√¥ng\n            baseStore.setState((state)=>{\n                const order = state.data.find((o)=>o.systemId === orderSystemId);\n                if (!order) return state;\n                const updatedPackagings = order.packagings.map((p)=>{\n                    if (p.systemId !== packagingSystemId) return p;\n                    return {\n                        ...p,\n                        status: 'H·ªßy ƒë√≥ng g√≥i',\n                        deliveryStatus: 'ƒê√£ h·ªßy',\n                        cancelDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_0__.toISODateTime)(new Date()),\n                        cancelReason: 'H·ªßy v·∫≠n ƒë∆°n GHTK',\n                        ghtkStatusId: -1,\n                        partnerStatus: 'H·ªßy ƒë∆°n h√†ng'\n                    };\n                });\n                // ‚úÖ KH√îNG rollback stock - ƒë·ªÉ user t·ª± quy·∫øt ƒë·ªãnh (n√∫t \"H·ªßy giao v√† nh·∫≠n l·∫°i h√†ng\")\n                const updatedOrder = {\n                    ...order,\n                    packagings: updatedPackagings\n                };\n                return {\n                    data: state.data.map((o)=>o.systemId === orderSystemId ? updatedOrder : o)\n                };\n            });\n            return {\n                success: true,\n                message: data.message || 'ƒê√£ h·ªßy v·∫≠n ƒë∆°n GHTK th√†nh c√¥ng'\n            };\n        } catch (error) {\n            console.error('[GHTK] Cancel error:', error);\n            return {\n                success: false,\n                message: error.message || 'L·ªói khi h·ªßy v·∫≠n ƒë∆°n GHTK'\n            };\n        }\n    }\n};\n// Auto-allocate historical receipts on startup\n_receipts_store__WEBPACK_IMPORTED_MODULE_12__.useReceiptStore.getState().data.forEach((receipt)=>{\n    autoAllocateReceiptToOrders(receipt);\n});\n// React to newly created receipts\n_receipts_store__WEBPACK_IMPORTED_MODULE_12__.useReceiptStore.subscribe((state)=>state.data, (currentReceipts, previousReceipts)=>{\n    const previousIds = new Set((previousReceipts ?? []).map((r)=>r.systemId));\n    currentReceipts.forEach((receipt)=>{\n        if (!previousIds.has(receipt.systemId)) {\n            autoAllocateReceiptToOrders(receipt);\n        }\n    });\n});\n// Export typed hook with all augmented methods\nconst useOrderStore = ()=>{\n    const state = baseStore();\n    return {\n        ...state,\n        ...augmentedMethods\n    };\n};\n// Export getState for non-hook usage\nuseOrderStore.getState = ()=>{\n    const state = baseStore.getState();\n    return {\n        ...state,\n        ...augmentedMethods\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL29yZGVycy9zdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLCtEQUErRDtBQUMrQjtBQUM3QztBQUNTO0FBSUk7QUFDZTtBQUV2QjtBQUN0RCxpRkFBaUY7QUFDN0I7QUFDSztBQUNLO0FBQ1I7QUFDZ0I7QUFDdEUsNkRBQTZEO0FBQ1I7QUFDRDtBQUVTO0FBQzhCO0FBQ3JDO0FBR2U7QUFFc0I7QUFPaEQ7QUFFM0Msa0NBQWtDO0FBQ2xDLE1BQU15QixjQUFjLENBQUNDLFFBQWlCQSxNQUFNQyxjQUFjO0FBRTFELE1BQU1DLHlDQUFnRTtJQUNsRTtJQUNBO0lBQ0E7Q0FDSDtBQUVELE1BQU1DLHlCQUF5QjtBQUUvQixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsNkJBQTZCO0FBRW5DLDhDQUE4QztBQUM5QyxJQUFJQywyQkFBMkI7QUFFL0Isc0VBQXNFO0FBQ3RFLE1BQU1DLHVCQUF1QixDQUFDQztJQUMxQixNQUFNQyxnQkFBZ0JELE9BQU9FLE9BQU8sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsVUFBVSxJQUFJLEVBQUU7SUFDNUROLDJCQUEyQjFCLG9FQUFxQkEsQ0FBQzZCLGVBQWVKO0FBQ3BFO0FBRUEscUNBQXFDO0FBQ3JDLE1BQU1RLDJCQUEyQjtJQUM3QlA7SUFDQSxPQUFPN0IseURBQVVBLENBQUNFLCtEQUFnQkEsQ0FBQyxhQUFhMkI7QUFDcEQ7QUFFQSxNQUFNUSxnQ0FBZ0MsQ0FBQ0M7SUFDbkMsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsTUFBTUMsV0FBVyxHQUFHRCxTQUFTO0lBQzdCLE1BQU1FLFNBQVNELFNBQVNFLE9BQU8sQ0FBQyxZQUFZO0lBQzVDLE9BQU9ELFVBQVVEO0FBQ3JCO0FBRUEsNkRBQTZEO0FBQzdELE1BQU1HLDBCQUEwQixDQUFDUDtJQUM3QixPQUFPQSxXQUFXUSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0s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NkMsUUFBUSxHQUFHQyxJQUFJLENBQUNvSCxPQUFPLENBQUNsRixDQUFBQTtJQUNwQ00sNEJBQTRCTjtBQUNoQztBQUVBLGtDQUFrQztBQUNsQ2hGLDZEQUFlQSxDQUFDOGMsU0FBUyxDQUNyQnhWLENBQUFBLFFBQVNBLE1BQU14RSxJQUFJLEVBQ25CLENBQUNpYSxpQkFBaUJDO0lBQ2QsTUFBTUMsY0FBYyxJQUFJeFAsSUFBSSxDQUFDdVAsb0JBQW9CLEVBQUUsRUFBRXRYLEdBQUcsQ0FBQ3dYLENBQUFBLElBQUtBLEVBQUU3WixRQUFRO0lBQ3hFMFosZ0JBQWdCN1MsT0FBTyxDQUFDbEYsQ0FBQUE7UUFDcEIsSUFBSSxDQUFDaVksWUFBWXRQLEdBQUcsQ0FBQzNJLFFBQVEzQixRQUFRLEdBQUc7WUFDcENpQyw0QkFBNEJOO1FBQ2hDO0lBQ0o7QUFDSjtBQUlKLCtDQUErQztBQUN4QyxNQUFNbVksZ0JBQWdCO0lBQzNCLE1BQU03VixRQUFRN0I7SUFDZCxPQUFPO1FBQ0wsR0FBRzZCLEtBQUs7UUFDUixHQUFHNkgsZ0JBQWdCO0lBQ3JCO0FBQ0YsRUFBRTtBQUVGLHFDQUFxQztBQUNyQ2dPLGNBQWN0YSxRQUFRLEdBQUc7SUFDdkIsTUFBTXlFLFFBQVE3QixVQUFVNUMsUUFBUTtJQUNoQyxPQUFPO1FBQ0wsR0FBR3lFLEtBQUs7UUFDUixHQUFHNkgsZ0JBQWdCO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxocm0yXFxmZWF0dXJlc1xcb3JkZXJzXFxzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuLy8gcGVyc2lzdCBtaWRkbGV3YXJlIHJlbW92ZWQgLSBkYXRhYmFzZSBpcyBub3cgc291cmNlIG9mIHRydXRoXHJcbmltcG9ydCB7IGZvcm1hdERhdGUsIGZvcm1hdERhdGVDdXN0b20sIHRvSVNPRGF0ZSwgdG9JU09EYXRlVGltZSB9IGZyb20gJy4uLy4uL2xpYi9kYXRlLXV0aWxzJztcclxuaW1wb3J0IHsgZ2V0QXBpVXJsIH0gZnJvbSAnLi4vLi4vbGliL2FwaS1jb25maWcnO1xyXG5pbXBvcnQgeyBjcmVhdGVDcnVkU3RvcmUgfSBmcm9tICcuLi8uLi9saWIvc3RvcmUtZmFjdG9yeSc7XHJcbi8vIFJFTU9WRUQ6IGltcG9ydCB7IGRhdGEgYXMgaW5pdGlhbERhdGFPbWl0IH0gZnJvbSAnLi9kYXRhJzsgLy8gTW9jayBkYXRhIG5vIGxvbmdlciB1c2VkIC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbmltcG9ydCB0eXBlIHsgT3JkZXIsIE9yZGVyUGF5bWVudCwgUGFja2FnaW5nLCBPcmRlck1haW5TdGF0dXMsIE9yZGVyRGVsaXZlcnlTdGF0dXMsIFBhY2thZ2luZ1N0YXR1cywgT3JkZXJQYXltZW50U3RhdHVzLCBPcmRlckRlbGl2ZXJ5TWV0aG9kIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB0eXBlIHsgU3lzdGVtSWQsIEJ1c2luZXNzSWQgfSBmcm9tICcuLi8uLi9saWIvaWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBhc1N5c3RlbUlkLCBhc0J1c2luZXNzSWQgfSBmcm9tICcuLi8uLi9saWIvaWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVN5c3RlbUlkLCBnZXRNYXhTeXN0ZW1JZENvdW50ZXIgfSBmcm9tICcuLi8uLi9saWIvaWQtdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgdXNlRW1wbG95ZWVTdG9yZSB9IGZyb20gJy4uL2VtcGxveWVlcy9zdG9yZSc7XHJcbi8vIFJFTU9WRUQ6IFZvdWNoZXIgc3RvcmUgbm8gbG9uZ2VyIGV4aXN0cyAtIHVzaW5nIFBheW1lbnQvUmVjZWlwdCBzdG9yZXMgaW5zdGVhZFxyXG5pbXBvcnQgeyB1c2VQcm9kdWN0U3RvcmUgfSBmcm9tICcuLi9wcm9kdWN0cy9zdG9yZSc7XHJcbmltcG9ydCB7IGlzQ29tYm9Qcm9kdWN0IH0gZnJvbSAnLi4vcHJvZHVjdHMvY29tYm8tdXRpbHMnO1xyXG5pbXBvcnQgeyB1c2VTdG9ja0hpc3RvcnlTdG9yZSB9IGZyb20gJy4uL3N0b2NrLWhpc3Rvcnkvc3RvcmUnO1xyXG5pbXBvcnQgeyB1c2VDdXN0b21lclN0b3JlIH0gZnJvbSAnLi4vY3VzdG9tZXJzL3N0b3JlJztcclxuaW1wb3J0IHsgdXNlUmVjZWlwdFR5cGVTdG9yZSB9IGZyb20gJy4uL3NldHRpbmdzL3JlY2VpcHQtdHlwZXMvc3RvcmUnO1xyXG4vLyBSRU1PVkVEOiBpbXBvcnQgdHlwZSB7IFZvdWNoZXIgfSBmcm9tICcuLi92b3VjaGVycy90eXBlcyc7XHJcbmltcG9ydCB7IHVzZUNhc2hib29rU3RvcmUgfSBmcm9tICcuLi9jYXNoYm9vay9zdG9yZSc7XHJcbmltcG9ydCB7IHVzZVJlY2VpcHRTdG9yZSB9IGZyb20gJy4uL3JlY2VpcHRzL3N0b3JlJztcclxuaW1wb3J0IHR5cGUgeyBSZWNlaXB0LCBSZWNlaXB0T3JkZXJBbGxvY2F0aW9uIH0gZnJvbSAnLi4vcmVjZWlwdHMvdHlwZXMnO1xyXG5pbXBvcnQgeyB1c2VTYWxlc1JldHVyblN0b3JlIH0gZnJvbSAnLi4vc2FsZXMtcmV0dXJucy9zdG9yZSc7XHJcbmltcG9ydCB7IGNyZWF0ZVBheW1lbnREb2N1bWVudCwgY3JlYXRlUmVjZWlwdERvY3VtZW50IH0gZnJvbSAnLi4vZmluYW5jZS9kb2N1bWVudC1oZWxwZXJzJztcclxuaW1wb3J0IHsgdXNlU2hpcG1lbnRTdG9yZSB9IGZyb20gJy4uL3NoaXBtZW50cy9zdG9yZSc7XHJcbmltcG9ydCB0eXBlIHsgU2hpcG1lbnQgfSBmcm9tICcuLi9zaGlwbWVudHMvdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCB9IGZyb20gJy4uLy4uL2NvbnRleHRzL2F1dGgtY29udGV4dCc7XHJcblxyXG5pbXBvcnQgeyB1c2VTYWxlc01hbmFnZW1lbnRTZXR0aW5nc1N0b3JlIH0gZnJvbSAnLi4vc2V0dGluZ3Mvc2FsZXMvc2FsZXMtbWFuYWdlbWVudC1zdG9yZSc7XHJcbmltcG9ydCB7XHJcbiAgZ2V0Q3VycmVudFVzZXJJbmZvLFxyXG4gIGNyZWF0ZUNyZWF0ZWRFbnRyeSxcclxuICBjcmVhdGVIaXN0b3J5RW50cnksXHJcbiAgYXBwZW5kSGlzdG9yeUVudHJ5LFxyXG4gIHR5cGUgSGlzdG9yeUVudHJ5XHJcbn0gZnJvbSAnLi4vLi4vbGliL2FjdGl2aXR5LWhpc3RvcnktaGVscGVyJztcclxuXHJcbi8vIOKchSBIZWxwZXIgdG8gZ2V0IGJyYW5jaCBzeXN0ZW1JZFxyXG5jb25zdCBnZXRCcmFuY2hJZCA9IChvcmRlcjogT3JkZXIpID0+IG9yZGVyLmJyYW5jaFN5c3RlbUlkO1xyXG5cclxuY29uc3QgZGVsaXZlcnlTdGF0dXNlc0Jsb2NrZWRGb3JDYW5jZWxsYXRpb246IE9yZGVyRGVsaXZlcnlTdGF0dXNbXSA9IFtcclxuICAgICfEkGFuZyBnaWFvIGjDoG5nJyxcclxuICAgICfEkMOjIGdpYW8gaMOgbmcnLFxyXG4gICAgJ0No4budIGdpYW8gbOG6oWknLFxyXG5dO1xyXG5cclxuY29uc3QgSU5fU1RPUkVfUElDS1VQX1BSRUZJWCA9ICdJTlNUT1JFJztcclxuXHJcbmNvbnN0IFBBQ0tBR0lOR19DT0RFX1BSRUZJWCA9ICdERyc7XHJcbmNvbnN0IFBBQ0tBR0lOR19TWVNURU1fSURfUFJFRklYID0gJ1BBQ0tBR0UnO1xyXG5cclxuLy8g4pyFIFRyYWNrIHBhY2thZ2luZyBzeXN0ZW1JZCBjb3VudGVyIGdsb2JhbGx5XHJcbmxldCBwYWNrYWdpbmdTeXN0ZW1JZENvdW50ZXIgPSAwO1xyXG5cclxuLy8g4pyFIEluaXRpYWxpemUgY291bnRlciBmcm9tIGFsbCBleGlzdGluZyBwYWNrYWdpbmdzIGFjcm9zcyBhbGwgb3JkZXJzXHJcbmNvbnN0IGluaXRQYWNrYWdpbmdDb3VudGVyID0gKG9yZGVyczogT3JkZXJbXSk6IHZvaWQgPT4ge1xyXG4gICAgY29uc3QgYWxsUGFja2FnaW5ncyA9IG9yZGVycy5mbGF0TWFwKG8gPT4gby5wYWNrYWdpbmdzIHx8IFtdKTtcclxuICAgIHBhY2thZ2luZ1N5c3RlbUlkQ291bnRlciA9IGdldE1heFN5c3RlbUlkQ291bnRlcihhbGxQYWNrYWdpbmdzLCBQQUNLQUdJTkdfU1lTVEVNX0lEX1BSRUZJWCk7XHJcbn07XHJcblxyXG4vLyDinIUgR2VuZXJhdGUgbmV4dCBwYWNrYWdpbmcgc3lzdGVtSWRcclxuY29uc3QgZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkID0gKCk6IFN5c3RlbUlkID0+IHtcclxuICAgIHBhY2thZ2luZ1N5c3RlbUlkQ291bnRlcisrO1xyXG4gICAgcmV0dXJuIGFzU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZCgncGFja2FnaW5nJywgcGFja2FnaW5nU3lzdGVtSWRDb3VudGVyKSk7XHJcbn07XHJcblxyXG5jb25zdCBnZXRQYWNrYWdpbmdTdWZmaXhGcm9tT3JkZXJJZCA9IChvcmRlcklkPzogQnVzaW5lc3NJZCkgPT4ge1xyXG4gICAgaWYgKCFvcmRlcklkKSByZXR1cm4gJyc7XHJcbiAgICBjb25zdCByYXdWYWx1ZSA9IGAke29yZGVySWR9YDtcclxuICAgIGNvbnN0IHN1ZmZpeCA9IHJhd1ZhbHVlLnJlcGxhY2UoL15bQS1aLV0rLywgJycpO1xyXG4gICAgcmV0dXJuIHN1ZmZpeCB8fCByYXdWYWx1ZTtcclxufTtcclxuXHJcbi8vIENvdW50IG9ubHkgYWN0aXZlIHBhY2thZ2luZ3MgKG5vdCBjYW5jZWxsZWQpIGZvciBudW1iZXJpbmdcclxuY29uc3QgZ2V0QWN0aXZlUGFja2FnaW5nQ291bnQgPSAocGFja2FnaW5nczogUGFja2FnaW5nW10pOiBudW1iZXIgPT4ge1xyXG4gICAgcmV0dXJuIHBhY2thZ2luZ3MuZmlsdGVyKHAgPT4gcC5zdGF0dXMgIT09ICdI4buneSDEkcOzbmcgZ8OzaScpLmxlbmd0aDtcclxufTtcclxuXHJcbmNvbnN0IGJ1aWxkUGFja2FnaW5nQnVzaW5lc3NJZCA9IChvcmRlcklkOiBCdXNpbmVzc0lkLCBhY3RpdmVJbmRleDogbnVtYmVyLCBhY3RpdmVDb3VudDogbnVtYmVyKTogQnVzaW5lc3NJZCA9PiB7XHJcbiAgICBjb25zdCBzdWZmaXggPSBnZXRQYWNrYWdpbmdTdWZmaXhGcm9tT3JkZXJJZChvcmRlcklkKTtcclxuICAgIGNvbnN0IGJhc2VDb2RlID0gYCR7UEFDS0FHSU5HX0NPREVfUFJFRklYfSR7c3VmZml4IHx8ICcwMDAwMDAnfWA7XHJcbiAgICAvLyBPbmx5IGFkZCBzdWZmaXggaWYgdGhlcmUgYXJlIG11bHRpcGxlIGFjdGl2ZSBwYWNrYWdpbmdzXHJcbiAgICBpZiAoYWN0aXZlQ291bnQgPiAxICYmIGFjdGl2ZUluZGV4ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhZGRlZEluZGV4ID0gU3RyaW5nKGFjdGl2ZUluZGV4ICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICByZXR1cm4gYXNCdXNpbmVzc0lkKGAke2Jhc2VDb2RlfS0ke3BhZGRlZEluZGV4fWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFzQnVzaW5lc3NJZChiYXNlQ29kZSk7XHJcbn07XHJcblxyXG5jb25zdCBnZXRSZXR1cm5lZFZhbHVlRm9yT3JkZXIgPSAob3JkZXJTeXN0ZW1JZDogU3lzdGVtSWQpOiBudW1iZXIgPT4ge1xyXG4gICAgcmV0dXJuIHVzZVNhbGVzUmV0dXJuU3RvcmUuZ2V0U3RhdGUoKS5kYXRhXHJcbiAgICAgICAgLmZpbHRlcihzciA9PiBzci5vcmRlclN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgc3IpID0+IHN1bSArIHNyLnRvdGFsUmV0dXJuVmFsdWUsIDApO1xyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlQWN0dWFsRGVidCA9IChvcmRlcjogT3JkZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgY29uc3QgdG90YWxSZXR1cm5lZFZhbHVlID0gZ2V0UmV0dXJuZWRWYWx1ZUZvck9yZGVyKG9yZGVyLnN5c3RlbUlkKTtcclxuICAgIHJldHVybiBNYXRoLm1heChvcmRlci5ncmFuZFRvdGFsIC0gdG90YWxSZXR1cm5lZFZhbHVlLCAwKTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZVRvdGFsUGFpZCA9IChwYXltZW50czogT3JkZXJQYXltZW50W10pOiBudW1iZXIgPT4ge1xyXG4gICAgcmV0dXJuIHBheW1lbnRzLnJlZHVjZSgoc3VtLCBwYXltZW50KSA9PiBzdW0gKyBwYXltZW50LmFtb3VudCwgMCk7XHJcbn07XHJcblxyXG5jb25zdCBnZXRPcmRlck91dHN0YW5kaW5nQW1vdW50ID0gKG9yZGVyOiBPcmRlcik6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCBhY3R1YWxEZWJ0ID0gY2FsY3VsYXRlQWN0dWFsRGVidChvcmRlcik7XHJcbiAgICBjb25zdCB0b3RhbFBhaWQgPSBjYWxjdWxhdGVUb3RhbFBhaWQob3JkZXIucGF5bWVudHMgPz8gW10pO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KGFjdHVhbERlYnQgLSB0b3RhbFBhaWQsIDApO1xyXG59O1xyXG5cclxuY29uc3QgYXBwbHlQYXltZW50VG9PcmRlciA9IChvcmRlcjogT3JkZXIsIHBheW1lbnQ6IE9yZGVyUGF5bWVudCk6IE9yZGVyID0+IHtcclxuICAgIGNvbnN0IHVwZGF0ZWRQYXltZW50cyA9IFsuLi4ob3JkZXIucGF5bWVudHMgPz8gW10pLCBwYXltZW50XTtcclxuICAgIGNvbnN0IHRvdGFsUGFpZCA9IGNhbGN1bGF0ZVRvdGFsUGFpZCh1cGRhdGVkUGF5bWVudHMpO1xyXG4gICAgY29uc3QgYWN0dWFsRGVidCA9IGNhbGN1bGF0ZUFjdHVhbERlYnQob3JkZXIpO1xyXG5cclxuICAgIGxldCBuZXdQYXltZW50U3RhdHVzOiBPcmRlclBheW1lbnRTdGF0dXMgPSAnQ2jGsGEgdGhhbmggdG/DoW4nO1xyXG4gICAgaWYgKHRvdGFsUGFpZCA+PSBhY3R1YWxEZWJ0KSB7XHJcbiAgICAgICAgbmV3UGF5bWVudFN0YXR1cyA9ICdUaGFuaCB0b8OhbiB0b8OgbiBi4buZJztcclxuICAgIH0gZWxzZSBpZiAodG90YWxQYWlkID4gMCkge1xyXG4gICAgICAgIG5ld1BheW1lbnRTdGF0dXMgPSAnVGhhbmggdG/DoW4gMSBwaOG6p24nO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdhc0NvbXBsZXRlZCA9IG9yZGVyLnN0YXR1cyA9PT0gJ0hvw6BuIHRow6BuaCc7XHJcbiAgICBsZXQgbmV3U3RhdHVzID0gb3JkZXIuc3RhdHVzO1xyXG4gICAgbGV0IG5ld0NvbXBsZXRlZERhdGUgPSBvcmRlci5jb21wbGV0ZWREYXRlO1xyXG5cclxuICAgIGlmIChuZXdQYXltZW50U3RhdHVzID09PSAnVGhhbmggdG/DoW4gdG/DoG4gYuG7mScgJiYgb3JkZXIuZGVsaXZlcnlTdGF0dXMgPT09ICfEkMOjIGdpYW8gaMOgbmcnKSB7XHJcbiAgICAgICAgbmV3U3RhdHVzID0gJ0hvw6BuIHRow6BuaCc7XHJcbiAgICAgICAgbmV3Q29tcGxldGVkRGF0ZSA9IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSk7XHJcbiAgICAgICAgaWYgKCF3YXNDb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNyZW1lbnRPcmRlclN0YXRzIH0gPSB1c2VDdXN0b21lclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgIGluY3JlbWVudE9yZGVyU3RhdHMob3JkZXIuY3VzdG9tZXJTeXN0ZW1JZCwgb3JkZXIuZ3JhbmRUb3RhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgdXBkYXRlRGVidFRyYW5zYWN0aW9uUGF5bWVudCB9ID0gdXNlQ3VzdG9tZXJTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgdXBkYXRlRGVidFRyYW5zYWN0aW9uUGF5bWVudChvcmRlci5jdXN0b21lclN5c3RlbUlkLCBvcmRlci5pZCwgcGF5bWVudC5hbW91bnQpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ub3JkZXIsXHJcbiAgICAgICAgcGF5bWVudHM6IHVwZGF0ZWRQYXltZW50cyxcclxuICAgICAgICBwYXltZW50U3RhdHVzOiBuZXdQYXltZW50U3RhdHVzLFxyXG4gICAgICAgIHN0YXR1czogbmV3U3RhdHVzLFxyXG4gICAgICAgIGNvbXBsZXRlZERhdGU6IG5ld0NvbXBsZXRlZERhdGUsXHJcbiAgICAgICAgcGFpZEFtb3VudDogdG90YWxQYWlkLFxyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IHNob3VsZEF1dG9BbGxvY2F0ZVJlY2VpcHQgPSAocmVjZWlwdDogUmVjZWlwdCk6IGJvb2xlYW4gPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICByZWNlaXB0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiZcclxuICAgICAgICByZWNlaXB0LmFmZmVjdHNEZWJ0ICYmXHJcbiAgICAgICAgISFyZWNlaXB0LmN1c3RvbWVyU3lzdGVtSWQgJiZcclxuICAgICAgICAhcmVjZWlwdC5saW5rZWRPcmRlclN5c3RlbUlkXHJcbiAgICApO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0QWxsb2NhdGVkQW1vdW50ID0gKHJlY2VpcHQ6IFJlY2VpcHQpOiBudW1iZXIgPT4ge1xyXG4gICAgcmV0dXJuIHJlY2VpcHQub3JkZXJBbGxvY2F0aW9ucz8ucmVkdWNlKChzdW0sIGFsbG9jYXRpb24pID0+IHN1bSArIGFsbG9jYXRpb24uYW1vdW50LCAwKSA/PyAwO1xyXG59O1xyXG5cclxuY29uc3QgYXV0b0FsbG9jYXRlUmVjZWlwdFRvT3JkZXJzID0gKHJlY2VpcHQ6IFJlY2VpcHQpID0+IHtcclxuICAgIGlmICghc2hvdWxkQXV0b0FsbG9jYXRlUmVjZWlwdChyZWNlaXB0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZW1haW5pbmdBbW91bnQgPSByZWNlaXB0LmFtb3VudCAtIGdldEFsbG9jYXRlZEFtb3VudChyZWNlaXB0KTtcclxuICAgIGlmIChyZW1haW5pbmdBbW91bnQgPD0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjYW5kaWRhdGVPcmRlcnMgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhXHJcbiAgICAgICAgLmZpbHRlcihvcmRlciA9PiBvcmRlci5jdXN0b21lclN5c3RlbUlkID09PSByZWNlaXB0LmN1c3RvbWVyU3lzdGVtSWQgJiYgb3JkZXIuc3RhdHVzICE9PSAnxJDDoyBo4buneScpXHJcbiAgICAgICAgLm1hcChvcmRlciA9PiAoeyBvcmRlciwgb3V0c3RhbmRpbmc6IGdldE9yZGVyT3V0c3RhbmRpbmdBbW91bnQob3JkZXIpIH0pKVxyXG4gICAgICAgIC5maWx0ZXIoZW50cnkgPT4gZW50cnkub3V0c3RhbmRpbmcgPiAwKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFUaW1lID0gYS5vcmRlci5vcmRlckRhdGUgPyBuZXcgRGF0ZShhLm9yZGVyLm9yZGVyRGF0ZSkuZ2V0VGltZSgpIDogMDtcclxuICAgICAgICAgICAgY29uc3QgYlRpbWUgPSBiLm9yZGVyLm9yZGVyRGF0ZSA/IG5ldyBEYXRlKGIub3JkZXIub3JkZXJEYXRlKS5nZXRUaW1lKCkgOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBpZiAoIWNhbmRpZGF0ZU9yZGVycy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFtb3VudFRvRGlzdHJpYnV0ZSA9IHJlbWFpbmluZ0Ftb3VudDtcclxuICAgIGNvbnN0IHVwZGF0ZWRPcmRlcnMgPSBuZXcgTWFwPFN5c3RlbUlkLCBPcmRlcj4oKTtcclxuICAgIGNvbnN0IGFsbG9jYXRpb25FbnRyaWVzOiBSZWNlaXB0T3JkZXJBbGxvY2F0aW9uW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHsgb3JkZXIgfSBvZiBjYW5kaWRhdGVPcmRlcnMpIHtcclxuICAgICAgICBpZiAoYW1vdW50VG9EaXN0cmlidXRlIDw9IDApIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50T3JkZXJTdGF0ZSA9IHVwZGF0ZWRPcmRlcnMuZ2V0KG9yZGVyLnN5c3RlbUlkKSA/PyBvcmRlcjtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZyA9IGdldE9yZGVyT3V0c3RhbmRpbmdBbW91bnQoY3VycmVudE9yZGVyU3RhdGUpO1xyXG4gICAgICAgIGlmIChvdXRzdGFuZGluZyA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGlvbkFtb3VudCA9IE1hdGgubWluKG91dHN0YW5kaW5nLCBhbW91bnRUb0Rpc3RyaWJ1dGUpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0aW9uQW1vdW50IDw9IDApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwYXltZW50RW50cnk6IE9yZGVyUGF5bWVudCA9IHtcclxuICAgICAgICAgICAgc3lzdGVtSWQ6IHJlY2VpcHQuc3lzdGVtSWQsXHJcbiAgICAgICAgICAgIGlkOiByZWNlaXB0LmlkLFxyXG4gICAgICAgICAgICBkYXRlOiByZWNlaXB0LmRhdGUsXHJcbiAgICAgICAgICAgIGFtb3VudDogYWxsb2NhdGlvbkFtb3VudCxcclxuICAgICAgICAgICAgbWV0aG9kOiByZWNlaXB0LnBheW1lbnRNZXRob2ROYW1lLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnk6IGFzU3lzdGVtSWQocmVjZWlwdC5jcmVhdGVkQnkpLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcmVjZWlwdC5kZXNjcmlwdGlvbiA/PyBgVGhhbmggdG/DoW4gdOG7qyBwaGnhur91IHRodSAke3JlY2VpcHQuaWR9YCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSBhcHBseVBheW1lbnRUb09yZGVyKGN1cnJlbnRPcmRlclN0YXRlLCBwYXltZW50RW50cnkpO1xyXG4gICAgICAgIHVwZGF0ZWRPcmRlcnMuc2V0KG9yZGVyLnN5c3RlbUlkLCB1cGRhdGVkT3JkZXIpO1xyXG4gICAgICAgIGFsbG9jYXRpb25FbnRyaWVzLnB1c2goe1xyXG4gICAgICAgICAgICBvcmRlclN5c3RlbUlkOiBvcmRlci5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgb3JkZXJJZDogb3JkZXIuaWQsXHJcbiAgICAgICAgICAgIGFtb3VudDogYWxsb2NhdGlvbkFtb3VudCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYW1vdW50VG9EaXN0cmlidXRlIC09IGFsbG9jYXRpb25BbW91bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhbGxvY2F0aW9uRW50cmllcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gc3RhdGUuZGF0YS5tYXAob3JkZXIgPT4gdXBkYXRlZE9yZGVycy5nZXQob3JkZXIuc3lzdGVtSWQpID8/IG9yZGVyKTtcclxuICAgICAgICByZXR1cm4geyBkYXRhIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZWNlaXB0U3RvcmUgPSB1c2VSZWNlaXB0U3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IGxhdGVzdFJlY2VpcHQgPSByZWNlaXB0U3RvcmUuZmluZEJ5SWQocmVjZWlwdC5zeXN0ZW1JZCk7XHJcbiAgICBpZiAoIWxhdGVzdFJlY2VpcHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVjZWlwdFN0b3JlLnVwZGF0ZShyZWNlaXB0LnN5c3RlbUlkLCB7XHJcbiAgICAgICAgLi4ubGF0ZXN0UmVjZWlwdCxcclxuICAgICAgICBvcmRlckFsbG9jYXRpb25zOiBbLi4uKGxhdGVzdFJlY2VpcHQub3JkZXJBbGxvY2F0aW9ucyA/PyBbXSksIC4uLmFsbG9jYXRpb25FbnRyaWVzXSxcclxuICAgIH0pO1xyXG59O1xyXG5cclxuY29uc3QgZW5zdXJlT3JkZXJQYWNrYWdpbmdJZGVudGlmaWVycyA9IChvcmRlcjogT3JkZXIpOiBPcmRlciB8IG51bGwgPT4ge1xyXG4gICAgaWYgKCFvcmRlci5wYWNrYWdpbmdzIHx8IG9yZGVyLnBhY2thZ2luZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ291bnQgb25seSBhY3RpdmUgcGFja2FnaW5ncyBmb3IgcHJvcGVyIG51bWJlcmluZ1xyXG4gICAgY29uc3QgYWN0aXZlUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MuZmlsdGVyKHAgPT4gcC5zdGF0dXMgIT09ICdI4buneSDEkcOzbmcgZ8OzaScpO1xyXG4gICAgY29uc3QgYWN0aXZlQ291bnQgPSBhY3RpdmVQYWNrYWdpbmdzLmxlbmd0aDtcclxuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBsZXQgYWN0aXZlSW5kZXggPSAwO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWRQYWNrYWdpbmdzID0gb3JkZXIucGFja2FnaW5ncy5tYXAoKHBrZywgaWR4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNDYW5jZWxsZWQgPSBwa2cuc3RhdHVzID09PSAnSOG7p3kgxJHDs25nIGfDs2knO1xyXG4gICAgICAgIGNvbnN0IGhhc0lkID0gdHlwZW9mIHBrZy5pZCA9PT0gJ3N0cmluZycgJiYgcGtnLmlkLnRyaW0oKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIC8vIOKchSBDaGVjayBmb3IgdGVtcCBzeXN0ZW1JZCBvciBvbGQgZm9ybWF0IChQS0dfKVxyXG4gICAgICAgIGNvbnN0IGhhc1RlbXBPck9sZFN5c3RlbUlkID0gcGtnLnN5c3RlbUlkPy5zdGFydHNXaXRoKCdQS0dfVEVNUF8nKSB8fCBwa2cuc3lzdGVtSWQ/LnN0YXJ0c1dpdGgoJ1BLR18nKTtcclxuICAgICAgICBjb25zdCBoYXNWYWxpZFN5c3RlbUlkID0gcGtnLnN5c3RlbUlkPy5zdGFydHNXaXRoKFBBQ0tBR0lOR19TWVNURU1fSURfUFJFRklYKTtcclxuICAgICAgICBjb25zdCBzaG91bGRGaXhUcmFja2luZyA9IHBrZy5kZWxpdmVyeU1ldGhvZCA9PT0gJ05o4bqtbiB04bqhaSBj4butYSBow6BuZycgJiYgcGtnLnRyYWNraW5nQ29kZSA9PT0gYCR7SU5fU1RPUkVfUElDS1VQX1BSRUZJWH0tYDtcclxuXHJcbiAgICAgICAgLy8gRm9yIGNhbmNlbGxlZCBwYWNrYWdpbmdzLCBrZWVwIGV4aXN0aW5nIElEXHJcbiAgICAgICAgaWYgKGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzSWQgfHwgKGhhc1RlbXBPck9sZFN5c3RlbUlkICYmICFoYXNWYWxpZFN5c3RlbUlkKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RpbGwgbmVlZCB0byBhc3NpZ24gYW4gSUQgaWYgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBrZyA9IHsgLi4ucGtnIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBrZy5pZCA9IGJ1aWxkUGFja2FnaW5nQnVzaW5lc3NJZChvcmRlci5pZCwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVGVtcE9yT2xkU3lzdGVtSWQgJiYgIWhhc1ZhbGlkU3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0UGtnLnN5c3RlbUlkID0gZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UGtnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwa2c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGb3IgYWN0aXZlIHBhY2thZ2luZ3MsIHVzZSBhY3RpdmVJbmRleCBmb3IgbnVtYmVyaW5nXHJcbiAgICAgICAgY29uc3QgY3VycmVudEFjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXg7XHJcbiAgICAgICAgYWN0aXZlSW5kZXgrKztcclxuXHJcbiAgICAgICAgaWYgKGhhc0lkICYmICFzaG91bGRGaXhUcmFja2luZyAmJiBoYXNWYWxpZFN5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwa2c7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXh0UGtnID0geyAuLi5wa2cgfTtcclxuICAgICAgICBpZiAoIWhhc0lkKSB7XHJcbiAgICAgICAgICAgIG5leHRQa2cuaWQgPSBidWlsZFBhY2thZ2luZ0J1c2luZXNzSWQob3JkZXIuaWQsIGN1cnJlbnRBY3RpdmVJbmRleCwgYWN0aXZlQ291bnQpO1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g4pyFIEZpeCB0ZW1wb3Jhcnkvb2xkIHN5c3RlbUlkIHRvIHByb3BlciBmb3JtYXQgUEFDS0FHRTAwMDAwMVxyXG4gICAgICAgIGlmIChoYXNUZW1wT3JPbGRTeXN0ZW1JZCAmJiAhaGFzVmFsaWRTeXN0ZW1JZCkge1xyXG4gICAgICAgICAgICBuZXh0UGtnLnN5c3RlbUlkID0gZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkKCk7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3VsZEZpeFRyYWNraW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSWQgPSBuZXh0UGtnLmlkID8/IGJ1aWxkUGFja2FnaW5nQnVzaW5lc3NJZChvcmRlci5pZCwgY3VycmVudEFjdGl2ZUluZGV4LCBhY3RpdmVDb3VudCk7XHJcbiAgICAgICAgICAgIG5leHRQa2cudHJhY2tpbmdDb2RlID0gYCR7SU5fU1RPUkVfUElDS1VQX1BSRUZJWH0tJHtyZXNvbHZlZElkfWA7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHRQa2c7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY2hhbmdlZCA/IHsgLi4ub3JkZXIsIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzIH0gOiBudWxsO1xyXG59O1xyXG5cclxuY29uc3QgZW5zdXJlQ2FuY2VsbGF0aW9uQWxsb3dlZCA9IChvcmRlcjogT3JkZXIgfCB1bmRlZmluZWQsIGFjdGlvbkxhYmVsOiBzdHJpbmcpID0+IHtcclxuICAgIGlmICghb3JkZXIpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBjb25zdCB7IGFsbG93Q2FuY2VsQWZ0ZXJFeHBvcnQgfSA9IHVzZVNhbGVzTWFuYWdlbWVudFNldHRpbmdzU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGlmIChhbGxvd0NhbmNlbEFmdGVyRXhwb3J0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFzTGVmdFdhcmVob3VzZSA9XHJcbiAgICAgICAgb3JkZXIuc3RvY2tPdXRTdGF0dXMgPT09ICdYdeG6pXQga2hvIHRvw6BuIGLhu5knIHx8XHJcbiAgICAgICAgZGVsaXZlcnlTdGF0dXNlc0Jsb2NrZWRGb3JDYW5jZWxsYXRpb24uaW5jbHVkZXMob3JkZXIuZGVsaXZlcnlTdGF0dXMpO1xyXG5cclxuICAgIGlmIChoYXNMZWZ0V2FyZWhvdXNlKSB7XHJcbiAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgIGBLaMO0bmcgdGjhu4MgJHthY3Rpb25MYWJlbH0gdsOsIMSRxqFuIGjDoG5nIMSRw6MgeHXhuqV0IGtoby4gVsOgbyBD4bqldSBow6xuaCBiw6FuIGjDoG5nIC0+IFRoaeG6v3QgbOG6rXAgcXXhuqNuIGzDvSBiw6FuIGjDoG5nIHbDoCBi4bqtdCBcIkNobyBwaMOpcCBo4buneSDEkcahbiBow6BuZyBzYXUga2hpIHh14bqldCBraG9cIi5gLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIOKchSBIZWxwZXIgxJHhu4MgeOG7rSBsw70gc3RvY2sgY2hvIGNvbWJvIGhv4bq3YyBz4bqjbiBwaOG6qW0gdGjGsOG7nW5nXHJcbiAqIENvbWJvIGtow7RuZyBjw7MgdOG7k24ga2hvIHRo4buxYyB04bq/IC0gdGhhbyB0w6FjIHRyw6puIFNQIGNvblxyXG4gKi9cclxudHlwZSBTdG9ja09wZXJhdGlvbiA9ICdjb21taXQnIHwgJ3VuY29tbWl0JyB8ICdkaXNwYXRjaCcgfCAnY29tcGxldGUnIHwgJ3JldHVybic7XHJcblxyXG5jb25zdCBwcm9jZXNzTGluZUl0ZW1TdG9jayA9IChcclxuICAgIGxpbmVJdGVtOiB7IHByb2R1Y3RTeXN0ZW1JZDogc3RyaW5nOyBxdWFudGl0eTogbnVtYmVyIH0sXHJcbiAgICBicmFuY2hTeXN0ZW1JZDogc3RyaW5nLFxyXG4gICAgb3BlcmF0aW9uOiBTdG9ja09wZXJhdGlvbixcclxuICAgIG9yZGVyUXVhbnRpdHk6IG51bWJlciA9IDEgLy8gU+G7kSBsxrDhu6NuZyDEkeG6t3QgY+G7p2EgbGluZSBpdGVtXHJcbikgPT4ge1xyXG4gICAgY29uc3QgeyBcclxuICAgICAgICBmaW5kQnlJZDogZmluZFByb2R1Y3RCeUlkLCBcclxuICAgICAgICBjb21taXRTdG9jaywgXHJcbiAgICAgICAgdW5jb21taXRTdG9jaywgXHJcbiAgICAgICAgZGlzcGF0Y2hTdG9jaywgXHJcbiAgICAgICAgY29tcGxldGVEZWxpdmVyeSwgXHJcbiAgICAgICAgcmV0dXJuU3RvY2tGcm9tVHJhbnNpdCBcclxuICAgIH0gPSB1c2VQcm9kdWN0U3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvZHVjdCA9IGZpbmRQcm9kdWN0QnlJZChhc1N5c3RlbUlkKGxpbmVJdGVtLnByb2R1Y3RTeXN0ZW1JZCkpO1xyXG4gICAgXHJcbiAgICAvLyBYw6FjIMSR4buLbmggZGFuaCBzw6FjaCBpdGVtcyBj4bqnbiB44butIGzDvSAoU1AgY29uIG7hur91IGNvbWJvLCBob+G6t2MgY2jDrW5oIFNQIG7hur91IHRoxrDhu51uZylcclxuICAgIGNvbnN0IGl0ZW1zVG9Qcm9jZXNzOiB7IHByb2R1Y3RTeXN0ZW1JZDogU3lzdGVtSWQ7IHF1YW50aXR5OiBudW1iZXIgfVtdID0gW107XHJcbiAgICBcclxuICAgIGlmIChwcm9kdWN0ICYmIGlzQ29tYm9Qcm9kdWN0KHByb2R1Y3QpICYmIHByb2R1Y3QuY29tYm9JdGVtcykge1xyXG4gICAgICAgIC8vIENvbWJvOiB44butIGzDvSB04bqldCBj4bqjIFNQIGNvblxyXG4gICAgICAgIHByb2R1Y3QuY29tYm9JdGVtcy5mb3JFYWNoKGNvbWJvSXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGl0ZW1zVG9Qcm9jZXNzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgcHJvZHVjdFN5c3RlbUlkOiBhc1N5c3RlbUlkKGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQpLFxyXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IG9yZGVyUXVhbnRpdHkgKiBjb21ib0l0ZW0ucXVhbnRpdHksIC8vIFPhu5EgbMaw4bujbmcgY29tYm8gw5cgc+G7kSBsxrDhu6NuZyBTUCBjb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFPhuqNuIHBo4bqpbSB0aMaw4budbmdcclxuICAgICAgICBpdGVtc1RvUHJvY2Vzcy5wdXNoKHtcclxuICAgICAgICAgICAgcHJvZHVjdFN5c3RlbUlkOiBhc1N5c3RlbUlkKGxpbmVJdGVtLnByb2R1Y3RTeXN0ZW1JZCksXHJcbiAgICAgICAgICAgIHF1YW50aXR5OiBvcmRlclF1YW50aXR5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUaOG7sWMgaGnhu4duIG9wZXJhdGlvbiBjaG8gdOG7q25nIGl0ZW1cclxuICAgIGl0ZW1zVG9Qcm9jZXNzLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoSWQgPSBhc1N5c3RlbUlkKGJyYW5jaFN5c3RlbUlkKTtcclxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlICdjb21taXQnOlxyXG4gICAgICAgICAgICAgICAgY29tbWl0U3RvY2soaXRlbS5wcm9kdWN0U3lzdGVtSWQsIGJyYW5jaElkLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd1bmNvbW1pdCc6XHJcbiAgICAgICAgICAgICAgICB1bmNvbW1pdFN0b2NrKGl0ZW0ucHJvZHVjdFN5c3RlbUlkLCBicmFuY2hJZCwgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGlzcGF0Y2gnOlxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hTdG9jayhpdGVtLnByb2R1Y3RTeXN0ZW1JZCwgYnJhbmNoSWQsIGl0ZW0ucXVhbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVsaXZlcnkoaXRlbS5wcm9kdWN0U3lzdGVtSWQsIGJyYW5jaElkLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuU3RvY2tGcm9tVHJhbnNpdChpdGVtLnByb2R1Y3RTeXN0ZW1JZCwgYnJhbmNoSWQsIGl0ZW0ucXVhbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBpdGVtc1RvUHJvY2VzczsgLy8gUmV0dXJuIMSR4buDIGPDsyB0aOG7gyBkw7luZyBjaG8gc3RvY2sgaGlzdG9yeVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIOKchSBIZWxwZXIgxJHhu4MgbOG6pXkgZGFuaCBzw6FjaCBzdG9jayBpdGVtcyB04burIGxpbmUgaXRlbXMgKG3hu58gcuG7mW5nIGNvbWJvIHRow6BuaCBTUCBjb24pXHJcbiAqIETDuW5nIHRyb25nIHdlYmhvb2sgR0hUSyBob+G6t2MgY8OhYyB0aGFvIHTDoWMgYmF0Y2hcclxuICovXHJcbmNvbnN0IGdldENvbWJvU3RvY2tJdGVtcyA9IChsaW5lSXRlbXM6IHsgcHJvZHVjdFN5c3RlbUlkOiBzdHJpbmc7IHF1YW50aXR5OiBudW1iZXIgfVtdKTogeyBwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkOyBxdWFudGl0eTogbnVtYmVyIH1bXSA9PiB7XHJcbiAgICBjb25zdCB7IGZpbmRCeUlkOiBmaW5kUHJvZHVjdEJ5SWQgfSA9IHVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgY29uc3Qgc3RvY2tJdGVtczogeyBwcm9kdWN0U3lzdGVtSWQ6IFN5c3RlbUlkOyBxdWFudGl0eTogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgXHJcbiAgICBsaW5lSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBwcm9kdWN0ID0gZmluZFByb2R1Y3RCeUlkKGFzU3lzdGVtSWQoaXRlbS5wcm9kdWN0U3lzdGVtSWQpKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJvZHVjdCAmJiBpc0NvbWJvUHJvZHVjdChwcm9kdWN0KSAmJiBwcm9kdWN0LmNvbWJvSXRlbXMpIHtcclxuICAgICAgICAgICAgLy8gQ29tYm86IG3hu58gcuG7mW5nIHRow6BuaCBTUCBjb25cclxuICAgICAgICAgICAgcHJvZHVjdC5jb21ib0l0ZW1zLmZvckVhY2goY29tYm9JdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIHN0b2NrSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFN5c3RlbUlkOiBhc1N5c3RlbUlkKGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5ICogY29tYm9JdGVtLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFPhuqNuIHBo4bqpbSB0aMaw4budbmdcclxuICAgICAgICAgICAgc3RvY2tJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RTeXN0ZW1JZDogYXNTeXN0ZW1JZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCksXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBzdG9ja0l0ZW1zO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlT3JkZXJSZWZ1bmRWb3VjaGVyID0gKG9yZGVyOiBPcmRlciwgYW1vdW50OiBudW1iZXIsIGVtcGxveWVlSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICBjb25zdCBsYXN0UG9zaXRpdmVQYXltZW50ID0gWy4uLihvcmRlci5wYXltZW50cyA/PyBbXSldLnJldmVyc2UoKS5maW5kKHAgPT4gcC5hbW91bnQgPiAwKTtcclxuICAgIGNvbnN0IHsgZG9jdW1lbnQsIGVycm9yIH0gPSBjcmVhdGVQYXltZW50RG9jdW1lbnQoe1xyXG4gICAgICAgIGFtb3VudCxcclxuICAgICAgICBkZXNjcmlwdGlvbjogYEhvw6BuIHRp4buBbiBkbyBo4buneSDEkcahbiAke29yZGVyLmlkfWAsXHJcbiAgICAgICAgcmVjaXBpZW50TmFtZTogb3JkZXIuY3VzdG9tZXJOYW1lLFxyXG4gICAgICAgIHJlY2lwaWVudFN5c3RlbUlkOiBvcmRlci5jdXN0b21lclN5c3RlbUlkLFxyXG4gICAgICAgIGN1c3RvbWVyU3lzdGVtSWQ6IG9yZGVyLmN1c3RvbWVyU3lzdGVtSWQsXHJcbiAgICAgICAgY3VzdG9tZXJOYW1lOiBvcmRlci5jdXN0b21lck5hbWUsXHJcbiAgICAgICAgYnJhbmNoU3lzdGVtSWQ6IG9yZGVyLmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgICAgIGJyYW5jaE5hbWU6IG9yZGVyLmJyYW5jaE5hbWUsXHJcbiAgICAgICAgY3JlYXRlZEJ5OiBlbXBsb3llZUlkLFxyXG4gICAgICAgIHBheW1lbnRNZXRob2ROYW1lOiBsYXN0UG9zaXRpdmVQYXltZW50Py5tZXRob2QgfHwgJ1Rp4buBbiBt4bq3dCcsXHJcbiAgICAgICAgcGF5bWVudFR5cGVOYW1lOiAnSG/DoG4gdGnhu4FuIGtow6FjaCBow6BuZycsXHJcbiAgICAgICAgb3JpZ2luYWxEb2N1bWVudElkOiBvcmRlci5pZCxcclxuICAgICAgICBsaW5rZWRPcmRlclN5c3RlbUlkOiBvcmRlci5zeXN0ZW1JZCxcclxuICAgICAgICBhZmZlY3RzRGVidDogdHJ1ZSxcclxuICAgICAgICBjYXRlZ29yeTogJ290aGVyJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghZG9jdW1lbnQpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbY2FuY2VsT3JkZXJdIEtow7RuZyB0aOG7gyB04bqhbyBwaGnhur91IGNoaSBob8OgbiB0aeG7gW4nLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRvY3VtZW50O1xyXG59O1xyXG5cclxuLy8gUkVNT1ZFRDogaW5pdGlhbERhdGFPbWl0IHRyYW5zZm9ybWF0aW9uIC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbmNvbnN0IGluaXRpYWxEYXRhOiBPcmRlcltdID0gW107XHJcblxyXG5jb25zdCBiYXNlU3RvcmUgPSBjcmVhdGVDcnVkU3RvcmU8T3JkZXI+KFtdLCAnb3JkZXJzJywge1xyXG4gIGJ1c2luZXNzSWRGaWVsZDogJ2lkJyxcclxuICBhcGlFbmRwb2ludDogJy9hcGkvb3JkZXJzJyxcclxuICBnZXRDdXJyZW50VXNlcjogKCkgPT4ge1xyXG4gICAgcmV0dXJuIGFzU3lzdGVtSWQoZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCgpKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLy8g4pyFIEFQSSBTeW5jIGhlbHBlcnNcclxuY29uc3QgQVBJX0VORFBPSU5UID0gJy9hcGkvb3JkZXJzJztcclxuXHJcbmNvbnN0IHN5bmNUb0FwaSA9IHtcclxuICBjcmVhdGU6IGFzeW5jIChvcmRlcjogT3JkZXIpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goQVBJX0VORFBPSU5ULCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcmRlciksXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSBjb25zb2xlLndhcm4oJ1tPcmRlciBBUEldIENyZWF0ZSBzeW5jIGZhaWxlZCcpO1xyXG4gICAgICBlbHNlIGNvbnNvbGUubG9nKCdbT3JkZXIgQVBJXSBDcmVhdGVkOicsIG9yZGVyLnN5c3RlbUlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbT3JkZXIgQVBJXSBDcmVhdGUgc3luYyBlcnJvcjonLCBlKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHVwZGF0ZTogYXN5bmMgKHN5c3RlbUlkOiBTeXN0ZW1JZCwgdXBkYXRlczogUGFydGlhbDxPcmRlcj4pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0VORFBPSU5UfS8ke3N5c3RlbUlkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVzKSxcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIGNvbnNvbGUud2FybignW09yZGVyIEFQSV0gVXBkYXRlIHN5bmMgZmFpbGVkJyk7XHJcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ1tPcmRlciBBUEldIFVwZGF0ZWQ6Jywgc3lzdGVtSWQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tPcmRlciBBUEldIFVwZGF0ZSBzeW5jIGVycm9yOicsIGUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVsZXRlOiBhc3luYyAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBoYXJkID0gZmFsc2UpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0VORFBPSU5UfS8ke3N5c3RlbUlkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBoYXJkIH0pLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbT3JkZXIgQVBJXSBEZWxldGUgc3luYyBmYWlsZWQnKTtcclxuICAgICAgZWxzZSBjb25zb2xlLmxvZygnW09yZGVyIEFQSV0gRGVsZXRlZDonLCBzeXN0ZW1JZCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW09yZGVyIEFQSV0gRGVsZXRlIHN5bmMgZXJyb3I6JywgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZXN0b3JlOiBhc3luYyAoc3lzdGVtSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9FTkRQT0lOVH0vJHtzeXN0ZW1JZH0vcmVzdG9yZWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgY29uc29sZS53YXJuKCdbT3JkZXIgQVBJXSBSZXN0b3JlIHN5bmMgZmFpbGVkJyk7XHJcbiAgICAgIGVsc2UgY29uc29sZS5sb2coJ1tPcmRlciBBUEldIFJlc3RvcmVkOicsIHN5c3RlbUlkKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbT3JkZXIgQVBJXSBSZXN0b3JlIHN5bmMgZXJyb3I6JywgZSk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbi8vIOKchSBXcmFwIGJhc2Ugc3RvcmUgbWV0aG9kcyB3aXRoIEFQSSBzeW5jXHJcbmNvbnN0IG9yaWdpbmFsQWRkID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuYWRkO1xyXG5jb25zdCBvcmlnaW5hbFVwZGF0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZTtcclxuY29uc3Qgb3JpZ2luYWxSZW1vdmUgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5yZW1vdmU7XHJcbmNvbnN0IG9yaWdpbmFsSGFyZERlbGV0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmhhcmREZWxldGU7XHJcbmNvbnN0IG9yaWdpbmFsUmVzdG9yZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLnJlc3RvcmU7XHJcblxyXG5iYXNlU3RvcmUuc2V0U3RhdGUoe1xyXG4gIGFkZDogKGl0ZW06IE9taXQ8T3JkZXIsICdzeXN0ZW1JZCc+KSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbEFkZChpdGVtKTtcclxuICAgIHN5bmNUb0FwaS5jcmVhdGUocmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSxcclxuICB1cGRhdGU6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHVwZGF0ZXM6IFBhcnRpYWw8T3JkZXI+KSA9PiB7XHJcbiAgICBvcmlnaW5hbFVwZGF0ZShzeXN0ZW1JZCwgdXBkYXRlcyk7XHJcbiAgICBzeW5jVG9BcGkudXBkYXRlKHN5c3RlbUlkLCB1cGRhdGVzKTtcclxuICB9LFxyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZW1vdmUoc3lzdGVtSWQpO1xyXG4gICAgc3luY1RvQXBpLmRlbGV0ZShzeXN0ZW1JZCwgZmFsc2UpO1xyXG4gIH0sXHJcbiAgaGFyZERlbGV0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxIYXJkRGVsZXRlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5kZWxldGUoc3lzdGVtSWQsIHRydWUpO1xyXG4gIH0sXHJcbiAgcmVzdG9yZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgb3JpZ2luYWxSZXN0b3JlKHN5c3RlbUlkKTtcclxuICAgIHN5bmNUb0FwaS5yZXN0b3JlKHN5c3RlbUlkKTtcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIOKchSBNSUdSQVRJT046IEVuc3VyZSBhbGwgb3JkZXJzIGhhdmUgcGFpZEFtb3VudCBmaWVsZCAoYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcclxuYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+ICh7XHJcbiAgZGF0YTogc3RhdGUuZGF0YS5tYXAob3JkZXIgPT4gKHtcclxuICAgIC4uLm9yZGVyLFxyXG4gICAgcGFpZEFtb3VudDogb3JkZXIucGFpZEFtb3VudCA/PyAwLCAvLyBEZWZhdWx0IHRvIDAgaWYgdW5kZWZpbmVkXHJcbiAgfSkpXHJcbn0pKTtcclxuXHJcbi8vIOKchSBNSUdSQVRJT046IE1lcmdlIHNlZWQgZGF0YSAtIGFkZCBuZXcgb3JkZXJzIGZyb20gaW5pdGlhbERhdGEgaWYgbm90IGV4aXN0IGluIHBlcnNpc3RlZCBzdG9yZVxyXG5iYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQpKTtcclxuICBjb25zdCBuZXdPcmRlcnMgPSBpbml0aWFsRGF0YS5maWx0ZXIobyA9PiAhZXhpc3RpbmdJZHMuaGFzKG8uc3lzdGVtSWQpKTtcclxuICBpZiAobmV3T3JkZXJzLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiB7IGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCAuLi5uZXdPcmRlcnNdIH07XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufSk7XHJcblxyXG4vLyDinIUgTUlHUkFUSU9OOiBGaXggb3JkZXIgc3RhdHVzIC0gb3JkZXJzIHdpdGggZnVsbCBwYXltZW50IGFuZCBkZWxpdmVyeSBzaG91bGQgYmUgXCJIb8OgbiB0aMOgbmhcIlxyXG5iYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvcmRlciA9PiB7XHJcbiAgICAvLyBJZiBvcmRlciBpcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBjYW5jZWxsZWQsIHNraXBcclxuICAgIGlmIChvcmRlci5zdGF0dXMgPT09ICdIb8OgbiB0aMOgbmgnIHx8IG9yZGVyLnN0YXR1cyA9PT0gJ8SQw6MgaOG7p3knKSB7XHJcbiAgICAgIHJldHVybiBvcmRlcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgYWxsIGFjdGl2ZSBwYWNrYWdpbmdzIGFyZSBkZWxpdmVyZWRcclxuICAgIGNvbnN0IGFjdGl2ZVBhY2thZ2luZ3MgPSBvcmRlci5wYWNrYWdpbmdzLmZpbHRlcihwID0+IHAuc3RhdHVzICE9PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgIGNvbnN0IGlzQWxsRGVsaXZlcmVkID0gYWN0aXZlUGFja2FnaW5ncy5sZW5ndGggPiAwICYmIGFjdGl2ZVBhY2thZ2luZ3MuZXZlcnkocCA9PiBwLmRlbGl2ZXJ5U3RhdHVzID09PSAnxJDDoyBnaWFvIGjDoG5nJyk7XHJcbiAgICBcclxuICAgIC8vIElmIGZ1bGx5IHBhaWQgYW5kIGZ1bGx5IGRlbGl2ZXJlZCwgdXBkYXRlIHN0YXR1cyB0byBcIkhvw6BuIHRow6BuaFwiXHJcbiAgICBpZiAob3JkZXIucGF5bWVudFN0YXR1cyA9PT0gJ1RoYW5oIHRvw6FuIHRvw6BuIGLhu5knICYmIChpc0FsbERlbGl2ZXJlZCB8fCBvcmRlci5kZWxpdmVyeVN0YXR1cyA9PT0gJ8SQw6MgZ2lhbyBow6BuZycpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ub3JkZXIsXHJcbiAgICAgICAgc3RhdHVzOiAnSG/DoG4gdGjDoG5oJyBhcyBPcmRlck1haW5TdGF0dXMsXHJcbiAgICAgICAgY29tcGxldGVkRGF0ZTogb3JkZXIuY29tcGxldGVkRGF0ZSB8fCB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3JkZXI7XHJcbiAgfSlcclxufSkpO1xyXG5cclxuY29uc3Qgb3JpZ2luYWxBZGRXaXRoU3RvY2sgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5hZGQ7XHJcblxyXG5iYXNlU3RvcmUuc2V0U3RhdGUoe1xyXG4gICAgYWRkOiAoaXRlbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgY29tbWl0U3RvY2ssIGZpbmRCeUlkOiBmaW5kUHJvZHVjdEJ5SWQgfSA9IHVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJJbmZvID0gZ2V0Q3VycmVudFVzZXJJbmZvKCk7XHJcbiAgICAgICAgY29uc3QgbmV3SXRlbSA9IG9yaWdpbmFsQWRkV2l0aFN0b2NrKGl0ZW0pO1xyXG4gICAgICAgIGlmIChuZXdJdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkUGFja2FnaW5ncyA9IGVuc3VyZU9yZGVyUGFja2FnaW5nSWRlbnRpZmllcnMobmV3SXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChoeWRyYXRlZFBhY2thZ2luZ3MpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3SXRlbSwgaHlkcmF0ZWRQYWNrYWdpbmdzKTtcclxuICAgICAgICAgICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKG9yZGVyID0+IG9yZGVyLnN5c3RlbUlkID09PSBoeWRyYXRlZFBhY2thZ2luZ3Muc3lzdGVtSWQgPyBoeWRyYXRlZFBhY2thZ2luZ3MgOiBvcmRlciksXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3SXRlbS5saW5lSXRlbXMuZm9yRWFjaChsaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gZmluZFByb2R1Y3RCeUlkKGFzU3lzdGVtSWQobGkucHJvZHVjdFN5c3RlbUlkKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIOKchSBY4butIGzDvSBjb21ibzogY29tbWl0IHN0b2NrIGPhu6dhIFNQIGNvbiB0aGF5IHbDrCBjb21ib1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2R1Y3QgJiYgaXNDb21ib1Byb2R1Y3QocHJvZHVjdCkgJiYgcHJvZHVjdC5jb21ib0l0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdC5jb21ib0l0ZW1zLmZvckVhY2goY29tYm9JdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWl0IHN0b2NrID0gc+G7kSBsxrDhu6NuZyBjb21ibyDDlyBz4buRIGzGsOG7o25nIFNQIGNvbiB0cm9uZyBjb21ib1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFF1YW50aXR5ID0gbGkucXVhbnRpdHkgKiBjb21ib0l0ZW0ucXVhbnRpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdFN0b2NrKGFzU3lzdGVtSWQoY29tYm9JdGVtLnByb2R1Y3RTeXN0ZW1JZCksIGFzU3lzdGVtSWQobmV3SXRlbS5icmFuY2hTeXN0ZW1JZCksIHRvdGFsUXVhbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBT4bqjbiBwaOG6qW0gdGjGsOG7nW5nOiBjb21taXQgc3RvY2sgbmjGsCBiw6xuaCB0aMaw4budbmdcclxuICAgICAgICAgICAgICAgICAgICBjb21taXRTdG9jayhhc1N5c3RlbUlkKGxpLnByb2R1Y3RTeXN0ZW1JZCksIGFzU3lzdGVtSWQobmV3SXRlbS5icmFuY2hTeXN0ZW1JZCksIGxpLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgQ+G6rXAgbmjhuq10IGxhc3RQdXJjaGFzZURhdGUga2hpIHThuqFvIMSRxqFuIG3hu5tpICjEkeG7gyBTTEEvY2h1cm4gcmlzayBob+G6oXQgxJHhu5luZyDEkcO6bmcpXHJcbiAgICAgICAgICAgIGlmIChuZXdJdGVtLmN1c3RvbWVyU3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlOiB1cGRhdGVDdXN0b21lciwgZmluZEJ5SWQ6IGZpbmRDdXN0b21lciB9ID0gdXNlQ3VzdG9tZXJTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tZXIgPSBmaW5kQ3VzdG9tZXIobmV3SXRlbS5jdXN0b21lclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUN1c3RvbWVyKG5ld0l0ZW0uY3VzdG9tZXJTeXN0ZW1JZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHVyY2hhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4pyFIEFkZCBhY3Rpdml0eSBoaXN0b3J5IGVudHJ5XHJcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnlFbnRyeSA9IGNyZWF0ZUNyZWF0ZWRFbnRyeShcclxuICAgICAgICAgICAgICAgIHVzZXJJbmZvLFxyXG4gICAgICAgICAgICAgICAgYCR7dXNlckluZm8ubmFtZX0gxJHDoyB04bqhbyDEkcahbiBow6BuZyAke25ld0l0ZW0uaWR9IGNobyBraMOhY2ggaMOgbmcgJHtuZXdJdGVtLmN1c3RvbWVyTmFtZX0gKFThu5VuZzogJHtuZXdJdGVtLmdyYW5kVG90YWwudG9Mb2NhbGVTdHJpbmcoJ3ZpLVZOJyl9xJEpYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKG9yZGVyID0+IG9yZGVyLnN5c3RlbUlkID09PSBuZXdJdGVtLnN5c3RlbUlkID8geyAuLi5vcmRlciwgYWN0aXZpdHlIaXN0b3J5OiBbaGlzdG9yeUVudHJ5XSB9IDogb3JkZXIpLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdJdGVtO1xyXG4gICAgfSxcclxufSk7XHJcblxyXG5jb25zdCBiYWNrZmlsbFBhY2thZ2luZ0lkZW50aWZpZXJzID0gKCkgPT4ge1xyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gYmFzZVN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgdXBkYXRlZERhdGEgPSBjdXJyZW50U3RhdGUuZGF0YS5tYXAob3JkZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IGVuc3VyZU9yZGVyUGFja2FnaW5nSWRlbnRpZmllcnMob3JkZXIpO1xyXG4gICAgICAgIGlmICh1cGRhdGVkT3JkZXIpIHtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkT3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcmRlcjtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHsgZGF0YTogdXBkYXRlZERhdGEgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5iYWNrZmlsbFBhY2thZ2luZ0lkZW50aWZpZXJzKCk7XHJcblxyXG5jb25zdCBhdWdtZW50ZWRNZXRob2RzID0ge1xyXG4gICAgY2FuY2VsT3JkZXI6IChcclxuICAgICAgICBzeXN0ZW1JZDogU3lzdGVtSWQsXHJcbiAgICAgICAgZW1wbG95ZWVJZDogU3lzdGVtSWQsXHJcbiAgICAgICAgb3B0aW9ucz86IHsgcmVhc29uPzogc3RyaW5nOyByZXN0b2NrPzogYm9vbGVhbiB9XHJcbiAgICApID0+IHtcclxuICAgICAgICBjb25zdCB7IHJlYXNvbiwgcmVzdG9jayA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XHJcbiAgICAgICAgY29uc3QgY3VycmVudE9yZGVyID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpO1xyXG4gICAgICAgIGlmICghZW5zdXJlQ2FuY2VsbGF0aW9uQWxsb3dlZChjdXJyZW50T3JkZXIsICdo4buneSDEkcahbiBow6BuZycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyVG9DYW5jZWwgPSBzdGF0ZS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBzeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXJUb0NhbmNlbCB8fCBvcmRlclRvQ2FuY2VsLnN0YXR1cyA9PT0gJ8SQw6MgaOG7p3knKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlID0gdXNlRW1wbG95ZWVTdG9yZS5nZXRTdGF0ZSgpLmZpbmRCeUlkKGVtcGxveWVlSWQgYXMgU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25SZWFzb24gPSAocmVhc29uICYmIHJlYXNvbi50cmltKCkubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgID8gcmVhc29uLnRyaW0oKVxyXG4gICAgICAgICAgICAgICAgOiBvcmRlclRvQ2FuY2VsLmNhbmNlbGxhdGlvblJlYXNvbiB8fCBgSOG7p3kgYuG7n2kgJHtlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ0jhu4cgdGjhu5FuZyd9YDtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVbmNvbW1pdCBzdG9jayAoaOG7lyB0cuG7oyBjb21ibylcclxuICAgICAgICAgICAgaWYgKHJlc3RvY2spIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyVG9DYW5jZWwubGluZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0xpbmVJdGVtU3RvY2soaXRlbSwgb3JkZXJUb0NhbmNlbC5icmFuY2hTeXN0ZW1JZCwgJ3VuY29tbWl0JywgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaGFzRGlzcGF0Y2hlZFN0b2NrID0gb3JkZXJUb0NhbmNlbC5zdG9ja091dFN0YXR1cyA9PT0gJ1h14bqldCBraG8gdG/DoG4gYuG7mSdcclxuICAgICAgICAgICAgICAgIHx8IFsnQ2jhu50gbOG6pXkgaMOgbmcnLCAnxJBhbmcgZ2lhbyBow6BuZycsICfEkMOjIGdpYW8gaMOgbmcnLCAnQ2jhu50gZ2lhbyBs4bqhaSddLmluY2x1ZGVzKG9yZGVyVG9DYW5jZWwuZGVsaXZlcnlTdGF0dXMpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFJldHVybiBzdG9jayBmcm9tIHRyYW5zaXQgKGjhu5cgdHLhu6MgY29tYm8pXHJcbiAgICAgICAgICAgIGlmIChyZXN0b2NrICYmIGhhc0Rpc3BhdGNoZWRTdG9jaykge1xyXG4gICAgICAgICAgICAgICAgb3JkZXJUb0NhbmNlbC5saW5lSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTGluZUl0ZW1TdG9jayhpdGVtLCBvcmRlclRvQ2FuY2VsLmJyYW5jaFN5c3RlbUlkLCAncmV0dXJuJywgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQYXltZW50cyA9IG9yZGVyVG9DYW5jZWwucGF5bWVudHMgPz8gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG5ldENvbGxlY3RlZCA9IGV4aXN0aW5nUGF5bWVudHMucmVkdWNlKChzdW0sIHBheW1lbnQpID0+IHN1bSArIHBheW1lbnQuYW1vdW50LCAwKTtcclxuICAgICAgICAgICAgbGV0IHJlZnVuZFBheW1lbnRFbnRyeTogT3JkZXJQYXltZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZnVuZEFtb3VudCA9IG5ldENvbGxlY3RlZCA+IDAgPyBuZXRDb2xsZWN0ZWQgOiAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlZnVuZEFtb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnVuZFZvdWNoZXIgPSBjcmVhdGVPcmRlclJlZnVuZFZvdWNoZXIob3JkZXJUb0NhbmNlbCwgcmVmdW5kQW1vdW50LCBlbXBsb3llZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVmdW5kVm91Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdLaMO0bmcgdGjhu4MgdOG6oW8gcGhp4bq/dSBjaGkgaG/DoG4gdGnhu4FuLiBWdWkgbMOybmcga2nhu4NtIHRyYSBj4bqldSBow6xuaCB0w6BpIGNow61uaCB0csaw4bubYyBraGkgaOG7p3kgxJHGoW4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlZnVuZFBheW1lbnRFbnRyeSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1JZDogcmVmdW5kVm91Y2hlci5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBpZDogcmVmdW5kVm91Y2hlci5pZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiByZWZ1bmRWb3VjaGVyLmRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAtcmVmdW5kQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcmVmdW5kVm91Y2hlci5wYXltZW50TWV0aG9kTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQnk6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBIb8OgbiB0aeG7gW4ga2hpIGjhu6d5IMSRxqFuICR7b3JkZXJUb0NhbmNlbC5pZH1gLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBheW1lbnRzID0gcmVmdW5kUGF5bWVudEVudHJ5ID8gWy4uLmV4aXN0aW5nUGF5bWVudHMsIHJlZnVuZFBheW1lbnRFbnRyeV0gOiBleGlzdGluZ1BheW1lbnRzO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFpZEFtb3VudCA9IE1hdGgubWF4KDAsIChvcmRlclRvQ2FuY2VsLnBhaWRBbW91bnQgPz8gMCkgLSByZWZ1bmRBbW91bnQpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyVG9DYW5jZWwucGFja2FnaW5ncy5tYXAocGtnID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwa2cuc3RhdHVzID09PSAnSOG7p3kgxJHDs25nIGfDs2knICYmIHBrZy5kZWxpdmVyeVN0YXR1cyA9PT0gJ8SQw6MgaOG7p3knKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucGtnLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ0jhu6d5IMSRw7NuZyBnw7NpJyBhcyBQYWNrYWdpbmdTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6ICfEkMOjIGjhu6d5JyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbERhdGU6IG5vdyxcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxSZWFzb246IHBrZy5jYW5jZWxSZWFzb24gPz8gY2FuY2VsbGF0aW9uUmVhc29uLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGluZ0VtcGxveWVlSWQ6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsaW5nRW1wbG95ZWVOYW1lOiBlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ0jhu4cgdGjhu5FuZycsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IHtcclxuICAgICAgICAgICAgICAgIC4uLm9yZGVyVG9DYW5jZWwsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICfEkMOjIGjhu6d5JyBhcyBPcmRlck1haW5TdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBjYW5jZWxsZWREYXRlOiBub3csXHJcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25SZWFzb24sXHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ8SQw6MgaOG7p3knIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBzdG9ja091dFN0YXR1czogcmVzdG9jayA/ICdDaMawYSB4deG6pXQga2hvJyBhcyBjb25zdCA6IG9yZGVyVG9DYW5jZWwuc3RvY2tPdXRTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBwYXltZW50czogdXBkYXRlZFBheW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgcGFpZEFtb3VudDogdXBkYXRlZFBhaWRBbW91bnQsXHJcbiAgICAgICAgICAgICAgICBwYXltZW50U3RhdHVzOiByZWZ1bmRQYXltZW50RW50cnkgPyAnQ2jGsGEgdGhhbmggdG/DoW4nIGFzIE9yZGVyUGF5bWVudFN0YXR1cyA6IG9yZGVyVG9DYW5jZWwucGF5bWVudFN0YXR1cyxcclxuICAgICAgICAgICAgICAgIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzLFxyXG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uTWV0YWRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN0b2NrSXRlbXM6IHJlc3RvY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5Q3VzdG9tZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsTm90aWZpZWRBdDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFjdGl2aXR5SGlzdG9yeTogYXBwZW5kSGlzdG9yeUVudHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyVG9DYW5jZWwuYWN0aXZpdHlIaXN0b3J5LFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUhpc3RvcnlFbnRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEN1cnJlbnRVc2VySW5mbygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ0jhu4cgdGjhu5FuZyd9IMSRw6MgaOG7p3kgxJHGoW4gaMOgbmcuIEzDvSBkbzogJHtjYW5jZWxsYXRpb25SZWFzb259JHtyZWZ1bmRBbW91bnQgPiAwID8gYC4gSG/DoG4gdGnhu4FuOiAke3JlZnVuZEFtb3VudC50b0xvY2FsZVN0cmluZygndmktVk4nKX3EkWAgOiAnJ31gXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBSZW1vdmUgZGVidCB0cmFuc2FjdGlvbiBmcm9tIGN1c3RvbWVyXHJcbiAgICAgICAgICAgIHVzZUN1c3RvbWVyU3RvcmUuZ2V0U3RhdGUoKS5yZW1vdmVEZWJ0VHJhbnNhY3Rpb24ob3JkZXJUb0NhbmNlbC5jdXN0b21lclN5c3RlbUlkLCBvcmRlclRvQ2FuY2VsLmlkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHN0YXRlLmRhdGEubWFwKG8gPT4gKG8uc3lzdGVtSWQgPT09IHN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbykpIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZFBheW1lbnQ6IChvcmRlclN5c3RlbUlkOiBTeXN0ZW1JZCwgcGF5bWVudERhdGE6IHsgYW1vdW50OiBudW1iZXI7IG1ldGhvZDogc3RyaW5nIH0sIGVtcGxveWVlSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgLy8gLS0tIFNpZGUgZWZmZWN0cyBtdXN0IGhhcHBlbiBvdXRzaWRlIHNldFN0YXRlIC0tLVxyXG4gICAgICAgIGNvbnN0IG9yZGVyID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQob3JkZXJTeXN0ZW1JZCBhcyBTeXN0ZW1JZCk7XHJcbiAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcblxyXG4gICAgICAgIGlmICghb3JkZXIgfHwgIWVtcGxveWVlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJPcmRlciBvciBlbXBsb3llZSBub3QgZm91bmQgZm9yIHBheW1lbnQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7IGRvY3VtZW50OiBjcmVhdGVkUmVjZWlwdCwgZXJyb3IgfSA9IGNyZWF0ZVJlY2VpcHREb2N1bWVudCh7XHJcbiAgICAgICAgICAgIGFtb3VudDogcGF5bWVudERhdGEuYW1vdW50LFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFRoYW5oIHRvw6FuIGNobyDEkcahbiBow6BuZyAke29yZGVyLmlkfWAsXHJcbiAgICAgICAgICAgIGN1c3RvbWVyTmFtZTogb3JkZXIuY3VzdG9tZXJOYW1lLFxyXG4gICAgICAgICAgICBjdXN0b21lclN5c3RlbUlkOiBvcmRlci5jdXN0b21lclN5c3RlbUlkLFxyXG4gICAgICAgICAgICBicmFuY2hTeXN0ZW1JZDogb3JkZXIuYnJhbmNoU3lzdGVtSWQsXHJcbiAgICAgICAgICAgIGJyYW5jaE5hbWU6IG9yZGVyLmJyYW5jaE5hbWUsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRCeTogZW1wbG95ZWVJZCxcclxuICAgICAgICAgICAgcGF5bWVudE1ldGhvZE5hbWU6IHBheW1lbnREYXRhLm1ldGhvZCxcclxuICAgICAgICAgICAgcmVjZWlwdFR5cGVOYW1lOiAnVGhhbmggdG/DoW4gY2hvIMSRxqFuIGjDoG5nJyxcclxuICAgICAgICAgICAgb3JpZ2luYWxEb2N1bWVudElkOiBvcmRlci5pZCxcclxuICAgICAgICAgICAgbGlua2VkT3JkZXJTeXN0ZW1JZDogb3JkZXIuc3lzdGVtSWQsXHJcbiAgICAgICAgICAgIGFmZmVjdHNEZWJ0OiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIWNyZWF0ZWRSZWNlaXB0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgcmVjZWlwdCcsIGVycm9yKTtcclxuICAgICAgICAgICAgYWxlcnQoJ0tow7RuZyB0aOG7gyB04bqhbyBwaGnhur91IHRodSBjaG8gxJHGoW4gaMOgbmcuIFZ1aSBsw7JuZyBraeG7g20gdHJhIGPhuqV1IGjDrG5oIGNo4bupbmcgdOG7qy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4gTm93LCB1cGRhdGUgdGhlIG9yZGVyIHN0YXRlIHdpdGggdGhlIGNyZWF0ZWQgcmVjZWlwdCBpbmZvXHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXJJbmRleCA9IHN0YXRlLmRhdGEuZmluZEluZGV4KG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmIChvcmRlckluZGV4ID09PSAtMSkgcmV0dXJuIHN0YXRlO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb3JkZXJUb1VwZGF0ZSA9IHN0YXRlLmRhdGFbb3JkZXJJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1BheW1lbnQ6IE9yZGVyUGF5bWVudCA9IHtcclxuICAgICAgICAgICAgICAgIHN5c3RlbUlkOiBjcmVhdGVkUmVjZWlwdC5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgIGlkOiBjcmVhdGVkUmVjZWlwdC5pZCxcclxuICAgICAgICAgICAgICAgIGRhdGU6IGNyZWF0ZWRSZWNlaXB0LmRhdGUsXHJcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGNyZWF0ZWRSZWNlaXB0LmFtb3VudCxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogY3JlYXRlZFJlY2VpcHQucGF5bWVudE1ldGhvZE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkQnk6IGFzU3lzdGVtSWQoY3JlYXRlZFJlY2VpcHQuY3JlYXRlZEJ5KSxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBjcmVhdGVkUmVjZWlwdC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IGFwcGx5UGF5bWVudFRvT3JkZXIob3JkZXJUb1VwZGF0ZSwgbmV3UGF5bWVudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgQWRkIGFjdGl2aXR5IGhpc3RvcnkgZW50cnlcclxuICAgICAgICAgICAgdXBkYXRlZE9yZGVyLmFjdGl2aXR5SGlzdG9yeSA9IGFwcGVuZEhpc3RvcnlFbnRyeShcclxuICAgICAgICAgICAgICAgIG9yZGVyVG9VcGRhdGUuYWN0aXZpdHlIaXN0b3J5LFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlSGlzdG9yeUVudHJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICdwYXltZW50X21hZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldEN1cnJlbnRVc2VySW5mbygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGAke2VtcGxveWVlPy5mdWxsTmFtZSB8fCAnTmjDom4gdmnDqm4nfSDEkcOjIHRoYW5oIHRvw6FuICR7cGF5bWVudERhdGEuYW1vdW50LnRvTG9jYWxlU3RyaW5nKCd2aS1WTicpfcSRIGLhurFuZyAke3BheW1lbnREYXRhLm1ldGhvZH1gXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBuZXdEYXRhID0gWy4uLnN0YXRlLmRhdGFdO1xyXG4gICAgICAgICAgICBuZXdEYXRhW29yZGVySW5kZXhdID0gdXBkYXRlZE9yZGVyO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbmV3RGF0YSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXF1ZXN0UGFja2FnaW5nOiAob3JkZXJTeXN0ZW1JZDogU3lzdGVtSWQsIGVtcGxveWVlSWQ6IFN5c3RlbUlkLCBhc3NpZ25lZEVtcGxveWVlSWQ/OiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gc3RhdGUuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXIpIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbmVkRW1wbG95ZWUgPSBhc3NpZ25lZEVtcGxveWVlSWQgPyB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoYXNzaWduZWRFbXBsb3llZUlkIGFzIFN5c3RlbUlkKSA6IG51bGw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDb3VudCBvbmx5IGFjdGl2ZSBwYWNrYWdpbmdzIGZvciBwcm9wZXIgbnVtYmVyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVBhY2thZ2luZ3MgPSBvcmRlci5wYWNrYWdpbmdzLmZpbHRlcihwID0+IHAuc3RhdHVzICE9PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlQ291bnRBZnRlckluc2VydCA9IGFjdGl2ZVBhY2thZ2luZ3MubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgY29uc3QgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVQYWNrYWdpbmdzLmxlbmd0aDsgLy8gVGhpcyB3aWxsIGJlIHRoZSBpbmRleCBpbiBhY3RpdmUgcGFja2FnaW5nc1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbmV3UGFja2FnaW5nOiBQYWNrYWdpbmcgPSB7XHJcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkKCksIC8vIOKchSBVc2UgcHJvcGVyIGZvcm1hdCBQQUNLQUdFMDAwMDAxXHJcbiAgICAgICAgICAgICAgICBpZDogYnVpbGRQYWNrYWdpbmdCdXNpbmVzc0lkKG9yZGVyLmlkLCBuZXdBY3RpdmVJbmRleCwgYWN0aXZlQ291bnRBZnRlckluc2VydCksXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0ZTogdG9JU09EYXRlVGltZShuZXcgRGF0ZSgpKSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdFbXBsb3llZUlkOiBlbXBsb3llZUlkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdGluZ0VtcGxveWVlTmFtZTogZW1wbG95ZWU/LmZ1bGxOYW1lIHx8ICdOL0EnLFxyXG4gICAgICAgICAgICAgICAgYXNzaWduZWRFbXBsb3llZUlkLFxyXG4gICAgICAgICAgICAgICAgYXNzaWduZWRFbXBsb3llZU5hbWU6IGFzc2lnbmVkRW1wbG95ZWU/LmZ1bGxOYW1lLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnQ2jhu50gxJHDs25nIGfDs2knLFxyXG4gICAgICAgICAgICAgICAgcHJpbnRTdGF0dXM6ICdDaMawYSBpbicsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7IC4uLm9yZGVyLCBwYWNrYWdpbmdzOiBbLi4ub3JkZXIucGFja2FnaW5ncywgbmV3UGFja2FnaW5nXSwgZGVsaXZlcnlTdGF0dXM6ICdDaOG7nSDEkcOzbmcgZ8OzaScgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cyB9O1xyXG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQgPyB1cGRhdGVkT3JkZXIgOiBvKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb25maXJtUGFja2FnaW5nOiAob3JkZXJTeXN0ZW1JZDogU3lzdGVtSWQsIHBhY2thZ2luZ1N5c3RlbUlkOiBTeXN0ZW1JZCwgZW1wbG95ZWVJZDogU3lzdGVtSWQpID0+IHtcclxuICAgICAgICAvLyDinIUgQ2hlY2sgbmVnYXRpdmUgcGFja2luZyBzZXR0aW5nXHJcbiAgICAgICAgY29uc3QgeyBhbGxvd05lZ2F0aXZlUGFja2luZyB9ID0gdXNlU2FsZXNNYW5hZ2VtZW50U2V0dGluZ3NTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGlmICghYWxsb3dOZWdhdGl2ZVBhY2tpbmcpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKG9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpbmRCeUlkOiBmaW5kUHJvZHVjdEJ5SWQgfSA9IHVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9yZGVyLmxpbmVJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBmaW5kUHJvZHVjdEJ5SWQoYXNTeXN0ZW1JZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9kdWN0ICYmIGlzQ29tYm9Qcm9kdWN0KHByb2R1Y3QpICYmIHByb2R1Y3QuY29tYm9JdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbWJvSXRlbSBvZiBwcm9kdWN0LmNvbWJvSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvZHVjdCA9IGZpbmRQcm9kdWN0QnlJZChhc1N5c3RlbUlkKGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkUXR5ID0gaXRlbS5xdWFudGl0eSAqIGNvbWJvSXRlbS5xdWFudGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9jayA9IGNoaWxkUHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltvcmRlci5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RvY2sgPCByZXF1aXJlZFF0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBLaMO0bmcgdGjhu4MgxJHDs25nIGfDs2k6IFPhuqNuIHBo4bqpbSBcIiR7Y2hpbGRQcm9kdWN0Py5uYW1lfVwiIGtow7RuZyDEkeG7pyB04buTbiBraG8gKEPDszogJHtjdXJyZW50U3RvY2t9LCBD4bqnbjogJHtyZXF1aXJlZFF0eX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b2NrID0gcHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltvcmRlci5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdG9jayA8IGl0ZW0ucXVhbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBLaMO0bmcgdGjhu4MgxJHDs25nIGfDs2k6IFPhuqNuIHBo4bqpbSBcIiR7aXRlbS5wcm9kdWN0TmFtZX1cIiBraMO0bmcgxJHhu6cgdOG7k24ga2hvIChDw7M6ICR7Y3VycmVudFN0b2NrfSwgQ+G6p246ICR7aXRlbS5xdWFudGl0eX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDb3B5ID0gWy4uLnN0YXRlLmRhdGFdO1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlckluZGV4ID0gZGF0YUNvcHkuZmluZEluZGV4KG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmIChvcmRlckluZGV4ID09PSAtMSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgXHJcbiAgICAgICAgY29uc3Qgb3JkZXJDb3B5ID0geyAuLi5kYXRhQ29weVtvcmRlckluZGV4XSB9O1xyXG4gICAgICAgICAgICBjb25zdCBwYWNrYWdpbmdJbmRleCA9IG9yZGVyQ29weS5wYWNrYWdpbmdzLmZpbmRJbmRleChwID0+IHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKHBhY2thZ2luZ0luZGV4ID09PSAtMSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcbiAgICBcclxuICAgICAgICBjb25zdCBwYWNrYWdpbmdzQ29weSA9IFsuLi5vcmRlckNvcHkucGFja2FnaW5nc107XHJcbiAgICAgICAgICAgIHBhY2thZ2luZ3NDb3B5W3BhY2thZ2luZ0luZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnBhY2thZ2luZ3NDb3B5W3BhY2thZ2luZ0luZGV4XSxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogJ8SQw6MgxJHDs25nIGfDs2knIGFzIFBhY2thZ2luZ1N0YXR1cyxcclxuICAgICAgICAgICAgICAgIGNvbmZpcm1EYXRlOiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgY29uZmlybWluZ0VtcGxveWVlSWQ6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICBjb25maXJtaW5nRW1wbG95ZWVOYW1lOiBlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ04vQScsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICBvcmRlckNvcHkucGFja2FnaW5ncyA9IHBhY2thZ2luZ3NDb3B5O1xyXG4gICAgICAgIG9yZGVyQ29weS5kZWxpdmVyeVN0YXR1cyA9ICfEkMOjIMSRw7NuZyBnw7NpJyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZGF0YUNvcHlbb3JkZXJJbmRleF0gPSBvcmRlckNvcHk7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhQ29weSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYW5jZWxQYWNrYWdpbmdSZXF1ZXN0OiAob3JkZXJTeXN0ZW1JZDogU3lzdGVtSWQsIHBhY2thZ2luZ1N5c3RlbUlkOiBTeXN0ZW1JZCwgZW1wbG95ZWVJZDogU3lzdGVtSWQsIHJlYXNvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gc3RhdGUuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXIpIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnSOG7p3kgxJHDs25nIGfDs2knIGFzIFBhY2thZ2luZ1N0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRGF0ZTogdG9JU09EYXRlVGltZShuZXcgRGF0ZSgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsaW5nRW1wbG95ZWVJZDogZW1wbG95ZWVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsaW5nRW1wbG95ZWVOYW1lOiBlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ04vQScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbFJlYXNvbjogcmVhc29uLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQW55QWN0aXZlUGFja2FnaW5nID0gdXBkYXRlZFBhY2thZ2luZ3Muc29tZShwID0+IHAuc3RhdHVzICE9PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9yZGVyID0geyAuLi5vcmRlciwgcGFja2FnaW5nczogdXBkYXRlZFBhY2thZ2luZ3MsIGRlbGl2ZXJ5U3RhdHVzOiBpc0FueUFjdGl2ZVBhY2thZ2luZyA/IG9yZGVyLmRlbGl2ZXJ5U3RhdHVzIDogJ0No4budIMSRw7NuZyBnw7NpJyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHN0YXRlLmRhdGEubWFwKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCA/IHVwZGF0ZWRPcmRlciA6IG8pIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBwcm9jZXNzSW5TdG9yZVBpY2t1cDogKG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZDogU3lzdGVtSWQpID0+IHtcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IHN0YXRlLmRhdGEuZmluZChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBpZiAoIW9yZGVyKSByZXR1cm4gc3RhdGU7XHJcbiAgICBcclxuICAgICAgICAgICAgY29uc3QgdG90YWxDb3VudCA9IG9yZGVyLnBhY2thZ2luZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKChwLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzSWQgPSB0eXBlb2YgcC5pZCA9PT0gJ3N0cmluZycgJiYgcC5pZC50cmltKCkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZElkID0gaGFzSWQgPyBwLmlkIDogYnVpbGRQYWNrYWdpbmdCdXNpbmVzc0lkKG9yZGVyLmlkLCBpbmRleCwgdG90YWxDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJlc29sdmVkSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5TWV0aG9kOiAnTmjhuq1uIHThuqFpIGPhu61hIGjDoG5nJyBhcyBPcmRlckRlbGl2ZXJ5TWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ8SQw6MgxJHDs25nIGfDs2knIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWNraW5nQ29kZSB3aWxsIGJlIHNldCB3aGVuIHNoaXBtZW50IGlzIGNyZWF0ZWQgaW4gY29uZmlybUluU3RvcmVQaWNrdXBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9yZGVyID0geyBcclxuICAgICAgICAgICAgICAgIC4uLm9yZGVyLCBcclxuICAgICAgICAgICAgICAgIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzLCBcclxuICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnxJDDoyDEkcOzbmcgZ8OzaScgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cyBcclxuICAgICAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQgPyB1cGRhdGVkT3JkZXIgOiBvKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY29uZmlybUluU3RvcmVQaWNrdXA6IChvcmRlclN5c3RlbUlkOiBTeXN0ZW1JZCwgcGFja2FnaW5nU3lzdGVtSWQ6IFN5c3RlbUlkLCBlbXBsb3llZUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5+iIFtjb25maXJtSW5TdG9yZVBpY2t1cF0gQ2FsbGVkIHdpdGg6JywgeyBvcmRlclN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZCwgZW1wbG95ZWVJZCB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDinIUgQ2hlY2sgbmVnYXRpdmUgc3RvY2sgb3V0IHNldHRpbmdcclxuICAgICAgICBjb25zdCB7IGFsbG93TmVnYXRpdmVTdG9ja091dCB9ID0gdXNlU2FsZXNNYW5hZ2VtZW50U2V0dGluZ3NTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGlmICghYWxsb3dOZWdhdGl2ZVN0b2NrT3V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmIChvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaW5kQnlJZDogZmluZFByb2R1Y3RCeUlkIH0gPSB1c2VQcm9kdWN0U3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmRlci5saW5lSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gZmluZFByb2R1Y3RCeUlkKGFzU3lzdGVtSWQoaXRlbS5wcm9kdWN0U3lzdGVtSWQpKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZHVjdCAmJiBpc0NvbWJvUHJvZHVjdChwcm9kdWN0KSAmJiBwcm9kdWN0LmNvbWJvSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb21ib0l0ZW0gb2YgcHJvZHVjdC5jb21ib0l0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFByb2R1Y3QgPSBmaW5kUHJvZHVjdEJ5SWQoYXNTeXN0ZW1JZChjb21ib0l0ZW0ucHJvZHVjdFN5c3RlbUlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZFF0eSA9IGl0ZW0ucXVhbnRpdHkgKiBjb21ib0l0ZW0ucXVhbnRpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RvY2sgPSBjaGlsZFByb2R1Y3Q/LmludmVudG9yeUJ5QnJhbmNoPy5bb3JkZXIuYnJhbmNoU3lzdGVtSWRdIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0b2NrIDwgcmVxdWlyZWRRdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChgS2jDtG5nIHRo4buDIHh14bqldCBraG86IFPhuqNuIHBo4bqpbSBcIiR7Y2hpbGRQcm9kdWN0Py5uYW1lfVwiIGtow7RuZyDEkeG7pyB04buTbiBraG8gKEPDszogJHtjdXJyZW50U3RvY2t9LCBD4bqnbjogJHtyZXF1aXJlZFF0eX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b2NrID0gcHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltvcmRlci5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdG9jayA8IGl0ZW0ucXVhbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KGBLaMO0bmcgdGjhu4MgeHXhuqV0IGtobzogU+G6o24gcGjhuqltIFwiJHtpdGVtLnByb2R1Y3ROYW1lfVwiIGtow7RuZyDEkeG7pyB04buTbiBraG8gKEPDszogJHtjdXJyZW50U3RvY2t9LCBD4bqnbjogJHtpdGVtLnF1YW50aXR5fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBzdGF0ZS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKCFvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFtjb25maXJtSW5TdG9yZVBpY2t1cF0gT3JkZXIgbm90IGZvdW5kOicsIG9yZGVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgW2NvbmZpcm1JblN0b3JlUGlja3VwXSBPcmRlciBmb3VuZDonLCBvcmRlci5pZCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIFtjb25maXJtSW5TdG9yZVBpY2t1cF0gTGluZSBpdGVtczonLCBvcmRlci5saW5lSXRlbXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFN0b2NrIGxvZ2ljXHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkRW50cnk6IGFkZFN0b2NrSGlzdG9yeSB9ID0gdXNlU3RvY2tIaXN0b3J5U3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVEYXRhID0gdXNlRW1wbG95ZWVTdG9yZS5nZXRTdGF0ZSgpLmZpbmRCeUlkKGVtcGxveWVlSWQgYXMgU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIG9yZGVyLmxpbmVJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk6YgW2NvbmZpcm1JblN0b3JlUGlja3VwXSBEaXNwYXRjaGluZyBpdGVtICR7aW5kZXggKyAxfTpgLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFN5c3RlbUlkOiBpdGVtLnByb2R1Y3RTeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0TmFtZTogaXRlbS5wcm9kdWN0TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2hTeXN0ZW1JZDogZ2V0QnJhbmNoSWQob3JkZXIpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8g4pyFIERpc3BhdGNoIHN0b2NrICho4buXIHRy4bujIGNvbWJvIC0gc+G6vSBkaXNwYXRjaCBTUCBjb24pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRJdGVtcyA9IHByb2Nlc3NMaW5lSXRlbVN0b2NrKGl0ZW0sIGdldEJyYW5jaElkKG9yZGVyKSwgJ2Rpc3BhdGNoJywgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIOKchSBBZGQgc3RvY2sgaGlzdG9yeSBlbnRyeSBmb3IgZWFjaCBwcm9jZXNzZWQgaXRlbSAoU1AgY29uIG7hur91IGNvbWJvKVxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkSXRlbXMuZm9yRWFjaChwcm9jZXNzZWRJdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gdXNlUHJvZHVjdFN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQocHJvY2Vzc2VkSXRlbS5wcm9kdWN0U3lzdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9jayA9IHByb2R1Y3Q/LmludmVudG9yeUJ5QnJhbmNoPy5bZ2V0QnJhbmNoSWQob3JkZXIpXSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZFN0b2NrSGlzdG9yeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IG5vdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9jZXNzZWRJdGVtLnByb2R1Y3RTeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnWHXhuqV0IGtobyAoxJDGoW4gaMOgbmcpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHlDaGFuZ2U6IC1wcm9jZXNzZWRJdGVtLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdG9ja0xldmVsOiBjdXJyZW50U3RvY2ssIC8vIEFmdGVyIGRpc3BhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IG9yZGVyLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmFuY2hTeXN0ZW1JZDogZ2V0QnJhbmNoSWQob3JkZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmFuY2g6IG9yZGVyLmJyYW5jaE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcGxveWVlTmFtZTogZW1wbG95ZWVEYXRhPy5mdWxsTmFtZSB8fCAnSOG7hyB0aOG7kW5nJyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBTdGF0dXMgdXBkYXRlIGxvZ2ljIC0gd2lsbCBiZSB1cGRhdGVkIHdpdGggdHJhY2tpbmdDb2RlIGFmdGVyIHNoaXBtZW50IGNyZWF0aW9uXHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ8SQw6MgZ2lhbyBow6BuZycgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cywgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJlZERhdGU6IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSkgXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zdCBpc0FsbERlbGl2ZXJlZCA9IHVwZGF0ZWRQYWNrYWdpbmdzLmV2ZXJ5KHAgPT4gcC5zdGF0dXMgPT09ICdI4buneSDEkcOzbmcgZ8OzaScgfHwgcC5kZWxpdmVyeVN0YXR1cyA9PT0gJ8SQw6MgZ2lhbyBow6BuZycpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IG5ld1N0YXR1cyA9IG9yZGVyLnN0YXR1cyA9PT0gJ8SQ4bq3dCBow6BuZycgPyAnxJBhbmcgZ2lhbyBk4buLY2gnIDogb3JkZXIuc3RhdHVzO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q29tcGxldGVkRGF0ZSA9IG9yZGVyLmNvbXBsZXRlZERhdGU7XHJcbiAgICAgICAgICAgIGlmIChpc0FsbERlbGl2ZXJlZCAmJiBvcmRlci5wYXltZW50U3RhdHVzID09PSAnVGhhbmggdG/DoW4gdG/DoG4gYuG7mScpIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXR1cyA9ICdIb8OgbiB0aMOgbmgnO1xyXG4gICAgICAgICAgICAgICAgbmV3Q29tcGxldGVkRGF0ZSA9IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgQ3JlYXRlIHNoaXBtZW50IHJlY29yZCBmb3IgSU5TVE9SRSBwaWNrdXBcclxuICAgICAgICAgICAgY29uc3QgcGFja2FnaW5nID0gb3JkZXIucGFja2FnaW5ncy5maW5kKHAgPT4gcC5zeXN0ZW1JZCA9PT0gcGFja2FnaW5nU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBsZXQgbmV3U2hpcG1lbnQ6IFNoaXBtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChwYWNrYWdpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlU2hpcG1lbnQsIHVwZGF0ZVNoaXBtZW50IH0gPSB1c2VTaGlwbWVudFN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdTaGlwbWVudCA9IGNyZWF0ZVNoaXBtZW50KHtcclxuICAgICAgICAgICAgICAgICAgICBwYWNrYWdpbmdTeXN0ZW1JZDogcGFja2FnaW5nU3lzdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJTeXN0ZW1JZDogb3JkZXJTeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBvcmRlcklkOiBvcmRlci5pZCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0NvZGU6ICcnLCAvLyBXaWxsIGJlIHNldCB0byBzaGlwbWVudCBidXNpbmVzcyBJRCBiZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJpZXI6ICdOaOG6rW4gdOG6oWkgY+G7rWEgaMOgbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdOaOG6rW4gdOG6oWkgY+G7rWEgaMOgbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnxJDDoyBnaWFvIGjDoG5nJyxcclxuICAgICAgICAgICAgICAgICAgICBwcmludFN0YXR1czogJ0NoxrBhIGluJyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvbmNpbGlhdGlvblN0YXR1czogJ0NoxrBhIMSR4buRaSBzb8OhdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hpcHBpbmdGZWVUb1BhcnRuZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY29kQW1vdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheWVyOiAnTmfGsOG7nWkgZ+G7rWknLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRBdDogbm93LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJlZEF0OiBub3csXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzaGlwbWVudCB0cmFja2luZ0NvZGUgdG8gdXNlIGl0cyBvd24gYnVzaW5lc3MgSURcclxuICAgICAgICAgICAgICAgIGlmIChuZXdTaGlwbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNoaXBtZW50KG5ld1NoaXBtZW50LnN5c3RlbUlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nQ29kZTogbmV3U2hpcG1lbnQuaWQsIC8vIFVzZSBzaGlwbWVudCBidXNpbmVzcyBJRCAoVkMwMDBYWFgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHBhY2thZ2luZyB3aXRoIHNoaXBtZW50IHRyYWNraW5nQ29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRQYWNrYWdpbmdzID0gdXBkYXRlZFBhY2thZ2luZ3MubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5zeXN0ZW1JZCA9PT0gcGFja2FnaW5nU3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnAsIHRyYWNraW5nQ29kZTogbmV3U2hpcG1lbnQhLmlkIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFtjb25maXJtSW5TdG9yZVBpY2t1cF0gU2hpcG1lbnQgY3JlYXRlZDonLCBuZXdTaGlwbWVudD8uaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7IFxyXG4gICAgICAgICAgICAgICAgLi4ub3JkZXIsIFxyXG4gICAgICAgICAgICAgICAgcGFja2FnaW5nczogdXBkYXRlZFBhY2thZ2luZ3MsIFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6ICfEkMOjIGdpYW8gaMOgbmcnIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld1N0YXR1cyxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZERhdGU6IG5ld0NvbXBsZXRlZERhdGUsXHJcbiAgICAgICAgICAgICAgICBzdG9ja091dFN0YXR1czogJ1h14bqldCBraG8gdG/DoG4gYuG7mScgYXMgY29uc3QsXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVkRGF0ZTogdG9JU09EYXRlVGltZShuZXcgRGF0ZSgpKSxcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRCeUVtcGxveWVlSWQ6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVkQnlFbXBsb3llZU5hbWU6IGVtcGxveWVlPy5mdWxsTmFtZSxcclxuICAgICAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFtjb25maXJtSW5TdG9yZVBpY2t1cF0gU3RvY2sgZGlzcGF0Y2hlZCBzdWNjZXNzZnVsbHknKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogc3RhdGUuZGF0YS5tYXAobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbykgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0sICAgIFxyXG4gICAgY29uZmlybVBhcnRuZXJTaGlwbWVudDogYXN5bmMgKG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZDogU3lzdGVtSWQsIHNoaXBtZW50RGF0YTogYW55KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PiA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKCFvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdLaMO0bmcgdMOsbSB0aOG6pXkgxJHGoW4gaMOgbmcnIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBDaGVjayBuZWdhdGl2ZSBwYWNraW5nIHNldHRpbmcgKGNvdmVycyBjcmVhdGluZyBzaGlwbWVudClcclxuICAgICAgICAgICAgY29uc3QgeyBhbGxvd05lZ2F0aXZlUGFja2luZyB9ID0gdXNlU2FsZXNNYW5hZ2VtZW50U2V0dGluZ3NTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoIWFsbG93TmVnYXRpdmVQYWNraW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpbmRCeUlkOiBmaW5kUHJvZHVjdEJ5SWQgfSA9IHVzZVByb2R1Y3RTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9yZGVyLmxpbmVJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBmaW5kUHJvZHVjdEJ5SWQoYXNTeXN0ZW1JZChpdGVtLnByb2R1Y3RTeXN0ZW1JZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9kdWN0ICYmIGlzQ29tYm9Qcm9kdWN0KHByb2R1Y3QpICYmIHByb2R1Y3QuY29tYm9JdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbWJvSXRlbSBvZiBwcm9kdWN0LmNvbWJvSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvZHVjdCA9IGZpbmRQcm9kdWN0QnlJZChhc1N5c3RlbUlkKGNvbWJvSXRlbS5wcm9kdWN0U3lzdGVtSWQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkUXR5ID0gaXRlbS5xdWFudGl0eSAqIGNvbWJvSXRlbS5xdWFudGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9jayA9IGNoaWxkUHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltvcmRlci5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RvY2sgPCByZXF1aXJlZFF0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBgS2jDtG5nIHRo4buDIHThuqFvIHbhuq1uIMSRxqFuOiBT4bqjbiBwaOG6qW0gXCIke2NoaWxkUHJvZHVjdD8ubmFtZX1cIiBraMO0bmcgxJHhu6cgdOG7k24ga2hvYCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b2NrID0gcHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltvcmRlci5icmFuY2hTeXN0ZW1JZF0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdG9jayA8IGl0ZW0ucXVhbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBgS2jDtG5nIHRo4buDIHThuqFvIHbhuq1uIMSRxqFuOiBT4bqjbiBwaOG6qW0gXCIke2l0ZW0ucHJvZHVjdE5hbWV9XCIga2jDtG5nIMSR4bunIHThu5NuIGtob2AgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEdldCBHSFRLIHByZXZpZXcgcGFyYW1zIGZyb20gd2luZG93IChzZXQgYnkgU2hpcHBpbmdJbnRlZ3JhdGlvbilcclxuICAgICAgICAgICAgY29uc3QgZ2h0a1BhcmFtcyA9ICh3aW5kb3cgYXMgYW55KS5fX2dodGtQcmV2aWV3UGFyYW1zO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFnaHRrUGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ1RoaeG6v3UgdGjDtG5nIHRpbiB24bqtbiBjaHV54buDbi4gVnVpIGzDsm5nIGNo4buNbiBk4buLY2ggduG7pSB24bqtbiBjaHV54buDbi4nIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBJbXBvcnQgR0hUSyBzZXJ2aWNlIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIGNvbnN0IHsgR0hUS1NlcnZpY2UgfSA9IGF3YWl0IGltcG9ydCgnLi4vc2V0dGluZ3Mvc2hpcHBpbmcvaW50ZWdyYXRpb25zL2dodGstc2VydmljZScpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldEdIVEtDcmVkZW50aWFscyB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi9saWIvdXRpbHMvZ2V0LXNoaXBwaW5nLWNyZWRlbnRpYWxzJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB7IGFwaVRva2VuLCBwYXJ0bmVyQ29kZSB9ID0gZ2V0R0hUS0NyZWRlbnRpYWxzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdodGtTZXJ2aWNlID0gbmV3IEdIVEtTZXJ2aWNlKGFwaVRva2VuLCBwYXJ0bmVyQ29kZSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpCBbY29uZmlybVBhcnRuZXJTaGlwbWVudF0gQ2FsbGluZyBHSFRLIEFQSSB3aXRoIHBhcmFtczonLCBnaHRrUGFyYW1zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBDYWxsIHJlYWwgR0hUSyBBUElcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2h0a1NlcnZpY2UuY3JlYXRlT3JkZXIoZ2h0a1BhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzIHx8ICFyZXN1bHQub3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQubWVzc2FnZSB8fCAnS2jDtG5nIHRo4buDIHThuqFvIMSRxqFuIHbhuq1uIGNodXnhu4NuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgb3JkZXIgd2l0aCByZWFsIHRyYWNraW5nIGNvZGUgZnJvbSBHSFRLXHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nQ29kZSA9IHJlc3VsdC5vcmRlci5sYWJlbDtcclxuICAgICAgICAgICAgY29uc3QgZ2h0a1RyYWNraW5nSWQgPSByZXN1bHQub3JkZXIudHJhY2tpbmdfaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZFBpY2tUaW1lID0gcmVzdWx0Lm9yZGVyLmVzdGltYXRlZF9waWNrX3RpbWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZERlbGl2ZXJUaW1lID0gcmVzdWx0Lm9yZGVyLmVzdGltYXRlZF9kZWxpdmVyX3RpbWU7XHJcblxyXG4gICAgICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBhY2thZ2luZ3MgPSBvcmRlci5wYWNrYWdpbmdzLm1hcChwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocC5zeXN0ZW1JZCA9PT0gcGFja2FnaW5nU3lzdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeU1ldGhvZDogJ0Thu4tjaCB24bulIGdpYW8gaMOgbmcnIGFzIE9yZGVyRGVsaXZlcnlNZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ0No4budIGzhuqV5IGjDoG5nJyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FycmllcjogJ0dIVEsnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZTogcmVzdWx0Lm9yZGVyPy5mZWUgPyBgJHtyZXN1bHQub3JkZXIuZmVlfcSRYCA6ICdTdGFuZGFyZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0NvZGU6IHRyYWNraW5nQ29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaXBwaW5nRmVlVG9QYXJ0bmVyOiBwYXJzZUludChyZXN1bHQub3JkZXI/LmZlZSB8fCAnMCcpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RBbW91bnQ6IGdodGtQYXJhbXMucGlja19tb25leSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5ZXI6IChnaHRrUGFyYW1zLmlzX2ZyZWVzaGlwID09PSAxID8gJ05nxrDhu51pIGfhu61pJyA6ICdOZ8aw4budaSBuaOG6rW4nKSBhcyAnTmfGsOG7nWkgZ+G7rWknIHwgJ05nxrDhu51pIG5o4bqtbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RlVG9TaGlwcGVyOiBnaHRrUGFyYW1zLm5vdGUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGdodGtQYXJhbXMud2VpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogYCR7Z2h0a1BhcmFtcy5wcm9kdWN0cz8uWzBdPy5sZW5ndGggfHwgMTB9w5cke2dodGtQYXJhbXMucHJvZHVjdHM/LlswXT8ud2lkdGggfHwgMTB9w5cke2dodGtQYXJhbXMucHJvZHVjdHM/LlswXT8uaGVpZ2h0IHx8IDEwfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDinIUgU3RvcmUgR0hUSyBzcGVjaWZpYyBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaHRrVHJhY2tpbmdJZDogU3RyaW5nKGdodGtUcmFja2luZ0lkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZFBpY2tUaW1lOiBlc3RpbWF0ZWRQaWNrVGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZERlbGl2ZXJUaW1lOiBlc3RpbWF0ZWREZWxpdmVyVGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9yZGVyID0geyBcclxuICAgICAgICAgICAgICAgICAgICAuLi5vcmRlciwgXHJcbiAgICAgICAgICAgICAgICAgICAgcGFja2FnaW5nczogdXBkYXRlZFBhY2thZ2luZ3MsIFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnQ2jhu50gbOG6pXkgaMOgbmcnIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsIFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ8SQYW5nIGdpYW8gZOG7i2NoJyBhcyBPcmRlck1haW5TdGF0dXMgXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQgPyB1cGRhdGVkT3JkZXIgOiBvKSB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgW2NvbmZpcm1QYXJ0bmVyU2hpcG1lbnRdIEdIVEsgb3JkZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHk6Jywge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tpbmdDb2RlLFxyXG4gICAgICAgICAgICAgICAgZ2h0a1RyYWNraW5nSWQsXHJcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRQaWNrVGltZSxcclxuICAgICAgICAgICAgICAgIGVzdGltYXRlZERlbGl2ZXJUaW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBU4bqhbyB24bqtbiDEkcahbiB0aMOgbmggY8O0bmchIE3DoyB24bqtbiDEkcahbjogJHt0cmFja2luZ0NvZGV9YCBcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFtjb25maXJtUGFydG5lclNoaXBtZW50XSBFcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Z1aSBsw7JuZyB0aOG7rSBs4bqhaSc7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBM4buXaSB04bqhbyDEkcahbiB24bqtbiBjaHV54buDbjogJHtlcnJvck1lc3NhZ2V9YCBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoRnJvbVdhcmVob3VzZTogKG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZDogU3lzdGVtSWQsIGVtcGxveWVlSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgLy8g4pyFIENoZWNrIG5lZ2F0aXZlIHN0b2NrIG91dCBzZXR0aW5nXHJcbiAgICAgICAgY29uc3QgeyBhbGxvd05lZ2F0aXZlU3RvY2tPdXQgfSA9IHVzZVNhbGVzTWFuYWdlbWVudFNldHRpbmdzU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICBpZiAoIWFsbG93TmVnYXRpdmVTdG9ja091dCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmRhdGEuZmluZChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBpZiAob3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmluZEJ5SWQ6IGZpbmRQcm9kdWN0QnlJZCB9ID0gdXNlUHJvZHVjdFN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3JkZXIubGluZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IGZpbmRQcm9kdWN0QnlJZChhc1N5c3RlbUlkKGl0ZW0ucHJvZHVjdFN5c3RlbUlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2R1Y3QgJiYgaXNDb21ib1Byb2R1Y3QocHJvZHVjdCkgJiYgcHJvZHVjdC5jb21ib0l0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29tYm9JdGVtIG9mIHByb2R1Y3QuY29tYm9JdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRQcm9kdWN0ID0gZmluZFByb2R1Y3RCeUlkKGFzU3lzdGVtSWQoY29tYm9JdGVtLnByb2R1Y3RTeXN0ZW1JZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRRdHkgPSBpdGVtLnF1YW50aXR5ICogY29tYm9JdGVtLnF1YW50aXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b2NrID0gY2hpbGRQcm9kdWN0Py5pbnZlbnRvcnlCeUJyYW5jaD8uW29yZGVyLmJyYW5jaFN5c3RlbUlkXSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdG9jayA8IHJlcXVpcmVkUXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoYEtow7RuZyB0aOG7gyB4deG6pXQga2hvOiBT4bqjbiBwaOG6qW0gXCIke2NoaWxkUHJvZHVjdD8ubmFtZX1cIiBraMO0bmcgxJHhu6cgdOG7k24ga2hvIChDw7M6ICR7Y3VycmVudFN0b2NrfSwgQ+G6p246ICR7cmVxdWlyZWRRdHl9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9jayA9IHByb2R1Y3Q/LmludmVudG9yeUJ5QnJhbmNoPy5bb3JkZXIuYnJhbmNoU3lzdGVtSWRdIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RvY2sgPCBpdGVtLnF1YW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChgS2jDtG5nIHRo4buDIHh14bqldCBraG86IFPhuqNuIHBo4bqpbSBcIiR7aXRlbS5wcm9kdWN0TmFtZX1cIiBraMO0bmcgxJHhu6cgdOG7k24ga2hvIChDw7M6ICR7Y3VycmVudFN0b2NrfSwgQ+G6p246ICR7aXRlbS5xdWFudGl0eX0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gc3RhdGUuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXIpIHJldHVybiBzdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkRW50cnk6IGFkZFN0b2NrSGlzdG9yeSB9ID0gdXNlU3RvY2tIaXN0b3J5U3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWVEYXRhID0gdXNlRW1wbG95ZWVTdG9yZS5nZXRTdGF0ZSgpLmZpbmRCeUlkKGVtcGxveWVlSWQgYXMgU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgb3JkZXIubGluZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyDinIUgRGlzcGF0Y2ggc3RvY2sgKGjhu5cgdHLhu6MgY29tYm8gLSBz4bq9IGRpc3BhdGNoIFNQIGNvbilcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEl0ZW1zID0gcHJvY2Vzc0xpbmVJdGVtU3RvY2soaXRlbSwgZ2V0QnJhbmNoSWQob3JkZXIpLCAnZGlzcGF0Y2gnLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8g4pyFIEFkZCBzdG9jayBoaXN0b3J5IGVudHJ5IGZvciBlYWNoIHByb2Nlc3NlZCBpdGVtXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRJdGVtcy5mb3JFYWNoKHByb2Nlc3NlZEl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSB1c2VQcm9kdWN0U3RvcmUuZ2V0U3RhdGUoKS5maW5kQnlJZChwcm9jZXNzZWRJdGVtLnByb2R1Y3RTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b2NrID0gcHJvZHVjdD8uaW52ZW50b3J5QnlCcmFuY2g/LltnZXRCcmFuY2hJZChvcmRlcildIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkU3RvY2tIaXN0b3J5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogbm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2Nlc3NlZEl0ZW0ucHJvZHVjdFN5c3RlbUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdYdeG6pXQga2hvICjEkMahbiBow6BuZyknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eUNoYW5nZTogLXByb2Nlc3NlZEl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0b2NrTGV2ZWw6IGN1cnJlbnRTdG9jayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogb3JkZXIuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaFN5c3RlbUlkOiBnZXRCcmFuY2hJZChvcmRlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaDogb3JkZXIuYnJhbmNoTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1wbG95ZWVOYW1lOiBlbXBsb3llZURhdGE/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3Qgbm93MiA9IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4gXHJcbiAgICAgICAgICAgICAgICBwLnN5c3RlbUlkID09PSBwYWNrYWdpbmdTeXN0ZW1JZCA/IHsgLi4ucCwgZGVsaXZlcnlTdGF0dXM6ICfEkGFuZyBnaWFvIGjDoG5nJyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzIH0gOiBwXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5vcmRlcixcclxuICAgICAgICAgICAgICAgIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzLFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6ICfEkGFuZyBnaWFvIGjDoG5nJyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgc3RvY2tPdXRTdGF0dXM6ICdYdeG6pXQga2hvIHRvw6BuIGLhu5knIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlZERhdGU6IG5vdzIsXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVkQnlFbXBsb3llZUlkOiBlbXBsb3llZUlkLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlZEJ5RW1wbG95ZWVOYW1lOiBlbXBsb3llZURhdGE/LmZ1bGxOYW1lLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlci5zdGF0dXMgPT09ICfEkOG6t3QgaMOgbmcnID8gJ8SQYW5nIGdpYW8gZOG7i2NoJyA6IG9yZGVyLnN0YXR1cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogc3RhdGUuZGF0YS5tYXAobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbykgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgY29tcGxldGVEZWxpdmVyeTogKG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZDogU3lzdGVtSWQsIGVtcGxveWVlSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBzdGF0ZS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKCFvcmRlcikgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4pyFIENvbXBsZXRlIGRlbGl2ZXJ5ICho4buXIHRy4bujIGNvbWJvIC0gc+G6vSBjb21wbGV0ZSBTUCBjb24pXHJcbiAgICAgICAgICAgIG9yZGVyLmxpbmVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0xpbmVJdGVtU3RvY2soaXRlbSwgZ2V0QnJhbmNoSWQob3JkZXIpLCAnY29tcGxldGUnLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4gXHJcbiAgICAgICAgICAgICAgICBwLnN5c3RlbUlkID09PSBwYWNrYWdpbmdTeXN0ZW1JZCA/IHsgLi4ucCwgZGVsaXZlcnlTdGF0dXM6ICfEkMOjIGdpYW8gaMOgbmcnIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsIGRlbGl2ZXJlZERhdGU6IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSkgfSA6IHBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGlzQWxsRGVsaXZlcmVkID0gdXBkYXRlZFBhY2thZ2luZ3MuZXZlcnkocCA9PiBwLnN0YXR1cyA9PT0gJ0jhu6d5IMSRw7NuZyBnw7NpJyB8fCBwLmRlbGl2ZXJ5U3RhdHVzID09PSAnxJDDoyBnaWFvIGjDoG5nJyk7XHJcbiAgICAgICAgICAgIGxldCBuZXdTdGF0dXMgPSBvcmRlci5zdGF0dXM7XHJcbiAgICAgICAgICAgIGxldCBuZXdDb21wbGV0ZWREYXRlID0gb3JkZXIuY29tcGxldGVkRGF0ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBLaGkgdOG6pXQgY+G6oyDEkcahbiDEkcOjIGdpYW8g4oaSIHThuqFvIGPDtG5nIG7hu6MgKG7hur91IGPDsykgdsOgIGPhuq1wIG5o4bqtdCBzdGF0c1xyXG4gICAgICAgICAgICBpZiAoaXNBbGxEZWxpdmVyZWQgJiYgb3JkZXIuc3RhdHVzICE9PSAnSG/DoG4gdGjDoG5oJykge1xyXG4gICAgICAgICAgICAgICAgLy8gVMOtbmggY8O0bmcgbuG7oyBjw7JuIGzhuqFpXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFBhaWQgPSAob3JkZXIucGF5bWVudHMgfHwgW10pLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmFtb3VudCwgMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWJ0QW1vdW50ID0gTWF0aC5tYXgoMCwgb3JkZXIuZ3JhbmRUb3RhbCAtIHRvdGFsUGFpZCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIOKchSBU4bqhbyBjw7RuZyBu4bujIENI4buIIEtISSBnaWFvIGjDoG5nIHRow6BuaCBjw7RuZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlYnRBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhZGREZWJ0VHJhbnNhY3Rpb24gfSA9IHVzZUN1c3RvbWVyU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkdWVEYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkdWVEYXRlLnNldERhdGUoZHVlRGF0ZS5nZXREYXRlKCkgKyAzMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVidFRyYW5zYWN0aW9uKG9yZGVyLmN1c3RvbWVyU3lzdGVtSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3lzdGVtSWQ6IGFzU3lzdGVtSWQoYERFQlRfJHtvcmRlci5zeXN0ZW1JZH1gKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXIuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyRGF0ZTogb3JkZXIub3JkZXJEYXRlLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogZGVidEFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVlRGF0ZTogZHVlRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0Ftb3VudDogZGVidEFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXM6ICdDw7RuZyBu4bujIHThu6sgxJHGoW4gaMOgbmcgxJHDoyBnaWFvIHRow6BuaCBjw7RuZycsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjdXN0b21lciBzdGF0c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmNyZW1lbnRPcmRlclN0YXRzIH0gPSB1c2VDdXN0b21lclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRPcmRlclN0YXRzKG9yZGVyLmN1c3RvbWVyU3lzdGVtSWQsIG9yZGVyLmdyYW5kVG90YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBvcmRlciBpcyBmdWxseSBjb21wbGV0ZSAoZGVsaXZlcmVkICsgZnVsbHkgcGFpZClcclxuICAgICAgICAgICAgaWYgKGlzQWxsRGVsaXZlcmVkICYmIG9yZGVyLnBheW1lbnRTdGF0dXMgPT09ICdUaGFuaCB0b8OhbiB0b8OgbiBi4buZJykge1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdHVzID0gJ0hvw6BuIHRow6BuaCc7XHJcbiAgICAgICAgICAgICAgICBuZXdDb21wbGV0ZWREYXRlID0gdG9JU09EYXRlVGltZShuZXcgRGF0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZmluZEJ5SWQoZW1wbG95ZWVJZCBhcyBTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IHsgXHJcbiAgICAgICAgICAgICAgICAuLi5vcmRlciwgXHJcbiAgICAgICAgICAgICAgICBwYWNrYWdpbmdzOiB1cGRhdGVkUGFja2FnaW5ncywgXHJcbiAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogJ8SQw6MgZ2lhbyBow6BuZycgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cywgXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld1N0YXR1cywgXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWREYXRlOiBuZXdDb21wbGV0ZWREYXRlLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZpdHlIaXN0b3J5OiBhcHBlbmRIaXN0b3J5RW50cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIuYWN0aXZpdHlIaXN0b3J5LFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUhpc3RvcnlFbnRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXR1c19jaGFuZ2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q3VycmVudFVzZXJJbmZvKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2VtcGxveWVlPy5mdWxsTmFtZSB8fCAnTmjDom4gdmnDqm4nfSDEkcOjIHjDoWMgbmjhuq1uIGdpYW8gaMOgbmcgdGjDoG5oIGPDtG5nJHtuZXdTdGF0dXMgPT09ICdIb8OgbiB0aMOgbmgnID8gJy4gxJDGoW4gaMOgbmcgaG/DoG4gdGjDoG5oJyA6ICcnfWBcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQgPyB1cGRhdGVkT3JkZXIgOiBvKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBmYWlsRGVsaXZlcnk6IChvcmRlclN5c3RlbUlkOiBTeXN0ZW1JZCwgcGFja2FnaW5nU3lzdGVtSWQ6IFN5c3RlbUlkLCBlbXBsb3llZUlkOiBTeXN0ZW1JZCwgcmVhc29uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBiYXNlU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IHN0YXRlLmRhdGEuZmluZChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICBpZiAoIW9yZGVyKSByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaW5jcmVtZW50RmFpbGVkRGVsaXZlcnlTdGF0cyB9ID0gdXNlQ3VzdG9tZXJTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4pyFIFJldHVybiBzdG9jayBmcm9tIHRyYW5zaXQgKGjhu5cgdHLhu6MgY29tYm8gLSBz4bq9IHJldHVybiBTUCBjb24pXHJcbiAgICAgICAgICAgIG9yZGVyLmxpbmVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0xpbmVJdGVtU3RvY2soaXRlbSwgZ2V0QnJhbmNoSWQob3JkZXIpLCAncmV0dXJuJywgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBjdXN0b21lciBmYWlsZWQgZGVsaXZlcnkgc3RhdHNcclxuICAgICAgICAgICAgaW5jcmVtZW50RmFpbGVkRGVsaXZlcnlTdGF0cyhvcmRlci5jdXN0b21lclN5c3RlbUlkKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYWNrYWdpbmdzID0gb3JkZXIucGFja2FnaW5ncy5tYXAocCA9PiBcclxuICAgICAgICAgICAgICAgIHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkID8geyAuLi5wLCBkZWxpdmVyeVN0YXR1czogJ0No4budIGdpYW8gbOG6oWknIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMsIG5vdGVzOiBgR2lhbyB0aOG6pXQgYuG6oWk6ICR7cmVhc29ufWAgfSA6IHBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IHsgLi4ub3JkZXIsIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzLCBkZWxpdmVyeVN0YXR1czogJ0No4budIGdpYW8gbOG6oWknIGFzIE9yZGVyRGVsaXZlcnlTdGF0dXMgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogc3RhdGUuZGF0YS5tYXAobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbykgfTtcclxuICAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIOKchSBI4buneSBnaWFvIGjDoG5nIC0gS0jDlE5HIHRy4bqjIGjDoG5nIHbhu4Ega2hvIChow6BuZyBi4buLIHRo4bqldCB0dW5nL3NoaXBwZXIgZ2nhu68pXHJcbiAgICBjYW5jZWxEZWxpdmVyeU9ubHk6IChvcmRlclN5c3RlbUlkOiBTeXN0ZW1JZCwgcGFja2FnaW5nU3lzdGVtSWQ6IFN5c3RlbUlkLCBlbXBsb3llZUlkOiBTeXN0ZW1JZCwgcmVhc29uOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50T3JkZXIgPSBiYXNlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICBpZiAoIWVuc3VyZUNhbmNlbGxhdGlvbkFsbG93ZWQoY3VycmVudE9yZGVyLCAnaOG7p3kgZ2lhbyBow6BuZycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gc3RhdGUuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXIpIHJldHVybiBzdGF0ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBHZXQgZW1wbG95ZWUgaW5mbyBmb3IgY2FuY2VsbGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlRGF0YSA9IHVzZUVtcGxveWVlU3RvcmUuZ2V0U3RhdGUoKS5maW5kQnlJZChlbXBsb3llZUlkIGFzIFN5c3RlbUlkKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYWNrYWdpbmdzID0gb3JkZXIucGFja2FnaW5ncy5tYXAocCA9PiBcclxuICAgICAgICAgICAgICAgIHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkID8geyBcclxuICAgICAgICAgICAgICAgICAgICAuLi5wLCBcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdI4buneSDEkcOzbmcgZ8OzaScgYXMgUGFja2FnaW5nU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnxJDDoyBo4buneScgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxSZWFzb246IGBI4buneSBnaWFvIGjDoG5nOiAke3JlYXNvbn1gLCBcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxEYXRlOiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGluZ0VtcGxveWVlSWQ6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsaW5nRW1wbG95ZWVOYW1lOiBlbXBsb3llZURhdGE/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgICAgICAgICAgICAgfSA6IHBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBDaGVjayBpZiBhbGwgcGFja2FnaW5ncyBhcmUgY2FuY2VsbGVkLCB1cGRhdGUgb3JkZXIgc3RhdHVzIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbENhbmNlbGxlZCA9IHVwZGF0ZWRQYWNrYWdpbmdzLmV2ZXJ5KHAgPT4gcC5kZWxpdmVyeVN0YXR1cyA9PT0gJ8SQw6MgaOG7p3knIHx8IHAuc3RhdHVzID09PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgY29uc3QgaGFzQW55QWN0aXZlID0gdXBkYXRlZFBhY2thZ2luZ3Muc29tZShwID0+IHAuZGVsaXZlcnlTdGF0dXMgJiYgcC5kZWxpdmVyeVN0YXR1cyAhPT0gJ8SQw6MgaOG7p3knICYmIHAuc3RhdHVzICE9PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBuZXdPcmRlclN0YXR1cyA9IG9yZGVyLnN0YXR1cztcclxuICAgICAgICAgICAgbGV0IG5ld0RlbGl2ZXJ5U3RhdHVzID0gb3JkZXIuZGVsaXZlcnlTdGF0dXM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYWxsQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgcGFja2FnaW5ncyBjYW5jZWxsZWQg4oaSIG9yZGVyIGdvZXMgYmFjayB0byBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBuZXdPcmRlclN0YXR1cyA9ICfEkGFuZyBnaWFvIGThu4tjaCcgYXMgT3JkZXJNYWluU3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgbmV3RGVsaXZlcnlTdGF0dXMgPSAnQ2jGsGEgZ2lhbyBow6BuZycgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNBbnlBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgcGFja2FnaW5ncyBzdGlsbCBhY3RpdmUg4oaSIGtlZXAgY3VycmVudCBkZWxpdmVyeSBzdGF0dXMgb2YgcmVtYWluaW5nIGFjdGl2ZSBwYWNrYWdpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVBhY2thZ2luZyA9IHVwZGF0ZWRQYWNrYWdpbmdzLmZpbmQocCA9PiBwLmRlbGl2ZXJ5U3RhdHVzICYmIHAuZGVsaXZlcnlTdGF0dXMgIT09ICfEkMOjIGjhu6d5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlUGFja2FnaW5nPy5kZWxpdmVyeVN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlbGl2ZXJ5U3RhdHVzID0gYWN0aXZlUGFja2FnaW5nLmRlbGl2ZXJ5U3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7IFxyXG4gICAgICAgICAgICAgICAgLi4ub3JkZXIsIFxyXG4gICAgICAgICAgICAgICAgcGFja2FnaW5nczogdXBkYXRlZFBhY2thZ2luZ3MsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld09yZGVyU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6IG5ld0RlbGl2ZXJ5U3RhdHVzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHN0YXRlLmRhdGEubWFwKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCA/IHVwZGF0ZWRPcmRlciA6IG8pIH07XHJcbiAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyDinIUgSOG7p3kgZ2lhbyB2w6Agbmjhuq1uIGzhuqFpIGjDoG5nIC0gVFLhuqIgaMOgbmcgduG7gSBraG8gKMSRw6Mgbmjhuq1uIGzhuqFpIHThu6sgc2hpcHBlcilcclxuICAgIGNhbmNlbERlbGl2ZXJ5OiAob3JkZXJTeXN0ZW1JZDogU3lzdGVtSWQsIHBhY2thZ2luZ1N5c3RlbUlkOiBTeXN0ZW1JZCwgZW1wbG95ZWVJZDogU3lzdGVtSWQsIHJlYXNvbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE9yZGVyID0gYmFzZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgaWYgKCFlbnN1cmVDYW5jZWxsYXRpb25BbGxvd2VkKGN1cnJlbnRPcmRlciwgJ2jhu6d5IGdpYW8gaMOgbmcnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBzdGF0ZS5kYXRhLmZpbmQobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkKTtcclxuICAgICAgICAgICAgaWYgKCFvcmRlcikgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4pyFIFRS4bqiIGjDoG5nIHThu6sgXCLEkWFuZyBnaWFvXCIgduG7gSBcInThu5NuIGtob1wiICho4buXIHRy4bujIGNvbWJvIC0gc+G6vSByZXR1cm4gU1AgY29uKVxyXG4gICAgICAgICAgICBvcmRlci5saW5lSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NMaW5lSXRlbVN0b2NrKGl0ZW0sIGdldEJyYW5jaElkKG9yZGVyKSwgJ3JldHVybicsIGl0ZW0ucXVhbnRpdHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBHZXQgZW1wbG95ZWUgaW5mbyBmb3IgY2FuY2VsbGVyXHJcbiAgICAgICAgICAgIGNvbnN0IGVtcGxveWVlRGF0YSA9IHVzZUVtcGxveWVlU3RvcmUuZ2V0U3RhdGUoKS5maW5kQnlJZChlbXBsb3llZUlkIGFzIFN5c3RlbUlkKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYWNrYWdpbmdzID0gb3JkZXIucGFja2FnaW5ncy5tYXAocCA9PiBcclxuICAgICAgICAgICAgICAgIHAuc3lzdGVtSWQgPT09IHBhY2thZ2luZ1N5c3RlbUlkID8geyBcclxuICAgICAgICAgICAgICAgICAgICAuLi5wLCBcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdI4buneSDEkcOzbmcgZ8OzaScgYXMgUGFja2FnaW5nU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJ5U3RhdHVzOiAnxJDDoyBo4buneScgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxSZWFzb246IGBI4buneSBnaWFvIGjDoG5nOiAke3JlYXNvbn1gLCBcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxEYXRlOiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGluZ0VtcGxveWVlSWQ6IGVtcGxveWVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsaW5nRW1wbG95ZWVOYW1lOiBlbXBsb3llZURhdGE/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgICAgICAgICAgICAgfSA6IHBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBDaGVjayBpZiBhbGwgcGFja2FnaW5ncyBhcmUgY2FuY2VsbGVkLCB1cGRhdGUgb3JkZXIgc3RhdHVzIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbENhbmNlbGxlZCA9IHVwZGF0ZWRQYWNrYWdpbmdzLmV2ZXJ5KHAgPT4gcC5kZWxpdmVyeVN0YXR1cyA9PT0gJ8SQw6MgaOG7p3knIHx8IHAuc3RhdHVzID09PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgY29uc3QgaGFzQW55QWN0aXZlID0gdXBkYXRlZFBhY2thZ2luZ3Muc29tZShwID0+IHAuZGVsaXZlcnlTdGF0dXMgJiYgcC5kZWxpdmVyeVN0YXR1cyAhPT0gJ8SQw6MgaOG7p3knICYmIHAuc3RhdHVzICE9PSAnSOG7p3kgxJHDs25nIGfDs2knKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBuZXdPcmRlclN0YXR1cyA9IG9yZGVyLnN0YXR1cztcclxuICAgICAgICAgICAgbGV0IG5ld0RlbGl2ZXJ5U3RhdHVzID0gb3JkZXIuZGVsaXZlcnlTdGF0dXM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYWxsQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgcGFja2FnaW5ncyBjYW5jZWxsZWQg4oaSIG9yZGVyIGdvZXMgYmFjayB0byBwZW5kaW5nIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBuZXdPcmRlclN0YXR1cyA9ICfEkGFuZyBnaWFvIGThu4tjaCcgYXMgT3JkZXJNYWluU3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgbmV3RGVsaXZlcnlTdGF0dXMgPSAnQ2jGsGEgZ2lhbyBow6BuZycgYXMgT3JkZXJEZWxpdmVyeVN0YXR1cztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNBbnlBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbWUgcGFja2FnaW5ncyBzdGlsbCBhY3RpdmUg4oaSIGtlZXAgY3VycmVudCBkZWxpdmVyeSBzdGF0dXMgb2YgcmVtYWluaW5nIGFjdGl2ZSBwYWNrYWdpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVBhY2thZ2luZyA9IHVwZGF0ZWRQYWNrYWdpbmdzLmZpbmQocCA9PiBwLmRlbGl2ZXJ5U3RhdHVzICYmIHAuZGVsaXZlcnlTdGF0dXMgIT09ICfEkMOjIGjhu6d5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlUGFja2FnaW5nPy5kZWxpdmVyeVN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlbGl2ZXJ5U3RhdHVzID0gYWN0aXZlUGFja2FnaW5nLmRlbGl2ZXJ5U3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7IFxyXG4gICAgICAgICAgICAgICAgLi4ub3JkZXIsIFxyXG4gICAgICAgICAgICAgICAgcGFja2FnaW5nczogdXBkYXRlZFBhY2thZ2luZ3MsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld09yZGVyU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6IG5ld0RlbGl2ZXJ5U3RhdHVzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHN0YXRlLmRhdGEubWFwKG8gPT4gby5zeXN0ZW1JZCA9PT0gb3JkZXJTeXN0ZW1JZCA/IHVwZGF0ZWRPcmRlciA6IG8pIH07XHJcbiAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb25maXJtQ29kUmVjb25jaWxpYXRpb246IChzaGlwbWVudHM6IChQYWNrYWdpbmcgJiB7IG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkIH0pW10sIGVtcGxveWVlSWQ6IFN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBhZGQ6IGFkZFJlY2VpcHQgfSA9IHVzZVJlY2VpcHRTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHVzZUNhc2hib29rU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCB7IGRhdGE6IHJlY2VpcHRUeXBlcyB9ID0gdXNlUmVjZWlwdFR5cGVTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGVtcGxveWVlID0gdXNlRW1wbG95ZWVTdG9yZS5nZXRTdGF0ZSgpLmZpbmRCeUlkKGVtcGxveWVlSWQgYXMgU3lzdGVtSWQpO1xyXG4gICAgICAgIGNvbnN0IGFsbE9yZGVycyA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpLmRhdGE7XHJcbiAgICBcclxuICAgICAgICBjb25zdCB0b3RhbEJ5UGFydG5lckFuZEJyYW5jaDogUmVjb3JkPHN0cmluZywgeyB0b3RhbDogbnVtYmVyOyBpZHM6IHN0cmluZ1tdOyBicmFuY2hTeXN0ZW1JZDogc3RyaW5nOyBicmFuY2hOYW1lOiBzdHJpbmc7IHBhcnRuZXJOYW1lOiBzdHJpbmc7IHNoaXBtZW50U3lzdGVtSWRzOiBzdHJpbmdbXSB9PiA9IHt9O1xyXG4gICAgXHJcbiAgICAgICAgc2hpcG1lbnRzLmZvckVhY2goc2hpcG1lbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IGFsbE9yZGVycy5maW5kKG8gPT4gby5zeXN0ZW1JZCA9PT0gc2hpcG1lbnQub3JkZXJTeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgIGlmICghb3JkZXIgfHwgIXNoaXBtZW50LmNhcnJpZXIpIHJldHVybjtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtzaGlwbWVudC5jYXJyaWVyfS0ke2dldEJyYW5jaElkKG9yZGVyKX1gO1xyXG4gICAgICAgICAgICBpZiAoIXRvdGFsQnlQYXJ0bmVyQW5kQnJhbmNoW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsQnlQYXJ0bmVyQW5kQnJhbmNoW2tleV0gPSB7IHRvdGFsOiAwLCBpZHM6IFtdLCBicmFuY2hTeXN0ZW1JZDogZ2V0QnJhbmNoSWQob3JkZXIpLCBicmFuY2hOYW1lOiBvcmRlci5icmFuY2hOYW1lLCBwYXJ0bmVyTmFtZTogc2hpcG1lbnQuY2Fycmllciwgc2hpcG1lbnRTeXN0ZW1JZHM6IFtdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG90YWxCeVBhcnRuZXJBbmRCcmFuY2hba2V5XS50b3RhbCArPSBzaGlwbWVudC5jb2RBbW91bnQgfHwgMDtcclxuICAgICAgICAgICAgdG90YWxCeVBhcnRuZXJBbmRCcmFuY2hba2V5XS5pZHMucHVzaChzaGlwbWVudC50cmFja2luZ0NvZGUgfHwgc2hpcG1lbnQuaWQpO1xyXG4gICAgICAgICAgICB0b3RhbEJ5UGFydG5lckFuZEJyYW5jaFtrZXldLnNoaXBtZW50U3lzdGVtSWRzLnB1c2goc2hpcG1lbnQuc3lzdGVtSWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICAgICAgY29uc3QgY3JlYXRlZFJlY2VpcHRzOiAoYW55ICYgeyBzaGlwbWVudFN5c3RlbUlkczogc3RyaW5nW10gfSlbXSA9IFtdO1xyXG4gICAgXHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0b3RhbEJ5UGFydG5lckFuZEJyYW5jaCkuZm9yRWFjaChncm91cCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50cy5maW5kKGFjYyA9PiBhY2MudHlwZSA9PT0gJ2JhbmsnICYmIGFjYy5icmFuY2hTeXN0ZW1JZCA9PT0gZ3JvdXAuYnJhbmNoU3lzdGVtSWQpIHx8IGFjY291bnRzLmZpbmQoYWNjID0+IGFjYy50eXBlID09PSAnYmFuaycpO1xyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHJlY2VpcHRUeXBlcy5maW5kKGMgPT4gYy5pZCA9PT0gJ0RPSVNPQVRDT0QnKTtcclxuICAgICAgICAgICAgaWYgKGFjY291bnQgJiYgY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JlY2VpcHREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogZ3JvdXAudG90YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5ZXJUeXBlOiAnxJDhu5FpIHTDoWMgduG6rW4gY2h1eeG7g24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheWVyTmFtZTogZ3JvdXAucGFydG5lck5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGDEkOG7kWkgc2/DoXQgQ09EIGNobyBjw6FjIHbhuq1uIMSRxqFuOiAke2dyb3VwLmlkcy5qb2luKCcsICcpfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bWVudE1ldGhvZDogJ0NodXnhu4NuIGtob+G6o24nLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRTeXN0ZW1JZDogYWNjb3VudC5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbERvY3VtZW50SWQ6IGdyb3VwLmlkcy5qb2luKCcsICcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRCeTogZW1wbG95ZWU/LmZ1bGxOYW1lIHx8ICdOL0EnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaFN5c3RlbUlkOiBncm91cC5icmFuY2hTeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBicmFuY2hOYW1lOiBncm91cC5icmFuY2hOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkOiBjYXRlZ29yeS5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXltZW50UmVjZWlwdFR5cGVOYW1lOiBjYXRlZ29yeS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcgYXMgY29uc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogdG9JU09EYXRlVGltZShuZXcgRGF0ZSgpKSxcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RzRGVidDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmVjZWlwdCA9IGFkZFJlY2VpcHQobmV3UmVjZWlwdERhdGEgYXMgYW55KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdSZWNlaXB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZFJlY2VpcHRzLnB1c2goeyAuLi5uZXdSZWNlaXB0LCBzaGlwbWVudFN5c3RlbUlkczogZ3JvdXAuc2hpcG1lbnRTeXN0ZW1JZHMgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwPHN0cmluZywgeyBuZXdQYXltZW50czogT3JkZXJQYXltZW50W107IHJlY29uY2lsZWRTaGlwbWVudElkczogc3RyaW5nW10gfT4oKTtcclxuICAgIFxyXG4gICAgICAgICAgICBzaGlwbWVudHMuZm9yRWFjaChzaGlwbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0Rm9yU2hpcG1lbnQgPSBjcmVhdGVkUmVjZWlwdHMuZmluZCh2ID0+IHYuc2hpcG1lbnRTeXN0ZW1JZHMuaW5jbHVkZXMoc2hpcG1lbnQuc3lzdGVtSWQpKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdEZvclNoaXBtZW50IHx8ICFzaGlwbWVudC5jb2RBbW91bnQgfHwgc2hpcG1lbnQuY29kQW1vdW50IDw9IDApIHJldHVybjtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJTeXN0ZW1JZCA9IHNoaXBtZW50Lm9yZGVyU3lzdGVtSWQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlclVwZGF0ZXMgPSB1cGRhdGVzLmdldChvcmRlclN5c3RlbUlkKSB8fCB7IG5ld1BheW1lbnRzOiBbXSwgcmVjb25jaWxlZFNoaXBtZW50SWRzOiBbXSB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXltZW50OiBPcmRlclBheW1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3lzdGVtSWQ6IHJlY2VpcHRGb3JTaGlwbWVudC5zeXN0ZW1JZCxcclxuICAgICAgICAgICAgICAgICAgICBpZDogcmVjZWlwdEZvclNoaXBtZW50LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHJlY2VpcHRGb3JTaGlwbWVudC5kYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ8SQ4buRaSBzb8OhdCBDT0QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogc2hpcG1lbnQuY29kQW1vdW50IHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEJ5OiBhc1N5c3RlbUlkKCdTWVNURU0nKSxcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFRoYW5oIHRvw6FuIENPRCBjaG8gduG6rW4gxJHGoW4gJHtzaGlwbWVudC50cmFja2luZ0NvZGUgfHwgc2hpcG1lbnQuaWR9YCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBvcmRlclVwZGF0ZXMubmV3UGF5bWVudHMucHVzaChuZXdQYXltZW50KTtcclxuICAgICAgICAgICAgICAgIG9yZGVyVXBkYXRlcy5yZWNvbmNpbGVkU2hpcG1lbnRJZHMucHVzaChzaGlwbWVudC5zeXN0ZW1JZCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChvcmRlclN5c3RlbUlkLCBvcmRlclVwZGF0ZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICBpZiAodXBkYXRlcy5zaXplID09PSAwKSByZXR1cm4gc3RhdGU7XHJcbiAgICBcclxuICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHN0YXRlLmRhdGEubWFwKG9yZGVyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVzLmhhcyhvcmRlci5zeXN0ZW1JZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlclVwZGF0ZXMgPSB1cGRhdGVzLmdldChvcmRlci5zeXN0ZW1JZCkhO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkT3JkZXIgPSB7IC4uLm9yZGVyIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRPcmRlci5wYWNrYWdpbmdzID0gdXBkYXRlZE9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJVcGRhdGVzLnJlY29uY2lsZWRTaGlwbWVudElkcy5pbmNsdWRlcyhwLnN5c3RlbUlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IC4uLnAsIHJlY29uY2lsaWF0aW9uU3RhdHVzOiAnxJDDoyDEkeG7kWkgc2/DoXQnIGFzIGNvbnN0IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGF5bWVudCBvZiBvcmRlclVwZGF0ZXMubmV3UGF5bWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE9yZGVyID0gYXBwbHlQYXltZW50VG9PcmRlcih1cGRhdGVkT3JkZXIsIHBheW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkT3JkZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG5ld0RhdGEgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIEdIVEsgSU5URUdSQVRJT04gTUVUSE9EU1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgR0hUSyB3ZWJob29rIHVwZGF0ZVxyXG4gICAgICogQ2FsbGVkIHdoZW4gR0hUSyBwdXNoZXMgc3RhdHVzIHVwZGF0ZSBvciBmcm9tIHRyYWNraW5nIEFQSVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzR0hUS1dlYmhvb2s6ICh3ZWJob29rRGF0YTogaW1wb3J0KCcuL3R5cGVzJykuR0hUS1dlYmhvb2tQYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgYmFzZVN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcclxuICAgICAgICAgICAgLy8gRmluZCBvcmRlciBieSB0cmFja2luZyBjb2RlIG9yIHBhcnRuZXJfaWRcclxuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBzdGF0ZS5kYXRhLmZpbmQobyA9PiBcclxuICAgICAgICAgICAgICAgIG8ucGFja2FnaW5ncy5zb21lKHAgPT4gXHJcbiAgICAgICAgICAgICAgICAgICAgcC50cmFja2luZ0NvZGUgPT09IHdlYmhvb2tEYXRhLmxhYmVsX2lkIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgIHAuc3lzdGVtSWQgPT09IHdlYmhvb2tEYXRhLnBhcnRuZXJfaWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBvLnN5c3RlbUlkID09PSB3ZWJob29rRGF0YS5wYXJ0bmVyX2lkXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIW9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tHSFRLIFdlYmhvb2tdIE9yZGVyIG5vdCBmb3VuZCBmb3I6Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsX2lkOiB3ZWJob29rRGF0YS5sYWJlbF9pZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0bmVyX2lkOiB3ZWJob29rRGF0YS5wYXJ0bmVyX2lkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSW1wb3J0IHN0YXR1cyBtYXBwaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0R0hUS1N0YXR1c0luZm8sIGdldEdIVEtSZWFzb25UZXh0IH0gPSByZXF1aXJlKCcuLi8uLi9saWIvZ2h0ay1jb25zdGFudHMnKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c01hcHBpbmcgPSBnZXRHSFRLU3RhdHVzSW5mbyh3ZWJob29rRGF0YS5zdGF0dXNfaWQpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXR1c01hcHBpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0dIVEsgV2ViaG9va10gVW5rbm93biBzdGF0dXM6Jywgd2ViaG9va0RhdGEuc3RhdHVzX2lkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHSFRLIFdlYmhvb2tdIFByb2Nlc3NpbmcgdXBkYXRlOicsIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyOiBvcmRlci5pZCxcclxuICAgICAgICAgICAgICAgIHRyYWNraW5nQ29kZTogd2ViaG9va0RhdGEubGFiZWxfaWQsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXNJZDogd2ViaG9va0RhdGEuc3RhdHVzX2lkLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzTWFwcGluZy5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6IHN0YXR1c01hcHBpbmcuZGVsaXZlcnlTdGF0dXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGFja2FnaW5nIHdpdGggbmV3IHN0YXR1c1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAudHJhY2tpbmdDb2RlICE9PSB3ZWJob29rRGF0YS5sYWJlbF9pZCAmJiBcclxuICAgICAgICAgICAgICAgICAgICBwLnN5c3RlbUlkICE9PSB3ZWJob29rRGF0YS5wYXJ0bmVyX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeVN0YXR1czogc3RhdHVzTWFwcGluZy5kZWxpdmVyeVN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0bmVyU3RhdHVzOiBzdGF0dXNNYXBwaW5nLnN0YXR1c1RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2h0a1N0YXR1c0lkOiB3ZWJob29rRGF0YS5zdGF0dXNfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2h0a1JlYXNvbkNvZGU6IHdlYmhvb2tEYXRhLnJlYXNvbl9jb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGdodGtSZWFzb25UZXh0OiB3ZWJob29rRGF0YS5yZWFzb24gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2ViaG9va0RhdGEucmVhc29uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh3ZWJob29rRGF0YS5yZWFzb25fY29kZSA/IGdldEdIVEtSZWFzb25UZXh0KHdlYmhvb2tEYXRhLnJlYXNvbl9jb2RlKSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsV2VpZ2h0OiB3ZWJob29rRGF0YS53ZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRmVlOiB3ZWJob29rRGF0YS5mZWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN5bmNlZEF0OiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByZWNvbmNpbGlhdGlvbiBzdGF0dXMgaWYgc3RhdHVzID0gNiAoxJDDoyDEkeG7kWkgc2/DoXQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb25jaWxpYXRpb25TdGF0dXM6IHdlYmhvb2tEYXRhLnN0YXR1c19pZCA9PT0gNiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnxJDDoyDEkeG7kWkgc2/DoXQnIGFzIGNvbnN0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAucmVjb25jaWxpYXRpb25TdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGRlbGl2ZXJlZCBkYXRlIGlmIHN0YXR1cyA9IDUgb3IgNlxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJlZERhdGU6IFs1LCA2XS5pbmNsdWRlcyh3ZWJob29rRGF0YS5zdGF0dXNfaWQpICYmICFwLmRlbGl2ZXJlZERhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC5kZWxpdmVyZWREYXRlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc3RvY2sgdXBkYXRlcyBiYXNlZCBvbiBzdGF0dXNcclxuICAgICAgICAgICAgaWYgKHN0YXR1c01hcHBpbmcuc2hvdWxkVXBkYXRlU3RvY2sgJiYgc3RhdHVzTWFwcGluZy5zdG9ja0FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkaXNwYXRjaFN0b2NrLCBjb21wbGV0ZURlbGl2ZXJ5OiBwcm9kdWN0Q29tcGxldGVEZWxpdmVyeSwgcmV0dXJuU3RvY2tGcm9tVHJhbnNpdCB9ID0gdXNlUHJvZHVjdFN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluY3JlbWVudEZhaWxlZERlbGl2ZXJ5U3RhdHMgfSA9IHVzZUN1c3RvbWVyU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8g4pyFIEV4cGFuZCBjb21ibyBpdGVtcyB0byBjaGlsZCBwcm9kdWN0c1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvY2tJdGVtcyA9IGdldENvbWJvU3RvY2tJdGVtcyhvcmRlci5saW5lSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzdG9ja0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0dXNNYXBwaW5nLnN0b2NrQWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc3BhdGNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cyAzOiDEkMOjIGzhuqV5IGjDoG5nIC0+IE1vdmUgdG8gdHJhbnNpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hTdG9jayhpdGVtLnByb2R1Y3RTeXN0ZW1JZCwgYXNTeXN0ZW1JZChnZXRCcmFuY2hJZChvcmRlcikpLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMgNTogxJDDoyBnaWFvIGjDoG5nIC0+IENvbXBsZXRlIGRlbGl2ZXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0Q29tcGxldGVEZWxpdmVyeShpdGVtLnByb2R1Y3RTeXN0ZW1JZCwgYXNTeXN0ZW1JZChnZXRCcmFuY2hJZChvcmRlcikpLCBpdGVtLnF1YW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhdHVzIC0xLCA3LCA5LCAxMywgMjA6IEZhaWxlZC9SZXR1cm5lZCAtPiBSZXR1cm4gc3RvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblN0b2NrRnJvbVRyYW5zaXQoaXRlbS5wcm9kdWN0U3lzdGVtSWQsIGFzU3lzdGVtSWQoZ2V0QnJhbmNoSWQob3JkZXIpKSwgaXRlbS5xdWFudGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8g4pyFIEluY3JlbWVudCBmYWlsZWQgZGVsaXZlcnkgc3RhdHMgZm9yIGN1c3RvbWVyIGlmIHJldHVybiAobW92ZWQgb3V0c2lkZSBsb29wKVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c01hcHBpbmcuc3RvY2tBY3Rpb24gPT09ICdyZXR1cm4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFpbHVyZVN0YXR1c2VzID0gWzcsIDksIDEzLCAyMCwgMjFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYWNrYWdpbmcgPSBvcmRlci5wYWNrYWdpbmdzLmZpbmQocCA9PiBwLnRyYWNraW5nQ29kZSA9PT0gd2ViaG9va0RhdGEubGFiZWxfaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdHVzSWQgPSBjdXJyZW50UGFja2FnaW5nPy5naHRrU3RhdHVzSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWx1cmVTdGF0dXNlcy5pbmNsdWRlcyh3ZWJob29rRGF0YS5zdGF0dXNfaWQpICYmICghcHJldmlvdXNTdGF0dXNJZCB8fCAhZmFpbHVyZVN0YXR1c2VzLmluY2x1ZGVzKHByZXZpb3VzU3RhdHVzSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRGYWlsZWREZWxpdmVyeVN0YXRzKG9yZGVyLmN1c3RvbWVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHSFRLIFdlYmhvb2tdIFN0b2NrIHVwZGF0ZWQ6Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogc3RhdHVzTWFwcGluZy5zdG9ja0FjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBpdGVtczogc3RvY2tJdGVtcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgb3JkZXItbGV2ZWwgZGVsaXZlcnkgc3RhdHVzXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFBhY2thZ2luZ3NEZWxpdmVyZWQgPSB1cGRhdGVkUGFja2FnaW5ncy5ldmVyeShwID0+IFxyXG4gICAgICAgICAgICAgICAgcC5zdGF0dXMgPT09ICdI4buneSDEkcOzbmcgZ8OzaScgfHwgXHJcbiAgICAgICAgICAgICAgICBwLmRlbGl2ZXJ5U3RhdHVzID09PSAnxJDDoyBnaWFvIGjDoG5nJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IG5ld09yZGVyRGVsaXZlcnlTdGF0dXMgPSBvcmRlci5kZWxpdmVyeVN0YXR1cztcclxuICAgICAgICAgICAgbGV0IG5ld09yZGVyU3RhdHVzID0gb3JkZXIuc3RhdHVzO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q29tcGxldGVkRGF0ZSA9IG9yZGVyLmNvbXBsZXRlZERhdGU7XHJcbiAgICAgICAgICAgIGxldCBuZXdTdG9ja091dFN0YXR1cyA9IG9yZGVyLnN0b2NrT3V0U3RhdHVzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVXBkYXRlIG9yZGVyIGRlbGl2ZXJ5IHN0YXR1c1xyXG4gICAgICAgICAgICBpZiAoYWxsUGFja2FnaW5nc0RlbGl2ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbmV3T3JkZXJEZWxpdmVyeVN0YXR1cyA9ICfEkMOjIGdpYW8gaMOgbmcnO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBBdXRvLWNvbXBsZXRlIG9yZGVyIGlmIGRlbGl2ZXJlZCArIHBhaWRcclxuICAgICAgICAgICAgICAgIGlmIChvcmRlci5wYXltZW50U3RhdHVzID09PSAnVGhhbmggdG/DoW4gdG/DoG4gYuG7mScgJiYgb3JkZXIuc3RhdHVzICE9PSAnSG/DoG4gdGjDoG5oJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld09yZGVyU3RhdHVzID0gJ0hvw6BuIHRow6BuaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tcGxldGVkRGF0ZSA9IHRvSVNPRGF0ZVRpbWUobmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGN1c3RvbWVyIHN0YXRzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpbmNyZW1lbnRPcmRlclN0YXRzIH0gPSB1c2VDdXN0b21lclN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T3JkZXJTdGF0cyhvcmRlci5jdXN0b21lclN5c3RlbUlkLCBvcmRlci5ncmFuZFRvdGFsKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0dIVEsgV2ViaG9va10gT3JkZXIgY29tcGxldGVkOicsIG9yZGVyLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXNNYXBwaW5nLnN0YXR1c0lkID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMgMzogxJDDoyBs4bqleSBow6BuZ1xyXG4gICAgICAgICAgICAgICAgbmV3T3JkZXJEZWxpdmVyeVN0YXR1cyA9ICfEkGFuZyBnaWFvIGjDoG5nJztcclxuICAgICAgICAgICAgICAgIG5ld1N0b2NrT3V0U3RhdHVzID0gJ1h14bqldCBraG8gdG/DoG4gYuG7mSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoWzQsIDEwXS5pbmNsdWRlcyhzdGF0dXNNYXBwaW5nLnN0YXR1c0lkKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzIDQsIDEwOiDEkGFuZyBnaWFvXHJcbiAgICAgICAgICAgICAgICBuZXdPcmRlckRlbGl2ZXJ5U3RhdHVzID0gJ8SQYW5nIGdpYW8gaMOgbmcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5vcmRlcixcclxuICAgICAgICAgICAgICAgIHBhY2thZ2luZ3M6IHVwZGF0ZWRQYWNrYWdpbmdzLFxyXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6IG5ld09yZGVyRGVsaXZlcnlTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG5ld09yZGVyU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVkRGF0ZTogbmV3Q29tcGxldGVkRGF0ZSxcclxuICAgICAgICAgICAgICAgIHN0b2NrT3V0U3RhdHVzOiBuZXdTdG9ja091dFN0YXR1cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLm1hcChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyLnN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgR0hUSyBzaGlwbWVudFxyXG4gICAgICog4pqg77iPIENo4buJIGjhu6d5IMSRxrDhu6NjIGtoaSDEkcahbiDhu58gdHLhuqFuZyB0aMOhaTogMSwgMiwgMTIgKENoxrBhIHRp4bq/cCBuaOG6rW4sIMSQw6MgdGnhur9wIG5o4bqtbiwgxJBhbmcgbOG6pXkgaMOgbmcpXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbEdIVEtTaGlwbWVudDogYXN5bmMgKG9yZGVyU3lzdGVtSWQ6IFN5c3RlbUlkLCBwYWNrYWdpbmdTeXN0ZW1JZDogU3lzdGVtSWQsIHRyYWNraW5nQ29kZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHSFRLXSBDYW5jZWxsaW5nIHNoaXBtZW50OicsIHRyYWNraW5nQ29kZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgTOG6pXkgY3JlZGVudGlhbHMgdOG7qyBzaGlwcGluZ19wYXJ0bmVyc19jb25maWdcclxuICAgICAgICAgICAgY29uc3QgeyBnZXRHSFRLQ3JlZGVudGlhbHMgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vbGliL3V0aWxzL2dldC1zaGlwcGluZy1jcmVkZW50aWFscycpO1xyXG4gICAgICAgICAgICBsZXQgY3JlZGVudGlhbHM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHMgPSBnZXRHSFRLQ3JlZGVudGlhbHMoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdDaMawYSBj4bqldSBow6xuaCBHSFRLLiBWdWkgbMOybmcgdsOgbyBDw6BpIMSR4bq3dCDihpIgxJDhu5FpIHTDoWMgduG6rW4gY2h1eeG7g24uJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChnZXRBcGlVcmwoJy9zaGlwcGluZy9naHRrL2NhbmNlbC1vcmRlcicpLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0NvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXBpVG9rZW46IGNyZWRlbnRpYWxzLmFwaVRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRuZXJDb2RlOiBjcmVkZW50aWFscy5wYXJ0bmVyQ29kZSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDinIUgS2nhu4NtIHRyYSByZXNwb25zZSB04burIEdIVEtcclxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCBkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gY2FuY2VsIEdIVEsgc2hpcG1lbnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8g4pyFIEdIVEsgdHLhuqMgc3VjY2VzczogZmFsc2Uga2hpIGtow7RuZyB0aOG7gyBo4buneSAoxJHDoyBs4bqleSBow6BuZylcclxuICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR0hUS10gQ2Fubm90IGNhbmNlbDonLCBkYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSB8fCAnS2jDtG5nIHRo4buDIGjhu6d5IMSRxqFuIGjDoG5nJyBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR0hUS10gQ2FuY2VsbGF0aW9uIHN1Y2Nlc3NmdWw6JywgZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIOKchSBDSOG7iCB1cGRhdGUgc3RhdGUga2hpIEdIVEsgeMOhYyBuaOG6rW4gaOG7p3kgdGjDoG5oIGPDtG5nXHJcbiAgICAgICAgICAgIGJhc2VTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlciA9IHN0YXRlLmRhdGEuZmluZChvID0+IG8uc3lzdGVtSWQgPT09IG9yZGVyU3lzdGVtSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcmRlcikgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFja2FnaW5ncyA9IG9yZGVyLnBhY2thZ2luZ3MubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnN5c3RlbUlkICE9PSBwYWNrYWdpbmdTeXN0ZW1JZCkgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnSOG7p3kgxJHDs25nIGfDs2knIGFzIFBhY2thZ2luZ1N0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaXZlcnlTdGF0dXM6ICfEkMOjIGjhu6d5JyBhcyBPcmRlckRlbGl2ZXJ5U3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxEYXRlOiB0b0lTT0RhdGVUaW1lKG5ldyBEYXRlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxSZWFzb246ICdI4buneSB24bqtbiDEkcahbiBHSFRLJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2h0a1N0YXR1c0lkOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydG5lclN0YXR1czogJ0jhu6d5IMSRxqFuIGjDoG5nJyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIOKchSBLSMOUTkcgcm9sbGJhY2sgc3RvY2sgLSDEkeG7gyB1c2VyIHThu7EgcXV54bq/dCDEkeG7i25oIChuw7p0IFwiSOG7p3kgZ2lhbyB2w6Agbmjhuq1uIGzhuqFpIGjDoG5nXCIpXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcmRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5vcmRlcixcclxuICAgICAgICAgICAgICAgICAgICBwYWNrYWdpbmdzOiB1cGRhdGVkUGFja2FnaW5ncyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAobyA9PiBvLnN5c3RlbUlkID09PSBvcmRlclN5c3RlbUlkID8gdXBkYXRlZE9yZGVyIDogbylcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSB8fCAnxJDDoyBo4buneSB24bqtbiDEkcahbiBHSFRLIHRow6BuaCBjw7RuZycgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0dIVEtdIENhbmNlbCBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IFxyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCAnTOG7l2kga2hpIGjhu6d5IHbhuq1uIMSRxqFuIEdIVEsnIFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07XHJcblxyXG4vLyBBdXRvLWFsbG9jYXRlIGhpc3RvcmljYWwgcmVjZWlwdHMgb24gc3RhcnR1cFxyXG51c2VSZWNlaXB0U3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZvckVhY2gocmVjZWlwdCA9PiB7XHJcbiAgICBhdXRvQWxsb2NhdGVSZWNlaXB0VG9PcmRlcnMocmVjZWlwdCk7XHJcbn0pO1xyXG5cclxuLy8gUmVhY3QgdG8gbmV3bHkgY3JlYXRlZCByZWNlaXB0c1xyXG51c2VSZWNlaXB0U3RvcmUuc3Vic2NyaWJlKFxyXG4gICAgc3RhdGUgPT4gc3RhdGUuZGF0YSxcclxuICAgIChjdXJyZW50UmVjZWlwdHMsIHByZXZpb3VzUmVjZWlwdHMpID0+IHtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0lkcyA9IG5ldyBTZXQoKHByZXZpb3VzUmVjZWlwdHMgPz8gW10pLm1hcChyID0+IHIuc3lzdGVtSWQpKTtcclxuICAgICAgICBjdXJyZW50UmVjZWlwdHMuZm9yRWFjaChyZWNlaXB0ID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwcmV2aW91c0lkcy5oYXMocmVjZWlwdC5zeXN0ZW1JZCkpIHtcclxuICAgICAgICAgICAgICAgIGF1dG9BbGxvY2F0ZVJlY2VpcHRUb09yZGVycyhyZWNlaXB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4pO1xyXG5cclxuXHJcbi8vIEV4cG9ydCB0eXBlZCBob29rIHdpdGggYWxsIGF1Z21lbnRlZCBtZXRob2RzXHJcbmV4cG9ydCBjb25zdCB1c2VPcmRlclN0b3JlID0gKCk6IGFueSA9PiB7XHJcbiAgY29uc3Qgc3RhdGUgPSBiYXNlU3RvcmUoKTtcclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICAuLi5hdWdtZW50ZWRNZXRob2RzLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBFeHBvcnQgZ2V0U3RhdGUgZm9yIG5vbi1ob29rIHVzYWdlXHJcbnVzZU9yZGVyU3RvcmUuZ2V0U3RhdGUgPSAoKTogYW55ID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IGJhc2VTdG9yZS5nZXRTdGF0ZSgpO1xyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIC4uLmF1Z21lbnRlZE1ldGhvZHMsXHJcbiAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbInRvSVNPRGF0ZVRpbWUiLCJnZXRBcGlVcmwiLCJjcmVhdGVDcnVkU3RvcmUiLCJhc1N5c3RlbUlkIiwiYXNCdXNpbmVzc0lkIiwiZ2VuZXJhdGVTeXN0ZW1JZCIsImdldE1heFN5c3RlbUlkQ291bnRlciIsInVzZUVtcGxveWVlU3RvcmUiLCJ1c2VQcm9kdWN0U3RvcmUiLCJpc0NvbWJvUHJvZHVjdCIsInVzZVN0b2NrSGlzdG9yeVN0b3JlIiwidXNlQ3VzdG9tZXJTdG9yZSIsInVzZVJlY2VpcHRUeXBlU3RvcmUiLCJ1c2VDYXNoYm9va1N0b3JlIiwidXNlUmVjZWlwdFN0b3JlIiwidXNlU2FsZXNSZXR1cm5TdG9yZSIsImNyZWF0ZVBheW1lbnREb2N1bWVudCIsImNyZWF0ZVJlY2VpcHREb2N1bWVudCIsInVzZVNoaXBtZW50U3RvcmUiLCJnZXRDdXJyZW50VXNlclN5c3RlbUlkIiwidXNlU2FsZXNNYW5hZ2VtZW50U2V0dGluZ3NTdG9yZSIsImdldEN1cnJlbnRVc2VySW5mbyIsImNyZWF0ZUNyZWF0ZWRFbnRyeSIsImNyZWF0ZUhpc3RvcnlFbnRyeSIsImFwcGVuZEhpc3RvcnlFbnRyeSIsImdldEJyYW5jaElkIiwib3JkZXIiLCJicmFuY2hTeXN0ZW1JZCIsImRlbGl2ZXJ5U3RhdHVzZXNCbG9ja2VkRm9yQ2FuY2VsbGF0aW9uIiwiSU5fU1RPUkVfUElDS1VQX1BSRUZJWCIsIlBBQ0tBR0lOR19DT0RFX1BSRUZJWCIsIlBBQ0tBR0lOR19TWVNURU1fSURfUFJFRklYIiwicGFja2FnaW5nU3lzdGVtSWRDb3VudGVyIiwiaW5pdFBhY2thZ2luZ0NvdW50ZXIiLCJvcmRlcnMiLCJhbGxQYWNrYWdpbmdzIiwiZmxhdE1hcCIsIm8iLCJwYWNrYWdpbmdzIiwiZ2V0TmV4dFBhY2thZ2luZ1N5c3RlbUlkIiwiZ2V0UGFja2FnaW5nU3VmZml4RnJvbU9yZGVySWQiLCJvcmRlcklkIiwicmF3VmFsdWUiLCJzdWZmaXgiLCJyZXBsYWNlIiwiZ2V0QWN0aXZlUGFja2FnaW5nQ291bnQiLCJmaWx0ZXIiLCJwIiwic3RhdHVzIiwibGVuZ3RoIiwiYnVpbGRQYWNrYWdpbmdCdXNpbmVzc0lkIiwiYWN0aXZlSW5kZXgiLCJhY3RpdmVDb3VudCIsImJhc2VDb2RlIiwicGFkZGVkSW5kZXgiLCJTdHJpbmciLCJwYWRTdGFydCIsImdldFJldHVybmVkVmFsdWVGb3JPcmRlciIsIm9yZGVyU3lzdGVtSWQiLCJnZXRTdGF0ZSIsImRhdGEiLCJzciIsInJlZHVjZSIsInN1bSIsInRvdGFsUmV0dXJuVmFsdWUiLCJjYWxjdWxhdGVBY3R1YWxEZWJ0IiwidG90YWxSZXR1cm5lZFZhbHVlIiwic3lzdGVtSWQiLCJNYXRoIiwibWF4IiwiZ3JhbmRUb3RhbCIsImNhbGN1bGF0ZVRvdGFsUGFpZCIsInBheW1lbnRzIiwicGF5bWVudCIsImFtb3VudCIsImdldE9yZGVyT3V0c3RhbmRpbmdBbW91bnQiLCJhY3R1YWxEZWJ0IiwidG90YWxQYWlkIiwiYXBwbHlQYXltZW50VG9PcmRlciIsInVwZGF0ZWRQYXltZW50cyIsIm5ld1BheW1lbnRTdGF0dXMiLCJ3YXNDb21wbGV0ZWQiLCJuZXdTdGF0dXMiLCJuZXdDb21wbGV0ZWREYXRlIiwiY29tcGxldGVkRGF0ZSIsImRlbGl2ZXJ5U3RhdHVzIiwiRGF0ZSIsImluY3JlbWVudE9yZGVyU3RhdHMiLCJjdXN0b21lclN5c3RlbUlkIiwidXBkYXRlRGVidFRyYW5zYWN0aW9uUGF5bWVudCIsImlkIiwicGF5bWVudFN0YXR1cyIsInBhaWRBbW91bnQiLCJzaG91bGRBdXRvQWxsb2NhdGVSZWNlaXB0IiwicmVjZWlwdCIsImFmZmVjdHNEZWJ0IiwibGlua2VkT3JkZXJTeXN0ZW1JZCIsImdldEFsbG9jYXRlZEFtb3VudCIsIm9yZGVyQWxsb2NhdGlvbnMiLCJhbGxvY2F0aW9uIiwiYXV0b0FsbG9jYXRlUmVjZWlwdFRvT3JkZXJzIiwicmVtYWluaW5nQW1vdW50IiwiY2FuZGlkYXRlT3JkZXJzIiwiYmFzZVN0b3JlIiwibWFwIiwib3V0c3RhbmRpbmciLCJlbnRyeSIsInNvcnQiLCJhIiwiYiIsImFUaW1lIiwib3JkZXJEYXRlIiwiZ2V0VGltZSIsImJUaW1lIiwiYW1vdW50VG9EaXN0cmlidXRlIiwidXBkYXRlZE9yZGVycyIsIk1hcCIsImFsbG9jYXRpb25FbnRyaWVzIiwiY3VycmVudE9yZGVyU3RhdGUiLCJnZXQiLCJhbGxvY2F0aW9uQW1vdW50IiwibWluIiwicGF5bWVudEVudHJ5IiwiZGF0ZSIsIm1ldGhvZCIsInBheW1lbnRNZXRob2ROYW1lIiwiY3JlYXRlZEJ5IiwiZGVzY3JpcHRpb24iLCJ1cGRhdGVkT3JkZXIiLCJzZXQiLCJwdXNoIiwic2V0U3RhdGUiLCJzdGF0ZSIsInJlY2VpcHRTdG9yZSIsImxhdGVzdFJlY2VpcHQiLCJmaW5kQnlJZCIsInVwZGF0ZSIsImVuc3VyZU9yZGVyUGFja2FnaW5nSWRlbnRpZmllcnMiLCJhY3RpdmVQYWNrYWdpbmdzIiwiY2hhbmdlZCIsInVwZGF0ZWRQYWNrYWdpbmdzIiwicGtnIiwiaWR4IiwiaXNDYW5jZWxsZWQiLCJoYXNJZCIsInRyaW0iLCJoYXNUZW1wT3JPbGRTeXN0ZW1JZCIsInN0YXJ0c1dpdGgiLCJoYXNWYWxpZFN5c3RlbUlkIiwic2hvdWxkRml4VHJhY2tpbmciLCJkZWxpdmVyeU1ldGhvZCIsInRyYWNraW5nQ29kZSIsIm5leHRQa2ciLCJjdXJyZW50QWN0aXZlSW5kZXgiLCJyZXNvbHZlZElkIiwiZW5zdXJlQ2FuY2VsbGF0aW9uQWxsb3dlZCIsImFjdGlvbkxhYmVsIiwiYWxsb3dDYW5jZWxBZnRlckV4cG9ydCIsImhhc0xlZnRXYXJlaG91c2UiLCJzdG9ja091dFN0YXR1cyIsImluY2x1ZGVzIiwiYWxlcnQiLCJwcm9jZXNzTGluZUl0ZW1TdG9jayIsImxpbmVJdGVtIiwib3BlcmF0aW9uIiwib3JkZXJRdWFudGl0eSIsImZpbmRQcm9kdWN0QnlJZCIsImNvbW1pdFN0b2NrIiwidW5jb21taXRTdG9jayIsImRpc3BhdGNoU3RvY2siLCJjb21wbGV0ZURlbGl2ZXJ5IiwicmV0dXJuU3RvY2tGcm9tVHJhbnNpdCIsInByb2R1Y3QiLCJwcm9kdWN0U3lzdGVtSWQiLCJpdGVtc1RvUHJvY2VzcyIsImNvbWJvSXRlbXMiLCJmb3JFYWNoIiwiY29tYm9JdGVtIiwicXVhbnRpdHkiLCJpdGVtIiwiYnJhbmNoSWQiLCJnZXRDb21ib1N0b2NrSXRlbXMiLCJsaW5lSXRlbXMiLCJzdG9ja0l0ZW1zIiwiY3JlYXRlT3JkZXJSZWZ1bmRWb3VjaGVyIiwiZW1wbG95ZWVJZCIsImxhc3RQb3NpdGl2ZVBheW1lbnQiLCJyZXZlcnNlIiwiZmluZCIsImRvY3VtZW50IiwiZXJyb3IiLCJyZWNpcGllbnROYW1lIiwiY3VzdG9tZXJOYW1lIiwicmVjaXBpZW50U3lzdGVtSWQiLCJicmFuY2hOYW1lIiwicGF5bWVudFR5cGVOYW1lIiwib3JpZ2luYWxEb2N1bWVudElkIiwiY2F0ZWdvcnkiLCJjb25zb2xlIiwiaW5pdGlhbERhdGEiLCJidXNpbmVzc0lkRmllbGQiLCJhcGlFbmRwb2ludCIsImdldEN1cnJlbnRVc2VyIiwiQVBJX0VORFBPSU5UIiwic3luY1RvQXBpIiwiY3JlYXRlIiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJ3YXJuIiwibG9nIiwiZSIsInVwZGF0ZXMiLCJkZWxldGUiLCJoYXJkIiwicmVzdG9yZSIsIm9yaWdpbmFsQWRkIiwiYWRkIiwib3JpZ2luYWxVcGRhdGUiLCJvcmlnaW5hbFJlbW92ZSIsInJlbW92ZSIsIm9yaWdpbmFsSGFyZERlbGV0ZSIsImhhcmREZWxldGUiLCJvcmlnaW5hbFJlc3RvcmUiLCJyZXN1bHQiLCJleGlzdGluZ0lkcyIsIlNldCIsIm5ld09yZGVycyIsImhhcyIsImlzQWxsRGVsaXZlcmVkIiwiZXZlcnkiLCJvcmlnaW5hbEFkZFdpdGhTdG9jayIsInVzZXJJbmZvIiwibmV3SXRlbSIsImh5ZHJhdGVkUGFja2FnaW5ncyIsIk9iamVjdCIsImFzc2lnbiIsImxpIiwidG90YWxRdWFudGl0eSIsInVwZGF0ZUN1c3RvbWVyIiwiZmluZEN1c3RvbWVyIiwiY3VzdG9tZXIiLCJsYXN0UHVyY2hhc2VEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImhpc3RvcnlFbnRyeSIsIm5hbWUiLCJ0b0xvY2FsZVN0cmluZyIsImFjdGl2aXR5SGlzdG9yeSIsImJhY2tmaWxsUGFja2FnaW5nSWRlbnRpZmllcnMiLCJjdXJyZW50U3RhdGUiLCJ1cGRhdGVkRGF0YSIsImF1Z21lbnRlZE1ldGhvZHMiLCJjYW5jZWxPcmRlciIsIm9wdGlvbnMiLCJyZWFzb24iLCJyZXN0b2NrIiwiY3VycmVudE9yZGVyIiwib3JkZXJUb0NhbmNlbCIsImVtcGxveWVlIiwibm93IiwiY2FuY2VsbGF0aW9uUmVhc29uIiwiZnVsbE5hbWUiLCJoYXNEaXNwYXRjaGVkU3RvY2siLCJleGlzdGluZ1BheW1lbnRzIiwibmV0Q29sbGVjdGVkIiwicmVmdW5kUGF5bWVudEVudHJ5IiwicmVmdW5kQW1vdW50IiwicmVmdW5kVm91Y2hlciIsInVwZGF0ZWRQYWlkQW1vdW50IiwiY2FuY2VsRGF0ZSIsImNhbmNlbFJlYXNvbiIsImNhbmNlbGluZ0VtcGxveWVlSWQiLCJjYW5jZWxpbmdFbXBsb3llZU5hbWUiLCJjYW5jZWxsZWREYXRlIiwiY2FuY2VsbGF0aW9uTWV0YWRhdGEiLCJyZXN0b2NrSXRlbXMiLCJub3RpZnlDdXN0b21lciIsImVtYWlsTm90aWZpZWRBdCIsInVuZGVmaW5lZCIsInJlbW92ZURlYnRUcmFuc2FjdGlvbiIsImFkZFBheW1lbnQiLCJwYXltZW50RGF0YSIsImNyZWF0ZWRSZWNlaXB0IiwicmVjZWlwdFR5cGVOYW1lIiwib3JkZXJJbmRleCIsImZpbmRJbmRleCIsIm9yZGVyVG9VcGRhdGUiLCJuZXdQYXltZW50IiwibmV3RGF0YSIsInJlcXVlc3RQYWNrYWdpbmciLCJhc3NpZ25lZEVtcGxveWVlSWQiLCJhc3NpZ25lZEVtcGxveWVlIiwiYWN0aXZlQ291bnRBZnRlckluc2VydCIsIm5ld0FjdGl2ZUluZGV4IiwibmV3UGFja2FnaW5nIiwicmVxdWVzdERhdGUiLCJyZXF1ZXN0aW5nRW1wbG95ZWVJZCIsInJlcXVlc3RpbmdFbXBsb3llZU5hbWUiLCJhc3NpZ25lZEVtcGxveWVlTmFtZSIsInByaW50U3RhdHVzIiwiY29uZmlybVBhY2thZ2luZyIsInBhY2thZ2luZ1N5c3RlbUlkIiwiYWxsb3dOZWdhdGl2ZVBhY2tpbmciLCJjaGlsZFByb2R1Y3QiLCJyZXF1aXJlZFF0eSIsImN1cnJlbnRTdG9jayIsImludmVudG9yeUJ5QnJhbmNoIiwicHJvZHVjdE5hbWUiLCJkYXRhQ29weSIsIm9yZGVyQ29weSIsInBhY2thZ2luZ0luZGV4IiwicGFja2FnaW5nc0NvcHkiLCJjb25maXJtRGF0ZSIsImNvbmZpcm1pbmdFbXBsb3llZUlkIiwiY29uZmlybWluZ0VtcGxveWVlTmFtZSIsImNhbmNlbFBhY2thZ2luZ1JlcXVlc3QiLCJpc0FueUFjdGl2ZVBhY2thZ2luZyIsInNvbWUiLCJwcm9jZXNzSW5TdG9yZVBpY2t1cCIsInRvdGFsQ291bnQiLCJpbmRleCIsImNvbmZpcm1JblN0b3JlUGlja3VwIiwiYWxsb3dOZWdhdGl2ZVN0b2NrT3V0IiwiYWRkRW50cnkiLCJhZGRTdG9ja0hpc3RvcnkiLCJlbXBsb3llZURhdGEiLCJwcm9jZXNzZWRJdGVtcyIsInByb2Nlc3NlZEl0ZW0iLCJwcm9kdWN0SWQiLCJhY3Rpb24iLCJxdWFudGl0eUNoYW5nZSIsIm5ld1N0b2NrTGV2ZWwiLCJkb2N1bWVudElkIiwiYnJhbmNoIiwiZW1wbG95ZWVOYW1lIiwiZGVsaXZlcmVkRGF0ZSIsInBhY2thZ2luZyIsIm5ld1NoaXBtZW50IiwiY3JlYXRlU2hpcG1lbnQiLCJ1cGRhdGVTaGlwbWVudCIsImNhcnJpZXIiLCJzZXJ2aWNlIiwicmVjb25jaWxpYXRpb25TdGF0dXMiLCJzaGlwcGluZ0ZlZVRvUGFydG5lciIsImNvZEFtb3VudCIsInBheWVyIiwiY3JlYXRlZEF0IiwiZGlzcGF0Y2hlZEF0IiwiZGVsaXZlcmVkQXQiLCJkaXNwYXRjaGVkRGF0ZSIsImRpc3BhdGNoZWRCeUVtcGxveWVlSWQiLCJkaXNwYXRjaGVkQnlFbXBsb3llZU5hbWUiLCJjb25maXJtUGFydG5lclNoaXBtZW50Iiwic2hpcG1lbnREYXRhIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJnaHRrUGFyYW1zIiwid2luZG93IiwiX19naHRrUHJldmlld1BhcmFtcyIsIkdIVEtTZXJ2aWNlIiwiZ2V0R0hUS0NyZWRlbnRpYWxzIiwiYXBpVG9rZW4iLCJwYXJ0bmVyQ29kZSIsImdodGtTZXJ2aWNlIiwiY3JlYXRlT3JkZXIiLCJFcnJvciIsImxhYmVsIiwiZ2h0a1RyYWNraW5nSWQiLCJ0cmFja2luZ19pZCIsImVzdGltYXRlZFBpY2tUaW1lIiwiZXN0aW1hdGVkX3BpY2tfdGltZSIsImVzdGltYXRlZERlbGl2ZXJUaW1lIiwiZXN0aW1hdGVkX2RlbGl2ZXJfdGltZSIsImZlZSIsInBhcnNlSW50IiwicGlja19tb25leSIsImlzX2ZyZWVzaGlwIiwibm90ZVRvU2hpcHBlciIsIm5vdGUiLCJ3ZWlnaHQiLCJkaW1lbnNpb25zIiwicHJvZHVjdHMiLCJ3aWR0aCIsImhlaWdodCIsImVycm9yTWVzc2FnZSIsImRpc3BhdGNoRnJvbVdhcmVob3VzZSIsIm5vdzIiLCJkZWJ0QW1vdW50IiwiYWRkRGVidFRyYW5zYWN0aW9uIiwiZHVlRGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwiaXNQYWlkIiwibm90ZXMiLCJmYWlsRGVsaXZlcnkiLCJpbmNyZW1lbnRGYWlsZWREZWxpdmVyeVN0YXRzIiwiY2FuY2VsRGVsaXZlcnlPbmx5IiwiYWxsQ2FuY2VsbGVkIiwiaGFzQW55QWN0aXZlIiwibmV3T3JkZXJTdGF0dXMiLCJuZXdEZWxpdmVyeVN0YXR1cyIsImFjdGl2ZVBhY2thZ2luZyIsImNhbmNlbERlbGl2ZXJ5IiwiY29uZmlybUNvZFJlY29uY2lsaWF0aW9uIiwic2hpcG1lbnRzIiwiYWRkUmVjZWlwdCIsImFjY291bnRzIiwicmVjZWlwdFR5cGVzIiwiYWxsT3JkZXJzIiwidG90YWxCeVBhcnRuZXJBbmRCcmFuY2giLCJzaGlwbWVudCIsImtleSIsInRvdGFsIiwiaWRzIiwicGFydG5lck5hbWUiLCJzaGlwbWVudFN5c3RlbUlkcyIsImNyZWF0ZWRSZWNlaXB0cyIsInZhbHVlcyIsImdyb3VwIiwiYWNjb3VudCIsImFjYyIsInR5cGUiLCJjIiwibmV3UmVjZWlwdERhdGEiLCJwYXllclR5cGUiLCJwYXllck5hbWUiLCJqb2luIiwicGF5bWVudE1ldGhvZCIsImFjY291bnRTeXN0ZW1JZCIsInBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkIiwicGF5bWVudFJlY2VpcHRUeXBlTmFtZSIsInVwZGF0ZWRBdCIsIm5ld1JlY2VpcHQiLCJyZWNlaXB0Rm9yU2hpcG1lbnQiLCJ2Iiwib3JkZXJVcGRhdGVzIiwibmV3UGF5bWVudHMiLCJyZWNvbmNpbGVkU2hpcG1lbnRJZHMiLCJzaXplIiwicHJvY2Vzc0dIVEtXZWJob29rIiwid2ViaG9va0RhdGEiLCJsYWJlbF9pZCIsInBhcnRuZXJfaWQiLCJnZXRHSFRLU3RhdHVzSW5mbyIsImdldEdIVEtSZWFzb25UZXh0IiwicmVxdWlyZSIsInN0YXR1c01hcHBpbmciLCJzdGF0dXNfaWQiLCJzdGF0dXNJZCIsInN0YXR1c1RleHQiLCJwYXJ0bmVyU3RhdHVzIiwiZ2h0a1N0YXR1c0lkIiwiZ2h0a1JlYXNvbkNvZGUiLCJyZWFzb25fY29kZSIsImdodGtSZWFzb25UZXh0IiwiYWN0dWFsV2VpZ2h0IiwiYWN0dWFsRmVlIiwibGFzdFN5bmNlZEF0Iiwic2hvdWxkVXBkYXRlU3RvY2siLCJzdG9ja0FjdGlvbiIsInByb2R1Y3RDb21wbGV0ZURlbGl2ZXJ5IiwiZmFpbHVyZVN0YXR1c2VzIiwiY3VycmVudFBhY2thZ2luZyIsInByZXZpb3VzU3RhdHVzSWQiLCJpdGVtcyIsImFsbFBhY2thZ2luZ3NEZWxpdmVyZWQiLCJuZXdPcmRlckRlbGl2ZXJ5U3RhdHVzIiwibmV3U3RvY2tPdXRTdGF0dXMiLCJjYW5jZWxHSFRLU2hpcG1lbnQiLCJqc29uIiwic3Vic2NyaWJlIiwiY3VycmVudFJlY2VpcHRzIiwicHJldmlvdXNSZWNlaXB0cyIsInByZXZpb3VzSWRzIiwiciIsInVzZU9yZGVyU3RvcmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/orders/store.ts\n"));

/***/ })

});