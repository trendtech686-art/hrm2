"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/customers/page",{

/***/ "(app-pages-browser)/./features/payments/store.ts":
/*!************************************!*\
  !*** ./features/payments/store.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePaymentStore: () => (/* binding */ usePaymentStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/features/finance/document-lookups */ \"(app-pages-browser)/./features/finance/document-lookups.ts\");\n/* harmony import */ var _employees_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../employees/store */ \"(app-pages-browser)/./features/employees/store.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n\n// REMOVED: import { data as initialData } from './data'; // Mock data no longer used - database is source of truth\n\n\n\n\n\n// API sync helpers\nasync function syncToAPI(action, data) {\n    try {\n        const endpoint = action === 'create' ? '/api/payments' : `/api/payments/${data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : 'DELETE';\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.error(`[Payments API] ${action} failed:`, await response.text());\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error(`[Payments API] ${action} error:`, error);\n        return false;\n    }\n}\n// Helper to get current user info\nconst getCurrentUserInfo = ()=>{\n    const currentUserSystemId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.() || 'SYSTEM';\n    const employee = _employees_store__WEBPACK_IMPORTED_MODULE_3__.useEmployeeStore.getState().data.find((e)=>e.systemId === currentUserSystemId);\n    return {\n        systemId: currentUserSystemId,\n        name: employee?.fullName || 'Hệ thống',\n        avatar: employee?.avatarUrl\n    };\n};\n// Helper to create history entry\nconst createHistoryEntry = (action, description, metadata)=>({\n        id: crypto.randomUUID(),\n        action,\n        timestamp: new Date(),\n        user: getCurrentUserInfo(),\n        description,\n        metadata\n    });\nconst PAYMENT_ENTITY = 'payments';\nconst SYSTEM_ID_PREFIX = 'PAYMENT';\nconst BUSINESS_ID_PREFIX = 'PC';\nconst BUSINESS_ID_DIGITS = 6;\nconst PURCHASE_ORDER_SYSTEM_PREFIX = 'PURCHASE';\nconst PURCHASE_ORDER_BUSINESS_PREFIX = 'PO';\nconst normalizePaymentStatus = (status)=>status === 'cancelled' ? 'cancelled' : 'completed';\nconst normalizePayment = (payment)=>({\n        ...payment,\n        status: normalizePaymentStatus(payment.status)\n    });\nconst ensurePaymentMetadata = (payment)=>{\n    let mutated = false;\n    const updates = {};\n    const targetGroup = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickTargetGroup)({\n        systemId: payment.recipientTypeSystemId,\n        name: payment.recipientTypeName\n    });\n    if (targetGroup) {\n        if (payment.recipientTypeSystemId !== targetGroup.systemId) {\n            updates.recipientTypeSystemId = targetGroup.systemId;\n            mutated = true;\n        }\n        if (payment.recipientTypeName !== targetGroup.name) {\n            updates.recipientTypeName = targetGroup.name;\n            mutated = true;\n        }\n    }\n    const paymentMethod = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentMethod)({\n        systemId: payment.paymentMethodSystemId,\n        name: payment.paymentMethodName\n    });\n    if (paymentMethod) {\n        if (payment.paymentMethodSystemId !== paymentMethod.systemId) {\n            updates.paymentMethodSystemId = paymentMethod.systemId;\n            mutated = true;\n        }\n        if (payment.paymentMethodName !== paymentMethod.name) {\n            updates.paymentMethodName = paymentMethod.name;\n            mutated = true;\n        }\n    }\n    const account = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickAccount)({\n        accountSystemId: payment.accountSystemId,\n        branchSystemId: payment.branchSystemId,\n        paymentMethodName: paymentMethod?.name ?? payment.paymentMethodName\n    });\n    if (account && payment.accountSystemId !== account.systemId) {\n        updates.accountSystemId = account.systemId;\n        mutated = true;\n    }\n    const paymentType = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentType)({\n        systemId: payment.paymentReceiptTypeSystemId,\n        name: payment.paymentReceiptTypeName\n    });\n    if (paymentType) {\n        if (payment.paymentReceiptTypeSystemId !== paymentType.systemId) {\n            updates.paymentReceiptTypeSystemId = paymentType.systemId;\n            mutated = true;\n        }\n        if (payment.paymentReceiptTypeName !== paymentType.name) {\n            updates.paymentReceiptTypeName = paymentType.name;\n            mutated = true;\n        }\n    }\n    const normalizedGroupName = targetGroup?.name?.trim().toLowerCase();\n    if (normalizedGroupName === 'khách hàng') {\n        if (!payment.customerName && payment.recipientName) {\n            updates.customerName = payment.recipientName;\n            mutated = true;\n        }\n        if (!payment.customerSystemId && payment.recipientSystemId) {\n            updates.customerSystemId = payment.recipientSystemId;\n            mutated = true;\n        }\n    }\n    return mutated ? {\n        ...payment,\n        ...updates\n    } : payment;\n};\nconst backfillPaymentMetadata = (payments)=>{\n    let mutated = false;\n    const updated = payments.map((payment)=>{\n        const normalized = ensurePaymentMetadata(payment);\n        if (normalized !== payment) {\n            mutated = true;\n        }\n        return normalized;\n    });\n    return mutated ? updated : payments;\n};\nconst initialPayments = backfillPaymentMetadata(initialData.map(normalizePayment));\nlet systemIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(initialPayments, SYSTEM_ID_PREFIX);\nlet businessIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(initialPayments, BUSINESS_ID_PREFIX);\nconst getNextSystemId = ()=>{\n    systemIdCounter += 1;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(PAYMENT_ENTITY, systemIdCounter));\n};\nconst ensurePaymentBusinessId = (payments, provided)=>{\n    if (provided && `${provided}`.trim().length > 0) {\n        const normalized = `${provided}`.trim().toUpperCase();\n        const parsedCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.extractCounterFromBusinessId)(normalized, BUSINESS_ID_PREFIX);\n        if (parsedCounter > businessIdCounter) {\n            businessIdCounter = parsedCounter;\n        }\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(normalized);\n    }\n    const existingIds = payments.map((payment)=>payment.id).filter(Boolean);\n    const { nextId, updatedCounter } = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(BUSINESS_ID_PREFIX, existingIds, businessIdCounter, BUSINESS_ID_DIGITS);\n    businessIdCounter = updatedCounter;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(nextId);\n};\nconst reconcileLinkedDocuments = (payment)=>{\n    if (!payment.originalDocumentId) {\n        return payment;\n    }\n    const normalizedDocId = payment.originalDocumentId.toUpperCase();\n    const nextPayment = {\n        ...payment\n    };\n    if (!nextPayment.purchaseOrderSystemId && normalizedDocId.startsWith(PURCHASE_ORDER_SYSTEM_PREFIX)) {\n        nextPayment.purchaseOrderSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)(payment.originalDocumentId);\n    }\n    if (!nextPayment.purchaseOrderId && normalizedDocId.startsWith(PURCHASE_ORDER_BUSINESS_PREFIX)) {\n        nextPayment.purchaseOrderId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(payment.originalDocumentId);\n    }\n    return nextPayment;\n};\nconst buildPayment = (input, existingPayments)=>{\n    const systemId = getNextSystemId();\n    const id = ensurePaymentBusinessId(existingPayments, input.id);\n    const basePayment = {\n        ...input,\n        systemId,\n        id,\n        createdAt: input.createdAt || new Date().toISOString(),\n        status: normalizePaymentStatus(input.status)\n    };\n    return reconcileLinkedDocuments(basePayment);\n};\nconst usePaymentStore = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.create)()((set, get)=>({\n        data: initialPayments,\n        businessIdCounter,\n        systemIdCounter,\n        initialized: false,\n        add: (item)=>{\n            let createdPayment = null;\n            set((state)=>{\n                const newPayment = buildPayment(item, state.data);\n                createdPayment = newPayment;\n                return {\n                    data: [\n                        ...state.data,\n                        newPayment\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync to API\n            if (createdPayment) {\n                syncToAPI('create', createdPayment).catch(console.error);\n            }\n            return createdPayment;\n        },\n        addMultiple: (items)=>{\n            const created = [];\n            set((state)=>{\n                items.forEach((item)=>{\n                    const context = [\n                        ...state.data,\n                        ...created\n                    ];\n                    const payment = buildPayment(item, context);\n                    created.push(payment);\n                });\n                return {\n                    data: [\n                        ...state.data,\n                        ...created\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync all to API\n            created.forEach((payment)=>{\n                syncToAPI('create', payment).catch(console.error);\n            });\n        },\n        update: (systemId, item)=>{\n            const updated = reconcileLinkedDocuments({\n                ...item,\n                systemId,\n                status: normalizePaymentStatus(item.status),\n                updatedAt: new Date().toISOString()\n            });\n            set((state)=>({\n                    data: state.data.map((payment)=>payment.systemId === systemId ? updated : payment),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('update', updated).catch(console.error);\n        },\n        remove: (systemId)=>{\n            set((state)=>({\n                    data: state.data.filter((payment)=>payment.systemId !== systemId),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('delete', {\n                systemId\n            }).catch(console.error);\n        },\n        findById: (systemId)=>{\n            return get().data.find((payment)=>payment.systemId === systemId);\n        },\n        getActive: ()=>{\n            return get().data.filter((payment)=>payment.status !== 'cancelled');\n        },\n        cancel: (systemId, reason)=>{\n            const payment = get().findById(systemId);\n            if (payment && payment.status !== 'cancelled') {\n                const historyEntry = createHistoryEntry('cancelled', `Đã hủy phiếu chi${reason ? `: ${reason}` : ''}`, {\n                    oldValue: 'Hoàn thành',\n                    newValue: 'Đã hủy',\n                    note: reason\n                });\n                get().update(systemId, {\n                    ...payment,\n                    status: 'cancelled',\n                    cancelledAt: new Date().toISOString(),\n                    activityHistory: [\n                        ...payment.activityHistory || [],\n                        historyEntry\n                    ]\n                });\n            }\n        },\n        loadFromAPI: async ()=>{\n            try {\n                // NOTE: Use React Query hooks for paginated data. This only loads initial batch.\n                const response = await fetch('/api/payments?limit=30');\n                if (!response.ok) return;\n                const json = await response.json();\n                const apiData = json.data || [];\n                if (apiData.length > 0) {\n                    const normalized = backfillPaymentMetadata(apiData.map(normalizePayment));\n                    const nextSystemCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(normalized, SYSTEM_ID_PREFIX);\n                    const nextBusinessCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(normalized, BUSINESS_ID_PREFIX);\n                    systemIdCounter = nextSystemCounter;\n                    businessIdCounter = nextBusinessCounter;\n                    set({\n                        data: normalized,\n                        systemIdCounter,\n                        businessIdCounter,\n                        initialized: true\n                    });\n                } else {\n                    set({\n                        initialized: true\n                    });\n                }\n            } catch (error) {\n                console.error('[Payments API] loadFromAPI error:', error);\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3BheW1lbnRzL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFHakMsbUhBQW1IO0FBUXZGO0FBQ2tFO0FBQ3lCO0FBQ2pFO0FBQ2U7QUFFckUsbUJBQW1CO0FBQ25CLGVBQWVjLFVBQVVDLE1BQXNDLEVBQUVDLElBQVM7SUFDeEUsSUFBSTtRQUNGLE1BQU1DLFdBQVdGLFdBQVcsV0FBVyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUVDLEtBQUtFLFFBQVEsRUFBRTtRQUN6RixNQUFNQyxTQUFTSixXQUFXLFdBQVcsU0FBU0EsV0FBVyxXQUFXLFVBQVU7UUFFOUUsTUFBTUssV0FBVyxNQUFNQyxNQUFNSixVQUFVO1lBQ3JDRTtZQUNBRyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTVIsV0FBVyxXQUFXUyxLQUFLQyxTQUFTLENBQUNULFFBQVFVO1FBQ3JEO1FBRUEsSUFBSSxDQUFDTixTQUFTTyxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGVBQWUsRUFBRWQsT0FBTyxRQUFRLENBQUMsRUFBRSxNQUFNSyxTQUFTVSxJQUFJO1lBQ3JFLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9ELE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFZCxPQUFPLE9BQU8sQ0FBQyxFQUFFYztRQUNqRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGtDQUFrQztBQUNsQyxNQUFNRSxxQkFBcUI7SUFDekIsTUFBTUMsc0JBQXNCbkIsOEVBQXNCQSxRQUFRO0lBQzFELE1BQU1vQixXQUFXckIsOERBQWdCQSxDQUFDc0IsUUFBUSxHQUFHbEIsSUFBSSxDQUFDbUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbEIsUUFBUSxLQUFLYztJQUMzRSxPQUFPO1FBQ0xkLFVBQVVjO1FBQ1ZLLE1BQU1KLFVBQVVLLFlBQVk7UUFDNUJDLFFBQVFOLFVB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Z0JBQU87Z0JBRzdEcEIsTUFBTWMsTUFBTSxDQUFDakgsVUFBVTtvQkFDckIsR0FBR3lDLE9BQU87b0JBQ1ZGLFFBQVE7b0JBQ1JxRixhQUFhLElBQUk5RixPQUFPa0UsV0FBVztvQkFDbkM2QixpQkFBaUI7MkJBQUtwRixRQUFRb0YsZUFBZSxJQUFJLEVBQUU7d0JBQUdMO3FCQUFhO2dCQUNyRTtZQUNGO1FBQ0Y7UUFFQU0sYUFBYTtZQUNYLElBQUk7Z0JBQ0YsaUZBQWlGO2dCQUNqRixNQUFNNUgsV0FBVyxNQUFNQyxNQUFNO2dCQUM3QixJQUFJLENBQUNELFNBQVNPLEVBQUUsRUFBRTtnQkFDbEIsTUFBTXNILE9BQU8sTUFBTTdILFNBQVM2SCxJQUFJO2dCQUNoQyxNQUFNQyxVQUFVRCxLQUFLakksSUFBSSxJQUFJLEVBQUU7Z0JBQy9CLElBQUlrSSxRQUFRcEQsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLE1BQU1SLGFBQWFKLHdCQUF3QmdFLFFBQVE3RCxHQUFHLENBQUMzQjtvQkFDdkQsTUFBTXlGLG9CQUFvQjlJLG9FQUFxQkEsQ0FBQ2lGLFlBQVluQztvQkFDNUQsTUFBTWlHLHNCQUFzQmhKLHNFQUF1QkEsQ0FBQ2tGLFlBQVlsQztvQkFDaEVxQyxrQkFBa0IwRDtvQkFDbEJ6RCxvQkFBb0IwRDtvQkFDcEJoQyxJQUFJO3dCQUNGcEcsTUFBTXNFO3dCQUNORzt3QkFDQUM7d0JBQ0E0QixhQUFhO29CQUNmO2dCQUNGLE9BQU87b0JBQ0xGLElBQUk7d0JBQUVFLGFBQWE7b0JBQUs7Z0JBQzFCO1lBQ0YsRUFBRSxPQUFPekYsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDckQ7UUFDRjtJQUNGLElBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxocm0yXFxmZWF0dXJlc1xccGF5bWVudHNcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xyXG5pbXBvcnQgdHlwZSB7IFBheW1lbnQgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHR5cGUgeyBIaXN0b3J5RW50cnkgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0FjdGl2aXR5SGlzdG9yeSc7XHJcbi8vIFJFTU9WRUQ6IGltcG9ydCB7IGRhdGEgYXMgaW5pdGlhbERhdGEgfSBmcm9tICcuL2RhdGEnOyAvLyBNb2NrIGRhdGEgbm8gbG9uZ2VyIHVzZWQgLSBkYXRhYmFzZSBpcyBzb3VyY2Ugb2YgdHJ1dGhcclxuaW1wb3J0IHtcclxuICBleHRyYWN0Q291bnRlckZyb21CdXNpbmVzc0lkLFxyXG4gIGZpbmROZXh0QXZhaWxhYmxlQnVzaW5lc3NJZCxcclxuICBnZW5lcmF0ZVN5c3RlbUlkLFxyXG4gIGdldE1heEJ1c2luZXNzSWRDb3VudGVyLFxyXG4gIGdldE1heFN5c3RlbUlkQ291bnRlcixcclxuICB0eXBlIEVudGl0eVR5cGUsXHJcbn0gZnJvbSAnLi4vLi4vbGliL2lkLXV0aWxzJztcclxuaW1wb3J0IHsgYXNCdXNpbmVzc0lkLCBhc1N5c3RlbUlkLCB0eXBlIEJ1c2luZXNzSWQsIHR5cGUgU3lzdGVtSWQgfSBmcm9tICcuLi8uLi9saWIvaWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBwaWNrQWNjb3VudCwgcGlja1BheW1lbnRNZXRob2QsIHBpY2tQYXltZW50VHlwZSwgcGlja1RhcmdldEdyb3VwIH0gZnJvbSAnQC9mZWF0dXJlcy9maW5hbmNlL2RvY3VtZW50LWxvb2t1cHMnO1xyXG5pbXBvcnQgeyB1c2VFbXBsb3llZVN0b3JlIH0gZnJvbSAnLi4vZW1wbG95ZWVzL3N0b3JlJztcclxuaW1wb3J0IHsgZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCB9IGZyb20gJy4uLy4uL2NvbnRleHRzL2F1dGgtY29udGV4dCc7XHJcblxyXG4vLyBBUEkgc3luYyBoZWxwZXJzXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNUb0FQSShhY3Rpb246ICdjcmVhdGUnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgZGF0YTogYW55KTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gYWN0aW9uID09PSAnY3JlYXRlJyA/ICcvYXBpL3BheW1lbnRzJyA6IGAvYXBpL3BheW1lbnRzLyR7ZGF0YS5zeXN0ZW1JZH1gO1xyXG4gICAgY29uc3QgbWV0aG9kID0gYWN0aW9uID09PSAnY3JlYXRlJyA/ICdQT1NUJyA6IGFjdGlvbiA9PT0gJ3VwZGF0ZScgPyAnUEFUQ0gnIDogJ0RFTEVURSc7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgYm9keTogYWN0aW9uICE9PSAnZGVsZXRlJyA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgW1BheW1lbnRzIEFQSV0gJHthY3Rpb259IGZhaWxlZDpgLCBhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgW1BheW1lbnRzIEFQSV0gJHthY3Rpb259IGVycm9yOmAsIGVycm9yKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBnZXQgY3VycmVudCB1c2VyIGluZm9cclxuY29uc3QgZ2V0Q3VycmVudFVzZXJJbmZvID0gKCkgPT4ge1xyXG4gIGNvbnN0IGN1cnJlbnRVc2VyU3lzdGVtSWQgPSBnZXRDdXJyZW50VXNlclN5c3RlbUlkPy4oKSB8fCAnU1lTVEVNJztcclxuICBjb25zdCBlbXBsb3llZSA9IHVzZUVtcGxveWVlU3RvcmUuZ2V0U3RhdGUoKS5kYXRhLmZpbmQoZSA9PiBlLnN5c3RlbUlkID09PSBjdXJyZW50VXNlclN5c3RlbUlkKTtcclxuICByZXR1cm4ge1xyXG4gICAgc3lzdGVtSWQ6IGN1cnJlbnRVc2VyU3lzdGVtSWQsXHJcbiAgICBuYW1lOiBlbXBsb3llZT8uZnVsbE5hbWUgfHwgJ0jhu4cgdGjhu5FuZycsXHJcbiAgICBhdmF0YXI6IGVtcGxveWVlPy5hdmF0YXJVcmwsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEhlbHBlciB0byBjcmVhdGUgaGlzdG9yeSBlbnRyeVxyXG5jb25zdCBjcmVhdGVIaXN0b3J5RW50cnkgPSAoXHJcbiAgYWN0aW9uOiBIaXN0b3J5RW50cnlbJ2FjdGlvbiddLFxyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXHJcbiAgbWV0YWRhdGE/OiBIaXN0b3J5RW50cnlbJ21ldGFkYXRhJ11cclxuKTogSGlzdG9yeUVudHJ5ID0+ICh7XHJcbiAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgYWN0aW9uLFxyXG4gIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICB1c2VyOiBnZXRDdXJyZW50VXNlckluZm8oKSxcclxuICBkZXNjcmlwdGlvbixcclxuICBtZXRhZGF0YSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBQYXltZW50SW5wdXQgPSBPbWl0PFBheW1lbnQsICdzeXN0ZW1JZCcgfCAnaWQnPiAmIHsgaWQ/OiBCdXNpbmVzc0lkIHwgc3RyaW5nIH07XHJcblxyXG5pbnRlcmZhY2UgUGF5bWVudFN0b3JlIHtcclxuICBkYXRhOiBQYXltZW50W107XHJcbiAgYnVzaW5lc3NJZENvdW50ZXI6IG51bWJlcjtcclxuICBzeXN0ZW1JZENvdW50ZXI6IG51bWJlcjtcclxuICBpbml0aWFsaXplZDogYm9vbGVhbjtcclxuICBhZGQ6IChpdGVtOiBQYXltZW50SW5wdXQpID0+IFBheW1lbnQ7XHJcbiAgYWRkTXVsdGlwbGU6IChpdGVtczogUGF5bWVudElucHV0W10pID0+IHZvaWQ7XHJcbiAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBQYXltZW50KSA9PiB2b2lkO1xyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gdm9pZDtcclxuICBmaW5kQnlJZDogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gUGF5bWVudCB8IHVuZGVmaW5lZDtcclxuICBnZXRBY3RpdmU6ICgpID0+IFBheW1lbnRbXTtcclxuICBjYW5jZWw6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlYXNvbj86IHN0cmluZykgPT4gdm9pZDtcclxuICBsb2FkRnJvbUFQSTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuY29uc3QgUEFZTUVOVF9FTlRJVFk6IEVudGl0eVR5cGUgPSAncGF5bWVudHMnO1xyXG5jb25zdCBTWVNURU1fSURfUFJFRklYID0gJ1BBWU1FTlQnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9QUkVGSVggPSAnUEMnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9ESUdJVFMgPSA2O1xyXG5jb25zdCBQVVJDSEFTRV9PUkRFUl9TWVNURU1fUFJFRklYID0gJ1BVUkNIQVNFJztcclxuY29uc3QgUFVSQ0hBU0VfT1JERVJfQlVTSU5FU1NfUFJFRklYID0gJ1BPJztcclxuXHJcbmNvbnN0IG5vcm1hbGl6ZVBheW1lbnRTdGF0dXMgPSAoc3RhdHVzPzogUGF5bWVudFsnc3RhdHVzJ10pOiBQYXltZW50WydzdGF0dXMnXSA9PlxyXG4gIHN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcgPyAnY2FuY2VsbGVkJyA6ICdjb21wbGV0ZWQnO1xyXG5cclxuY29uc3Qgbm9ybWFsaXplUGF5bWVudCA9IChwYXltZW50OiBQYXltZW50KTogUGF5bWVudCA9PiAoe1xyXG4gIC4uLnBheW1lbnQsXHJcbiAgc3RhdHVzOiBub3JtYWxpemVQYXltZW50U3RhdHVzKHBheW1lbnQuc3RhdHVzKSxcclxufSk7XHJcblxyXG5jb25zdCBlbnN1cmVQYXltZW50TWV0YWRhdGEgPSAocGF5bWVudDogUGF5bWVudCk6IFBheW1lbnQgPT4ge1xyXG4gIGxldCBtdXRhdGVkID0gZmFsc2U7XHJcbiAgY29uc3QgdXBkYXRlczogUGFydGlhbDxQYXltZW50PiA9IHt9O1xyXG5cclxuICBjb25zdCB0YXJnZXRHcm91cCA9IHBpY2tUYXJnZXRHcm91cCh7XHJcbiAgICBzeXN0ZW1JZDogcGF5bWVudC5yZWNpcGllbnRUeXBlU3lzdGVtSWQsXHJcbiAgICBuYW1lOiBwYXltZW50LnJlY2lwaWVudFR5cGVOYW1lLFxyXG4gIH0pO1xyXG4gIGlmICh0YXJnZXRHcm91cCkge1xyXG4gICAgaWYgKHBheW1lbnQucmVjaXBpZW50VHlwZVN5c3RlbUlkICE9PSB0YXJnZXRHcm91cC5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnJlY2lwaWVudFR5cGVTeXN0ZW1JZCA9IHRhcmdldEdyb3VwLnN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChwYXltZW50LnJlY2lwaWVudFR5cGVOYW1lICE9PSB0YXJnZXRHcm91cC5uYW1lKSB7XHJcbiAgICAgIHVwZGF0ZXMucmVjaXBpZW50VHlwZU5hbWUgPSB0YXJnZXRHcm91cC5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHBheW1lbnRNZXRob2QgPSBwaWNrUGF5bWVudE1ldGhvZCh7XHJcbiAgICBzeXN0ZW1JZDogcGF5bWVudC5wYXltZW50TWV0aG9kU3lzdGVtSWQsXHJcbiAgICBuYW1lOiBwYXltZW50LnBheW1lbnRNZXRob2ROYW1lLFxyXG4gIH0pO1xyXG4gIGlmIChwYXltZW50TWV0aG9kKSB7XHJcbiAgICBpZiAocGF5bWVudC5wYXltZW50TWV0aG9kU3lzdGVtSWQgIT09IHBheW1lbnRNZXRob2Quc3lzdGVtSWQpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kU3lzdGVtSWQgPSBwYXltZW50TWV0aG9kLnN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChwYXltZW50LnBheW1lbnRNZXRob2ROYW1lICE9PSBwYXltZW50TWV0aG9kLm5hbWUpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kTmFtZSA9IHBheW1lbnRNZXRob2QubmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhY2NvdW50ID0gcGlja0FjY291bnQoe1xyXG4gICAgYWNjb3VudFN5c3RlbUlkOiBwYXltZW50LmFjY291bnRTeXN0ZW1JZCxcclxuICAgIGJyYW5jaFN5c3RlbUlkOiBwYXltZW50LmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgcGF5bWVudE1ldGhvZE5hbWU6IHBheW1lbnRNZXRob2Q/Lm5hbWUgPz8gcGF5bWVudC5wYXltZW50TWV0aG9kTmFtZSxcclxuICB9KTtcclxuICBpZiAoYWNjb3VudCAmJiBwYXltZW50LmFjY291bnRTeXN0ZW1JZCAhPT0gYWNjb3VudC5zeXN0ZW1JZCkge1xyXG4gICAgdXBkYXRlcy5hY2NvdW50U3lzdGVtSWQgPSBhY2NvdW50LnN5c3RlbUlkO1xyXG4gICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXltZW50VHlwZSA9IHBpY2tQYXltZW50VHlwZSh7XHJcbiAgICBzeXN0ZW1JZDogcGF5bWVudC5wYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCxcclxuICAgIG5hbWU6IHBheW1lbnQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAocGF5bWVudFR5cGUpIHtcclxuICAgIGlmIChwYXltZW50LnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkICE9PSBwYXltZW50VHlwZS5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkID0gcGF5bWVudFR5cGUuc3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHBheW1lbnQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSAhPT0gcGF5bWVudFR5cGUubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZU5hbWUgPSBwYXltZW50VHlwZS5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IG5vcm1hbGl6ZWRHcm91cE5hbWUgPSB0YXJnZXRHcm91cD8ubmFtZT8udHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKG5vcm1hbGl6ZWRHcm91cE5hbWUgPT09ICdraMOhY2ggaMOgbmcnKSB7XHJcbiAgICBpZiAoIXBheW1lbnQuY3VzdG9tZXJOYW1lICYmIHBheW1lbnQucmVjaXBpZW50TmFtZSkge1xyXG4gICAgICB1cGRhdGVzLmN1c3RvbWVyTmFtZSA9IHBheW1lbnQucmVjaXBpZW50TmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBheW1lbnQuY3VzdG9tZXJTeXN0ZW1JZCAmJiBwYXltZW50LnJlY2lwaWVudFN5c3RlbUlkKSB7XHJcbiAgICAgIHVwZGF0ZXMuY3VzdG9tZXJTeXN0ZW1JZCA9IHBheW1lbnQucmVjaXBpZW50U3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG11dGF0ZWQgPyB7IC4uLnBheW1lbnQsIC4uLnVwZGF0ZXMgfSA6IHBheW1lbnQ7XHJcbn07XHJcblxyXG5jb25zdCBiYWNrZmlsbFBheW1lbnRNZXRhZGF0YSA9IChwYXltZW50czogUGF5bWVudFtdKTogUGF5bWVudFtdID0+IHtcclxuICBsZXQgbXV0YXRlZCA9IGZhbHNlO1xyXG4gIGNvbnN0IHVwZGF0ZWQgPSBwYXltZW50cy5tYXAocGF5bWVudCA9PiB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gZW5zdXJlUGF5bWVudE1ldGFkYXRhKHBheW1lbnQpO1xyXG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IHBheW1lbnQpIHtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9KTtcclxuICByZXR1cm4gbXV0YXRlZCA/IHVwZGF0ZWQgOiBwYXltZW50cztcclxufTtcclxuXHJcbmNvbnN0IGluaXRpYWxQYXltZW50cyA9IGJhY2tmaWxsUGF5bWVudE1ldGFkYXRhKGluaXRpYWxEYXRhLm1hcChub3JtYWxpemVQYXltZW50KSk7XHJcblxyXG5sZXQgc3lzdGVtSWRDb3VudGVyID0gZ2V0TWF4U3lzdGVtSWRDb3VudGVyKGluaXRpYWxQYXltZW50cywgU1lTVEVNX0lEX1BSRUZJWCk7XHJcbmxldCBidXNpbmVzc0lkQ291bnRlciA9IGdldE1heEJ1c2luZXNzSWRDb3VudGVyKGluaXRpYWxQYXltZW50cywgQlVTSU5FU1NfSURfUFJFRklYKTtcclxuXHJcbmNvbnN0IGdldE5leHRTeXN0ZW1JZCA9ICgpOiBTeXN0ZW1JZCA9PiB7XHJcbiAgc3lzdGVtSWRDb3VudGVyICs9IDE7XHJcbiAgcmV0dXJuIGFzU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZChQQVlNRU5UX0VOVElUWSwgc3lzdGVtSWRDb3VudGVyKSk7XHJcbn07XHJcblxyXG5jb25zdCBlbnN1cmVQYXltZW50QnVzaW5lc3NJZCA9IChwYXltZW50czogUGF5bWVudFtdLCBwcm92aWRlZD86IEJ1c2luZXNzSWQgfCBzdHJpbmcpOiBCdXNpbmVzc0lkID0+IHtcclxuICBpZiAocHJvdmlkZWQgJiYgYCR7cHJvdmlkZWR9YC50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGAke3Byb3ZpZGVkfWAudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCBwYXJzZWRDb3VudGVyID0gZXh0cmFjdENvdW50ZXJGcm9tQnVzaW5lc3NJZChub3JtYWxpemVkLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG4gICAgaWYgKHBhcnNlZENvdW50ZXIgPiBidXNpbmVzc0lkQ291bnRlcikge1xyXG4gICAgICBidXNpbmVzc0lkQ291bnRlciA9IHBhcnNlZENvdW50ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXNCdXNpbmVzc0lkKG5vcm1hbGl6ZWQpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBwYXltZW50cy5tYXAocGF5bWVudCA9PiBwYXltZW50LmlkIGFzIHN0cmluZykuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIGNvbnN0IHsgbmV4dElkLCB1cGRhdGVkQ291bnRlciB9ID0gZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkKFxyXG4gICAgQlVTSU5FU1NfSURfUFJFRklYLFxyXG4gICAgZXhpc3RpbmdJZHMsXHJcbiAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgIEJVU0lORVNTX0lEX0RJR0lUU1xyXG4gICk7XHJcbiAgYnVzaW5lc3NJZENvdW50ZXIgPSB1cGRhdGVkQ291bnRlcjtcclxuICByZXR1cm4gYXNCdXNpbmVzc0lkKG5leHRJZCk7XHJcbn07XHJcblxyXG5jb25zdCByZWNvbmNpbGVMaW5rZWREb2N1bWVudHMgPSAocGF5bWVudDogUGF5bWVudCk6IFBheW1lbnQgPT4ge1xyXG4gIGlmICghcGF5bWVudC5vcmlnaW5hbERvY3VtZW50SWQpIHtcclxuICAgIHJldHVybiBwYXltZW50O1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgbm9ybWFsaXplZERvY0lkID0gcGF5bWVudC5vcmlnaW5hbERvY3VtZW50SWQudG9VcHBlckNhc2UoKTtcclxuICBjb25zdCBuZXh0UGF5bWVudCA9IHsgLi4ucGF5bWVudCB9O1xyXG5cclxuICBpZiAoIW5leHRQYXltZW50LnB1cmNoYXNlT3JkZXJTeXN0ZW1JZCAmJiBub3JtYWxpemVkRG9jSWQuc3RhcnRzV2l0aChQVVJDSEFTRV9PUkRFUl9TWVNURU1fUFJFRklYKSkge1xyXG4gICAgbmV4dFBheW1lbnQucHVyY2hhc2VPcmRlclN5c3RlbUlkID0gYXNTeXN0ZW1JZChwYXltZW50Lm9yaWdpbmFsRG9jdW1lbnRJZCk7XHJcbiAgfVxyXG5cclxuICBpZiAoIW5leHRQYXltZW50LnB1cmNoYXNlT3JkZXJJZCAmJiBub3JtYWxpemVkRG9jSWQuc3RhcnRzV2l0aChQVVJDSEFTRV9PUkRFUl9CVVNJTkVTU19QUkVGSVgpKSB7XHJcbiAgICBuZXh0UGF5bWVudC5wdXJjaGFzZU9yZGVySWQgPSBhc0J1c2luZXNzSWQocGF5bWVudC5vcmlnaW5hbERvY3VtZW50SWQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5leHRQYXltZW50O1xyXG59O1xyXG5cclxuY29uc3QgYnVpbGRQYXltZW50ID0gKGlucHV0OiBQYXltZW50SW5wdXQsIGV4aXN0aW5nUGF5bWVudHM6IFBheW1lbnRbXSk6IFBheW1lbnQgPT4ge1xyXG4gIGNvbnN0IHN5c3RlbUlkID0gZ2V0TmV4dFN5c3RlbUlkKCk7XHJcbiAgY29uc3QgaWQgPSBlbnN1cmVQYXltZW50QnVzaW5lc3NJZChleGlzdGluZ1BheW1lbnRzLCBpbnB1dC5pZCk7XHJcbiAgY29uc3QgYmFzZVBheW1lbnQ6IFBheW1lbnQgPSB7XHJcbiAgICAuLi5pbnB1dCxcclxuICAgIHN5c3RlbUlkLFxyXG4gICAgaWQsXHJcbiAgICBjcmVhdGVkQXQ6IGlucHV0LmNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICBzdGF0dXM6IG5vcm1hbGl6ZVBheW1lbnRTdGF0dXMoaW5wdXQuc3RhdHVzKSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gcmVjb25jaWxlTGlua2VkRG9jdW1lbnRzKGJhc2VQYXltZW50KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VQYXltZW50U3RvcmUgPSBjcmVhdGU8UGF5bWVudFN0b3JlPigpKFxyXG4gIChzZXQsIGdldCkgPT4gKHtcclxuICAgICAgZGF0YTogaW5pdGlhbFBheW1lbnRzLFxyXG4gICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgc3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICBpbml0aWFsaXplZDogZmFsc2UsXHJcbiAgICAgIFxyXG4gICAgICBhZGQ6IChpdGVtKSA9PiB7XHJcbiAgICAgICAgbGV0IGNyZWF0ZWRQYXltZW50OiBQYXltZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgc2V0KHN0YXRlID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1BheW1lbnQgPSBidWlsZFBheW1lbnQoaXRlbSwgc3RhdGUuZGF0YSk7XHJcbiAgICAgICAgICBjcmVhdGVkUGF5bWVudCA9IG5ld1BheW1lbnQ7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBbLi4uc3RhdGUuZGF0YSwgbmV3UGF5bWVudF0sXHJcbiAgICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFN5bmMgdG8gQVBJXHJcbiAgICAgICAgaWYgKGNyZWF0ZWRQYXltZW50KSB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoJ2NyZWF0ZScsIGNyZWF0ZWRQYXltZW50KS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZWRQYXltZW50ITtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGFkZE11bHRpcGxlOiAoaXRlbXMpID0+IHtcclxuICAgICAgICBjb25zdCBjcmVhdGVkOiBQYXltZW50W10gPSBbXTtcclxuICAgICAgICBzZXQoc3RhdGUgPT4ge1xyXG4gICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IFsuLi5zdGF0ZS5kYXRhLCAuLi5jcmVhdGVkXTtcclxuICAgICAgICAgICAgY29uc3QgcGF5bWVudCA9IGJ1aWxkUGF5bWVudChpdGVtLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY3JlYXRlZC5wdXNoKHBheW1lbnQpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogWy4uLnN0YXRlLmRhdGEsIC4uLmNyZWF0ZWRdLFxyXG4gICAgICAgICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgICAgICAgc3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTeW5jIGFsbCB0byBBUElcclxuICAgICAgICBjcmVhdGVkLmZvckVhY2gocGF5bWVudCA9PiB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoJ2NyZWF0ZScsIHBheW1lbnQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgdXBkYXRlOiAoc3lzdGVtSWQsIGl0ZW0pID0+IHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkID0gcmVjb25jaWxlTGlua2VkRG9jdW1lbnRzKHtcclxuICAgICAgICAgIC4uLml0ZW0sXHJcbiAgICAgICAgICBzeXN0ZW1JZCxcclxuICAgICAgICAgIHN0YXR1czogbm9ybWFsaXplUGF5bWVudFN0YXR1cyhpdGVtLnN0YXR1cyksXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKHBheW1lbnQgPT5cclxuICAgICAgICAgICAgcGF5bWVudC5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQgPyB1cGRhdGVkIDogcGF5bWVudFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgc3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIHN5bmNUb0FQSSgndXBkYXRlJywgdXBkYXRlZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICByZW1vdmU6IChzeXN0ZW1JZCkgPT4ge1xyXG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5maWx0ZXIocGF5bWVudCA9PiBwYXltZW50LnN5c3RlbUlkICE9PSBzeXN0ZW1JZCksXHJcbiAgICAgICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgICAgIHN5c3RlbUlkQ291bnRlcixcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLy8gU3luYyB0byBBUElcclxuICAgICAgICBzeW5jVG9BUEkoJ2RlbGV0ZScsIHsgc3lzdGVtSWQgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBmaW5kQnlJZDogKHN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldCgpLmRhdGEuZmluZChwYXltZW50ID0+IHBheW1lbnQuc3lzdGVtSWQgPT09IHN5c3RlbUlkKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGdldEFjdGl2ZTogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBnZXQoKS5kYXRhLmZpbHRlcihwYXltZW50ID0+IHBheW1lbnQuc3RhdHVzICE9PSAnY2FuY2VsbGVkJyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBjYW5jZWw6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlYXNvbj86IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBheW1lbnQgPSBnZXQoKS5maW5kQnlJZChzeXN0ZW1JZCk7XHJcbiAgICAgICAgaWYgKHBheW1lbnQgJiYgcGF5bWVudC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICBjb25zdCBoaXN0b3J5RW50cnkgPSBjcmVhdGVIaXN0b3J5RW50cnkoXHJcbiAgICAgICAgICAgICdjYW5jZWxsZWQnLFxyXG4gICAgICAgICAgICBgxJDDoyBo4buneSBwaGnhur91IGNoaSR7cmVhc29uID8gYDogJHtyZWFzb259YCA6ICcnfWAsXHJcbiAgICAgICAgICAgIHsgb2xkVmFsdWU6ICdIb8OgbiB0aMOgbmgnLCBuZXdWYWx1ZTogJ8SQw6MgaOG7p3knLCBub3RlOiByZWFzb24gfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZ2V0KCkudXBkYXRlKHN5c3RlbUlkLCB7XHJcbiAgICAgICAgICAgIC4uLnBheW1lbnQsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICAgIGNhbmNlbGxlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGFjdGl2aXR5SGlzdG9yeTogWy4uLihwYXltZW50LmFjdGl2aXR5SGlzdG9yeSB8fCBbXSksIGhpc3RvcnlFbnRyeV0sXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBsb2FkRnJvbUFQSTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBOT1RFOiBVc2UgUmVhY3QgUXVlcnkgaG9va3MgZm9yIHBhZ2luYXRlZCBkYXRhLiBUaGlzIG9ubHkgbG9hZHMgaW5pdGlhbCBiYXRjaC5cclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcGF5bWVudHM/bGltaXQ9MzAnKTtcclxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybjtcclxuICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICBjb25zdCBhcGlEYXRhID0ganNvbi5kYXRhIHx8IFtdO1xyXG4gICAgICAgICAgaWYgKGFwaURhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYmFja2ZpbGxQYXltZW50TWV0YWRhdGEoYXBpRGF0YS5tYXAobm9ybWFsaXplUGF5bWVudCkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0U3lzdGVtQ291bnRlciA9IGdldE1heFN5c3RlbUlkQ291bnRlcihub3JtYWxpemVkLCBTWVNURU1fSURfUFJFRklYKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEJ1c2luZXNzQ291bnRlciA9IGdldE1heEJ1c2luZXNzSWRDb3VudGVyKG5vcm1hbGl6ZWQsIEJVU0lORVNTX0lEX1BSRUZJWCk7XHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlciA9IG5leHRTeXN0ZW1Db3VudGVyO1xyXG4gICAgICAgICAgICBidXNpbmVzc0lkQ291bnRlciA9IG5leHRCdXNpbmVzc0NvdW50ZXI7XHJcbiAgICAgICAgICAgIHNldCh7IFxyXG4gICAgICAgICAgICAgIGRhdGE6IG5vcm1hbGl6ZWQsIFxyXG4gICAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlciwgXHJcbiAgICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0KHsgaW5pdGlhbGl6ZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tQYXltZW50cyBBUEldIGxvYWRGcm9tQVBJIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9KVxyXG4pO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiZXh0cmFjdENvdW50ZXJGcm9tQnVzaW5lc3NJZCIsImZpbmROZXh0QXZhaWxhYmxlQnVzaW5lc3NJZCIsImdlbmVyYXRlU3lzdGVtSWQiLCJnZXRNYXhCdXNpbmVzc0lkQ291bnRlciIsImdldE1heFN5c3RlbUlkQ291bnRlciIsImFzQnVzaW5lc3NJZCIsImFzU3lzdGVtSWQiLCJwaWNrQWNjb3VudCIsInBpY2tQYXltZW50TWV0aG9kIiwicGlja1BheW1lbnRUeXBlIiwicGlja1RhcmdldEdyb3VwIiwidXNlRW1wbG95ZWVTdG9yZSIsImdldEN1cnJlbnRVc2VyU3lzdGVtSWQiLCJzeW5jVG9BUEkiLCJhY3Rpb24iLCJkYXRhIiwiZW5kcG9pbnQiLCJzeXN0ZW1JZCIsIm1ldGhvZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJvayIsImNvbnNvbGUiLCJlcnJvciIsInRleHQiLCJnZXRDdXJyZW50VXNlckluZm8iLCJjdXJyZW50VXNlclN5c3RlbUlkIiwiZW1wbG95ZWUiLCJnZXRTdGF0ZSIsImZpbmQiLCJlIiwibmFtZSIsImZ1bGxOYW1lIiwiYXZhdGFyIiwiYXZhdGFyVXJsIiwiY3JlYXRlSGlzdG9yeUVudHJ5IiwiZGVzY3JpcHRpb24iLCJtZXRhZGF0YSIsImlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ1c2VyIiwiUEFZTUVOVF9FTlRJVFkiLCJTWVNURU1fSURfUFJFRklYIiwiQlVTSU5FU1NfSURfUFJFRklYIiwiQlVTSU5FU1NfSURfRElHSVRTIiwiUFVSQ0hBU0VfT1JERVJfU1lTVEVNX1BSRUZJWCIsIlBVUkNIQVNFX09SREVSX0JVU0lORVNTX1BSRUZJWCIsIm5vcm1hbGl6ZVBheW1lbnRTdGF0dXMiLCJzdGF0dXMiLCJub3JtYWxpemVQYXltZW50IiwicGF5bWVudCIsImVuc3VyZVBheW1lbnRNZXRhZGF0YSIsIm11dGF0ZWQiLCJ1cGRhdGVzIiwidGFyZ2V0R3JvdXAiLCJyZWNpcGllbnRUeXBlU3lzdGVtSWQiLCJyZWNpcGllbnRUeXBlTmFtZSIsInBheW1lbnRNZXRob2QiLCJwYXltZW50TWV0aG9kU3lzdGVtSWQiLCJwYXltZW50TWV0aG9kTmFtZSIsImFjY291bnQiLCJhY2NvdW50U3lzdGVtSWQiLCJicmFuY2hTeXN0ZW1JZCIsInBheW1lbnRUeXBlIiwicGF5bWVudFJlY2VpcHRUeXBlU3lzdGVtSWQiLCJwYXltZW50UmVjZWlwdFR5cGVOYW1lIiwibm9ybWFsaXplZEdyb3VwTmFtZSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImN1c3RvbWVyTmFtZSIsInJlY2lwaWVudE5hbWUiLCJjdXN0b21lclN5c3RlbUlkIiwicmVjaXBpZW50U3lzdGVtSWQiLCJiYWNrZmlsbFBheW1lbnRNZXRhZGF0YSIsInBheW1lbnRzIiwidXBkYXRlZCIsIm1hcCIsIm5vcm1hbGl6ZWQiLCJpbml0aWFsUGF5bWVudHMiLCJpbml0aWFsRGF0YSIsInN5c3RlbUlkQ291bnRlciIsImJ1c2luZXNzSWRDb3VudGVyIiwiZ2V0TmV4dFN5c3RlbUlkIiwiZW5zdXJlUGF5bWVudEJ1c2luZXNzSWQiLCJwcm92aWRlZCIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwicGFyc2VkQ291bnRlciIsImV4aXN0aW5nSWRzIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm5leHRJZCIsInVwZGF0ZWRDb3VudGVyIiwicmVjb25jaWxlTGlua2VkRG9jdW1lbnRzIiwib3JpZ2luYWxEb2N1bWVudElkIiwibm9ybWFsaXplZERvY0lkIiwibmV4dFBheW1lbnQiLCJwdXJjaGFzZU9yZGVyU3lzdGVtSWQiLCJzdGFydHNXaXRoIiwicHVyY2hhc2VPcmRlcklkIiwiYnVpbGRQYXltZW50IiwiaW5wdXQiLCJleGlzdGluZ1BheW1lbnRzIiwiYmFzZVBheW1lbnQiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInVzZVBheW1lbnRTdG9yZSIsInNldCIsImdldCIsImluaXRpYWxpemVkIiwiYWRkIiwiaXRlbSIsImNyZWF0ZWRQYXltZW50Iiwic3RhdGUiLCJuZXdQYXltZW50IiwiY2F0Y2giLCJhZGRNdWx0aXBsZSIsIml0ZW1zIiwiY3JlYXRlZCIsImZvckVhY2giLCJjb250ZXh0IiwicHVzaCIsInVwZGF0ZSIsInVwZGF0ZWRBdCIsInJlbW92ZSIsImZpbmRCeUlkIiwiZ2V0QWN0aXZlIiwiY2FuY2VsIiwicmVhc29uIiwiaGlzdG9yeUVudHJ5Iiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIm5vdGUiLCJjYW5jZWxsZWRBdCIsImFjdGl2aXR5SGlzdG9yeSIsImxvYWRGcm9tQVBJIiwianNvbiIsImFwaURhdGEiLCJuZXh0U3lzdGVtQ291bnRlciIsIm5leHRCdXNpbmVzc0NvdW50ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/payments/store.ts\n"));

/***/ })

});