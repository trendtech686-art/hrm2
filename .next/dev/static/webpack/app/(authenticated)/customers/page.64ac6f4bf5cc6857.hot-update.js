"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/customers/page",{

/***/ "(app-pages-browser)/./features/payments/store.ts":
/*!************************************!*\
  !*** ./features/payments/store.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePaymentStore: () => (/* binding */ usePaymentStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/features/finance/document-lookups */ \"(app-pages-browser)/./features/finance/document-lookups.ts\");\n/* harmony import */ var _employees_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../employees/store */ \"(app-pages-browser)/./features/employees/store.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n\n// REMOVED: import { data as initialData } from './data'; // Mock data no longer used - database is source of truth\n\n\n\n\n\n// API sync helpers\nasync function syncToAPI(action, data) {\n    try {\n        const endpoint = action === 'create' ? '/api/payments' : `/api/payments/${data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : 'DELETE';\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.error(`[Payments API] ${action} failed:`, await response.text());\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error(`[Payments API] ${action} error:`, error);\n        return false;\n    }\n}\n// Helper to get current user info\nconst getCurrentUserInfo = ()=>{\n    const currentUserSystemId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.() || 'SYSTEM';\n    const employee = _employees_store__WEBPACK_IMPORTED_MODULE_3__.useEmployeeStore.getState().data.find((e)=>e.systemId === currentUserSystemId);\n    return {\n        systemId: currentUserSystemId,\n        name: employee?.fullName || 'Hệ thống',\n        avatar: employee?.avatarUrl\n    };\n};\n// Helper to create history entry\nconst createHistoryEntry = (action, description, metadata)=>({\n        id: crypto.randomUUID(),\n        action,\n        timestamp: new Date(),\n        user: getCurrentUserInfo(),\n        description,\n        metadata\n    });\nconst PAYMENT_ENTITY = 'payments';\nconst SYSTEM_ID_PREFIX = 'PAYMENT';\nconst BUSINESS_ID_PREFIX = 'PC';\nconst BUSINESS_ID_DIGITS = 6;\nconst PURCHASE_ORDER_SYSTEM_PREFIX = 'PURCHASE';\nconst PURCHASE_ORDER_BUSINESS_PREFIX = 'PO';\nconst normalizePaymentStatus = (status)=>status === 'cancelled' ? 'cancelled' : 'completed';\nconst normalizePayment = (payment)=>({\n        ...payment,\n        status: normalizePaymentStatus(payment.status)\n    });\nconst ensurePaymentMetadata = (payment)=>{\n    let mutated = false;\n    const updates = {};\n    const targetGroup = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickTargetGroup)({\n        systemId: payment.recipientTypeSystemId,\n        name: payment.recipientTypeName\n    });\n    if (targetGroup) {\n        if (payment.recipientTypeSystemId !== targetGroup.systemId) {\n            updates.recipientTypeSystemId = targetGroup.systemId;\n            mutated = true;\n        }\n        if (payment.recipientTypeName !== targetGroup.name) {\n            updates.recipientTypeName = targetGroup.name;\n            mutated = true;\n        }\n    }\n    const paymentMethod = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentMethod)({\n        systemId: payment.paymentMethodSystemId,\n        name: payment.paymentMethodName\n    });\n    if (paymentMethod) {\n        if (payment.paymentMethodSystemId !== paymentMethod.systemId) {\n            updates.paymentMethodSystemId = paymentMethod.systemId;\n            mutated = true;\n        }\n        if (payment.paymentMethodName !== paymentMethod.name) {\n            updates.paymentMethodName = paymentMethod.name;\n            mutated = true;\n        }\n    }\n    const account = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickAccount)({\n        accountSystemId: payment.accountSystemId,\n        branchSystemId: payment.branchSystemId,\n        paymentMethodName: paymentMethod?.name ?? payment.paymentMethodName\n    });\n    if (account && payment.accountSystemId !== account.systemId) {\n        updates.accountSystemId = account.systemId;\n        mutated = true;\n    }\n    const paymentType = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentType)({\n        systemId: payment.paymentReceiptTypeSystemId,\n        name: payment.paymentReceiptTypeName\n    });\n    if (paymentType) {\n        if (payment.paymentReceiptTypeSystemId !== paymentType.systemId) {\n            updates.paymentReceiptTypeSystemId = paymentType.systemId;\n            mutated = true;\n        }\n        if (payment.paymentReceiptTypeName !== paymentType.name) {\n            updates.paymentReceiptTypeName = paymentType.name;\n            mutated = true;\n        }\n    }\n    const normalizedGroupName = targetGroup?.name?.trim().toLowerCase();\n    if (normalizedGroupName === 'khách hàng') {\n        if (!payment.customerName && payment.recipientName) {\n            updates.customerName = payment.recipientName;\n            mutated = true;\n        }\n        if (!payment.customerSystemId && payment.recipientSystemId) {\n            updates.customerSystemId = payment.recipientSystemId;\n            mutated = true;\n        }\n    }\n    return mutated ? {\n        ...payment,\n        ...updates\n    } : payment;\n};\nconst backfillPaymentMetadata = (payments)=>{\n    let mutated = false;\n    const updated = payments.map((payment)=>{\n        const normalized = ensurePaymentMetadata(payment);\n        if (normalized !== payment) {\n            mutated = true;\n        }\n        return normalized;\n    });\n    return mutated ? updated : payments;\n};\nconst initialPayments = []; // Database is source of truth\nlet systemIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(initialPayments, SYSTEM_ID_PREFIX);\nlet businessIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(initialPayments, BUSINESS_ID_PREFIX);\nconst getNextSystemId = ()=>{\n    systemIdCounter += 1;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(PAYMENT_ENTITY, systemIdCounter));\n};\nconst ensurePaymentBusinessId = (payments, provided)=>{\n    if (provided && `${provided}`.trim().length > 0) {\n        const normalized = `${provided}`.trim().toUpperCase();\n        const parsedCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.extractCounterFromBusinessId)(normalized, BUSINESS_ID_PREFIX);\n        if (parsedCounter > businessIdCounter) {\n            businessIdCounter = parsedCounter;\n        }\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(normalized);\n    }\n    const existingIds = payments.map((payment)=>payment.id).filter(Boolean);\n    const { nextId, updatedCounter } = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(BUSINESS_ID_PREFIX, existingIds, businessIdCounter, BUSINESS_ID_DIGITS);\n    businessIdCounter = updatedCounter;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(nextId);\n};\nconst reconcileLinkedDocuments = (payment)=>{\n    if (!payment.originalDocumentId) {\n        return payment;\n    }\n    const normalizedDocId = payment.originalDocumentId.toUpperCase();\n    const nextPayment = {\n        ...payment\n    };\n    if (!nextPayment.purchaseOrderSystemId && normalizedDocId.startsWith(PURCHASE_ORDER_SYSTEM_PREFIX)) {\n        nextPayment.purchaseOrderSystemId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)(payment.originalDocumentId);\n    }\n    if (!nextPayment.purchaseOrderId && normalizedDocId.startsWith(PURCHASE_ORDER_BUSINESS_PREFIX)) {\n        nextPayment.purchaseOrderId = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(payment.originalDocumentId);\n    }\n    return nextPayment;\n};\nconst buildPayment = (input, existingPayments)=>{\n    const systemId = getNextSystemId();\n    const id = ensurePaymentBusinessId(existingPayments, input.id);\n    const basePayment = {\n        ...input,\n        systemId,\n        id,\n        createdAt: input.createdAt || new Date().toISOString(),\n        status: normalizePaymentStatus(input.status)\n    };\n    return reconcileLinkedDocuments(basePayment);\n};\nconst usePaymentStore = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.create)()((set, get)=>({\n        data: initialPayments,\n        businessIdCounter,\n        systemIdCounter,\n        initialized: false,\n        add: (item)=>{\n            let createdPayment = null;\n            set((state)=>{\n                const newPayment = buildPayment(item, state.data);\n                createdPayment = newPayment;\n                return {\n                    data: [\n                        ...state.data,\n                        newPayment\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync to API\n            if (createdPayment) {\n                syncToAPI('create', createdPayment).catch(console.error);\n            }\n            return createdPayment;\n        },\n        addMultiple: (items)=>{\n            const created = [];\n            set((state)=>{\n                items.forEach((item)=>{\n                    const context = [\n                        ...state.data,\n                        ...created\n                    ];\n                    const payment = buildPayment(item, context);\n                    created.push(payment);\n                });\n                return {\n                    data: [\n                        ...state.data,\n                        ...created\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync all to API\n            created.forEach((payment)=>{\n                syncToAPI('create', payment).catch(console.error);\n            });\n        },\n        update: (systemId, item)=>{\n            const updated = reconcileLinkedDocuments({\n                ...item,\n                systemId,\n                status: normalizePaymentStatus(item.status),\n                updatedAt: new Date().toISOString()\n            });\n            set((state)=>({\n                    data: state.data.map((payment)=>payment.systemId === systemId ? updated : payment),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('update', updated).catch(console.error);\n        },\n        remove: (systemId)=>{\n            set((state)=>({\n                    data: state.data.filter((payment)=>payment.systemId !== systemId),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('delete', {\n                systemId\n            }).catch(console.error);\n        },\n        findById: (systemId)=>{\n            return get().data.find((payment)=>payment.systemId === systemId);\n        },\n        getActive: ()=>{\n            return get().data.filter((payment)=>payment.status !== 'cancelled');\n        },\n        cancel: (systemId, reason)=>{\n            const payment = get().findById(systemId);\n            if (payment && payment.status !== 'cancelled') {\n                const historyEntry = createHistoryEntry('cancelled', `Đã hủy phiếu chi${reason ? `: ${reason}` : ''}`, {\n                    oldValue: 'Hoàn thành',\n                    newValue: 'Đã hủy',\n                    note: reason\n                });\n                get().update(systemId, {\n                    ...payment,\n                    status: 'cancelled',\n                    cancelledAt: new Date().toISOString(),\n                    activityHistory: [\n                        ...payment.activityHistory || [],\n                        historyEntry\n                    ]\n                });\n            }\n        },\n        loadFromAPI: async ()=>{\n            try {\n                // NOTE: Use React Query hooks for paginated data. This only loads initial batch.\n                const response = await fetch('/api/payments?limit=30');\n                if (!response.ok) return;\n                const json = await response.json();\n                const apiData = json.data || [];\n                if (apiData.length > 0) {\n                    const normalized = backfillPaymentMetadata(apiData.map(normalizePayment));\n                    const nextSystemCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(normalized, SYSTEM_ID_PREFIX);\n                    const nextBusinessCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(normalized, BUSINESS_ID_PREFIX);\n                    systemIdCounter = nextSystemCounter;\n                    businessIdCounter = nextBusinessCounter;\n                    set({\n                        data: normalized,\n                        systemIdCounter,\n                        businessIdCounter,\n                        initialized: true\n                    });\n                } else {\n                    set({\n                        initialized: true\n                    });\n                }\n            } catch (error) {\n                console.error('[Payments API] loadFromAPI error:', error);\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3BheW1lbnRzL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFHakMsbUhBQW1IO0FBUXZGO0FBQ2tFO0FBQ3lCO0FBQ2pFO0FBQ2U7QUFFckUsbUJBQW1CO0FBQ25CLGVBQWVjLFVBQVVDLE1BQXNDLEVBQUVDLElBQVM7SUFDeEUsSUFBSTtRQUNGLE1BQU1DLFdBQVdGLFdBQVcsV0FBVyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUVDLEtBQUtFLFFBQVEsRUFBRTtRQUN6RixNQUFNQyxTQUFTSixXQUFXLFdBQVcsU0FBU0EsV0FBVyxXQUFXLFVBQVU7UUFFOUUsTUFBTUssV0FBVyxNQUFNQyxNQUFNSixVQUFVO1lBQ3JDRTtZQUNBRyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTVIsV0FBVyxXQUFXUyxLQUFLQyxTQUFTLENBQUNULFFBQVFVO1FBQ3JEO1FBRUEsSUFBSSxDQUFDTixTQUFTTyxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGVBQWUsRUFBRWQsT0FBTyxRQUFRLENBQUMsRUFBRSxNQUFNSyxTQUFTVSxJQUFJO1lBQ3JFLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9ELE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFZCxPQUFPLE9BQU8sQ0FBQyxFQUFFYztRQUNqRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGtDQUFrQztBQUNsQyxNQUFNRSxxQkFBcUI7SUFDekIsTUFBTUMsc0JBQXNCbkIsOEVBQXNCQSxRQUFRO0lBQzFELE1BQU1vQixXQUFXckIsOERBQWdCQSxDQUFDc0IsUUFBUSxHQUFHbEIsSUFBSSxDQUFDbUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbEIsUUFBUSxLQUFLYztJQUMzRSxPQUFPO1FBQ0xkLFVBQVVjO1FBQ1ZLLE1BQU1KLFVBQVVLLFlBQVk7UUFDNUJDLFFBQVFOLFVB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RHBCLE1BQU1jLE1BQU0sQ0FBQ2hILFVBQVU7b0JBQ3JCLEdBQUd5QyxPQUFPO29CQUNWRixRQUFRO29CQUNSb0YsYUFBYSxJQUFJN0YsT0FBT2lFLFdBQVc7b0JBQ25DNkIsaUJBQWlCOzJCQUFLbkYsUUFBUW1GLGVBQWUsSUFBSSxFQUFFO3dCQUFHTDtxQkFBYTtnQkFDckU7WUFDRjtRQUNGO1FBRUFNLGFBQWE7WUFDWCxJQUFJO2dCQUNGLGlGQUFpRjtnQkFDakYsTUFBTTNILFdBQVcsTUFBTUMsTUFBTTtnQkFDN0IsSUFBSSxDQUFDRCxTQUFTTyxFQUFFLEVBQUU7Z0JBQ2xCLE1BQU1xSCxPQUFPLE1BQU01SCxTQUFTNEgsSUFBSTtnQkFDaEMsTUFBTUMsVUFBVUQsS0FBS2hJLElBQUksSUFBSSxFQUFFO2dCQUMvQixJQUFJaUksUUFBUXBELE1BQU0sR0FBRyxHQUFHO29CQUN0QixNQUFNUCxhQUFhSix3QkFBd0IrRCxRQUFRNUQsR0FBRyxDQUFDM0I7b0JBQ3ZELE1BQU13RixvQkFBb0I3SSxvRUFBcUJBLENBQUNpRixZQUFZbkM7b0JBQzVELE1BQU1nRyxzQkFBc0IvSSxzRUFBdUJBLENBQUNrRixZQUFZbEM7b0JBQ2hFb0Msa0JBQWtCMEQ7b0JBQ2xCekQsb0JBQW9CMEQ7b0JBQ3BCaEMsSUFBSTt3QkFDRm5HLE1BQU1zRTt3QkFDTkU7d0JBQ0FDO3dCQUNBNEIsYUFBYTtvQkFDZjtnQkFDRixPQUFPO29CQUNMRixJQUFJO3dCQUFFRSxhQUFhO29CQUFLO2dCQUMxQjtZQUNGLEVBQUUsT0FBT3hGLE9BQU87Z0JBQ2RELFFBQVFDLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ3JEO1FBQ0Y7SUFDRixJQUNGIiwic291cmNlcyI6WyJEOlxcaHJtMlxcZmVhdHVyZXNcXHBheW1lbnRzXFxzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuaW1wb3J0IHR5cGUgeyBQYXltZW50IH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB0eXBlIHsgSGlzdG9yeUVudHJ5IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9BY3Rpdml0eUhpc3RvcnknO1xyXG4vLyBSRU1PVkVEOiBpbXBvcnQgeyBkYXRhIGFzIGluaXRpYWxEYXRhIH0gZnJvbSAnLi9kYXRhJzsgLy8gTW9jayBkYXRhIG5vIGxvbmdlciB1c2VkIC0gZGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcbmltcG9ydCB7XHJcbiAgZXh0cmFjdENvdW50ZXJGcm9tQnVzaW5lc3NJZCxcclxuICBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQsXHJcbiAgZ2VuZXJhdGVTeXN0ZW1JZCxcclxuICBnZXRNYXhCdXNpbmVzc0lkQ291bnRlcixcclxuICBnZXRNYXhTeXN0ZW1JZENvdW50ZXIsXHJcbiAgdHlwZSBFbnRpdHlUeXBlLFxyXG59IGZyb20gJy4uLy4uL2xpYi9pZC11dGlscyc7XHJcbmltcG9ydCB7IGFzQnVzaW5lc3NJZCwgYXNTeXN0ZW1JZCwgdHlwZSBCdXNpbmVzc0lkLCB0eXBlIFN5c3RlbUlkIH0gZnJvbSAnLi4vLi4vbGliL2lkLXR5cGVzJztcclxuaW1wb3J0IHsgcGlja0FjY291bnQsIHBpY2tQYXltZW50TWV0aG9kLCBwaWNrUGF5bWVudFR5cGUsIHBpY2tUYXJnZXRHcm91cCB9IGZyb20gJ0AvZmVhdHVyZXMvZmluYW5jZS9kb2N1bWVudC1sb29rdXBzJztcclxuaW1wb3J0IHsgdXNlRW1wbG95ZWVTdG9yZSB9IGZyb20gJy4uL2VtcGxveWVlcy9zdG9yZSc7XHJcbmltcG9ydCB7IGdldEN1cnJlbnRVc2VyU3lzdGVtSWQgfSBmcm9tICcuLi8uLi9jb250ZXh0cy9hdXRoLWNvbnRleHQnO1xyXG5cclxuLy8gQVBJIHN5bmMgaGVscGVyc1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jVG9BUEkoYWN0aW9uOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIGRhdGE6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnL2FwaS9wYXltZW50cycgOiBgL2FwaS9wYXltZW50cy8ke2RhdGEuc3lzdGVtSWR9YDtcclxuICAgIGNvbnN0IG1ldGhvZCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnUE9TVCcgOiBhY3Rpb24gPT09ICd1cGRhdGUnID8gJ1BBVENIJyA6ICdERUxFVEUnO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XHJcbiAgICAgIG1ldGhvZCxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IGFjdGlvbiAhPT0gJ2RlbGV0ZScgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtQYXltZW50cyBBUEldICR7YWN0aW9ufSBmYWlsZWQ6YCwgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFtQYXltZW50cyBBUEldICR7YWN0aW9ufSBlcnJvcjpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gZ2V0IGN1cnJlbnQgdXNlciBpbmZvXHJcbmNvbnN0IGdldEN1cnJlbnRVc2VySW5mbyA9ICgpID0+IHtcclxuICBjb25zdCBjdXJyZW50VXNlclN5c3RlbUlkID0gZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZD8uKCkgfHwgJ1NZU1RFTSc7XHJcbiAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKGUgPT4gZS5zeXN0ZW1JZCA9PT0gY3VycmVudFVzZXJTeXN0ZW1JZCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5c3RlbUlkOiBjdXJyZW50VXNlclN5c3RlbUlkLFxyXG4gICAgbmFtZTogZW1wbG95ZWU/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgYXZhdGFyOiBlbXBsb3llZT8uYXZhdGFyVXJsLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGhpc3RvcnkgZW50cnlcclxuY29uc3QgY3JlYXRlSGlzdG9yeUVudHJ5ID0gKFxyXG4gIGFjdGlvbjogSGlzdG9yeUVudHJ5WydhY3Rpb24nXSxcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gIG1ldGFkYXRhPzogSGlzdG9yeUVudHJ5WydtZXRhZGF0YSddXHJcbik6IEhpc3RvcnlFbnRyeSA9PiAoe1xyXG4gIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gIGFjdGlvbixcclxuICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgdXNlcjogZ2V0Q3VycmVudFVzZXJJbmZvKCksXHJcbiAgZGVzY3JpcHRpb24sXHJcbiAgbWV0YWRhdGEsXHJcbn0pO1xyXG5cclxuZXhwb3J0IHR5cGUgUGF5bWVudElucHV0ID0gT21pdDxQYXltZW50LCAnc3lzdGVtSWQnIHwgJ2lkJz4gJiB7IGlkPzogQnVzaW5lc3NJZCB8IHN0cmluZyB9O1xyXG5cclxuaW50ZXJmYWNlIFBheW1lbnRTdG9yZSB7XHJcbiAgZGF0YTogUGF5bWVudFtdO1xyXG4gIGJ1c2luZXNzSWRDb3VudGVyOiBudW1iZXI7XHJcbiAgc3lzdGVtSWRDb3VudGVyOiBudW1iZXI7XHJcbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XHJcbiAgYWRkOiAoaXRlbTogUGF5bWVudElucHV0KSA9PiBQYXltZW50O1xyXG4gIGFkZE11bHRpcGxlOiAoaXRlbXM6IFBheW1lbnRJbnB1dFtdKSA9PiB2b2lkO1xyXG4gIHVwZGF0ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgaXRlbTogUGF5bWVudCkgPT4gdm9pZDtcclxuICByZW1vdmU6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHZvaWQ7XHJcbiAgZmluZEJ5SWQ6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IFBheW1lbnQgfCB1bmRlZmluZWQ7XHJcbiAgZ2V0QWN0aXZlOiAoKSA9PiBQYXltZW50W107XHJcbiAgY2FuY2VsOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCByZWFzb24/OiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgbG9hZEZyb21BUEk6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmNvbnN0IFBBWU1FTlRfRU5USVRZOiBFbnRpdHlUeXBlID0gJ3BheW1lbnRzJztcclxuY29uc3QgU1lTVEVNX0lEX1BSRUZJWCA9ICdQQVlNRU5UJztcclxuY29uc3QgQlVTSU5FU1NfSURfUFJFRklYID0gJ1BDJztcclxuY29uc3QgQlVTSU5FU1NfSURfRElHSVRTID0gNjtcclxuY29uc3QgUFVSQ0hBU0VfT1JERVJfU1lTVEVNX1BSRUZJWCA9ICdQVVJDSEFTRSc7XHJcbmNvbnN0IFBVUkNIQVNFX09SREVSX0JVU0lORVNTX1BSRUZJWCA9ICdQTyc7XHJcblxyXG5jb25zdCBub3JtYWxpemVQYXltZW50U3RhdHVzID0gKHN0YXR1cz86IFBheW1lbnRbJ3N0YXR1cyddKTogUGF5bWVudFsnc3RhdHVzJ10gPT5cclxuICBzdGF0dXMgPT09ICdjYW5jZWxsZWQnID8gJ2NhbmNlbGxlZCcgOiAnY29tcGxldGVkJztcclxuXHJcbmNvbnN0IG5vcm1hbGl6ZVBheW1lbnQgPSAocGF5bWVudDogUGF5bWVudCk6IFBheW1lbnQgPT4gKHtcclxuICAuLi5wYXltZW50LFxyXG4gIHN0YXR1czogbm9ybWFsaXplUGF5bWVudFN0YXR1cyhwYXltZW50LnN0YXR1cyksXHJcbn0pO1xyXG5cclxuY29uc3QgZW5zdXJlUGF5bWVudE1ldGFkYXRhID0gKHBheW1lbnQ6IFBheW1lbnQpOiBQYXltZW50ID0+IHtcclxuICBsZXQgbXV0YXRlZCA9IGZhbHNlO1xyXG4gIGNvbnN0IHVwZGF0ZXM6IFBhcnRpYWw8UGF5bWVudD4gPSB7fTtcclxuXHJcbiAgY29uc3QgdGFyZ2V0R3JvdXAgPSBwaWNrVGFyZ2V0R3JvdXAoe1xyXG4gICAgc3lzdGVtSWQ6IHBheW1lbnQucmVjaXBpZW50VHlwZVN5c3RlbUlkLFxyXG4gICAgbmFtZTogcGF5bWVudC5yZWNpcGllbnRUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAodGFyZ2V0R3JvdXApIHtcclxuICAgIGlmIChwYXltZW50LnJlY2lwaWVudFR5cGVTeXN0ZW1JZCAhPT0gdGFyZ2V0R3JvdXAuc3lzdGVtSWQpIHtcclxuICAgICAgdXBkYXRlcy5yZWNpcGllbnRUeXBlU3lzdGVtSWQgPSB0YXJnZXRHcm91cC5zeXN0ZW1JZDtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAocGF5bWVudC5yZWNpcGllbnRUeXBlTmFtZSAhPT0gdGFyZ2V0R3JvdXAubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnJlY2lwaWVudFR5cGVOYW1lID0gdGFyZ2V0R3JvdXAubmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXltZW50TWV0aG9kID0gcGlja1BheW1lbnRNZXRob2Qoe1xyXG4gICAgc3lzdGVtSWQ6IHBheW1lbnQucGF5bWVudE1ldGhvZFN5c3RlbUlkLFxyXG4gICAgbmFtZTogcGF5bWVudC5wYXltZW50TWV0aG9kTmFtZSxcclxuICB9KTtcclxuICBpZiAocGF5bWVudE1ldGhvZCkge1xyXG4gICAgaWYgKHBheW1lbnQucGF5bWVudE1ldGhvZFN5c3RlbUlkICE9PSBwYXltZW50TWV0aG9kLnN5c3RlbUlkKSB7XHJcbiAgICAgIHVwZGF0ZXMucGF5bWVudE1ldGhvZFN5c3RlbUlkID0gcGF5bWVudE1ldGhvZC5zeXN0ZW1JZDtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAocGF5bWVudC5wYXltZW50TWV0aG9kTmFtZSAhPT0gcGF5bWVudE1ldGhvZC5uYW1lKSB7XHJcbiAgICAgIHVwZGF0ZXMucGF5bWVudE1ldGhvZE5hbWUgPSBwYXltZW50TWV0aG9kLm5hbWU7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgYWNjb3VudCA9IHBpY2tBY2NvdW50KHtcclxuICAgIGFjY291bnRTeXN0ZW1JZDogcGF5bWVudC5hY2NvdW50U3lzdGVtSWQsXHJcbiAgICBicmFuY2hTeXN0ZW1JZDogcGF5bWVudC5icmFuY2hTeXN0ZW1JZCxcclxuICAgIHBheW1lbnRNZXRob2ROYW1lOiBwYXltZW50TWV0aG9kPy5uYW1lID8/IHBheW1lbnQucGF5bWVudE1ldGhvZE5hbWUsXHJcbiAgfSk7XHJcbiAgaWYgKGFjY291bnQgJiYgcGF5bWVudC5hY2NvdW50U3lzdGVtSWQgIT09IGFjY291bnQuc3lzdGVtSWQpIHtcclxuICAgIHVwZGF0ZXMuYWNjb3VudFN5c3RlbUlkID0gYWNjb3VudC5zeXN0ZW1JZDtcclxuICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcGF5bWVudFR5cGUgPSBwaWNrUGF5bWVudFR5cGUoe1xyXG4gICAgc3lzdGVtSWQ6IHBheW1lbnQucGF5bWVudFJlY2VpcHRUeXBlU3lzdGVtSWQsXHJcbiAgICBuYW1lOiBwYXltZW50LnBheW1lbnRSZWNlaXB0VHlwZU5hbWUsXHJcbiAgfSk7XHJcbiAgaWYgKHBheW1lbnRUeXBlKSB7XHJcbiAgICBpZiAocGF5bWVudC5wYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCAhPT0gcGF5bWVudFR5cGUuc3lzdGVtSWQpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCA9IHBheW1lbnRUeXBlLnN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChwYXltZW50LnBheW1lbnRSZWNlaXB0VHlwZU5hbWUgIT09IHBheW1lbnRUeXBlLm5hbWUpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50UmVjZWlwdFR5cGVOYW1lID0gcGF5bWVudFR5cGUubmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBub3JtYWxpemVkR3JvdXBOYW1lID0gdGFyZ2V0R3JvdXA/Lm5hbWU/LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmIChub3JtYWxpemVkR3JvdXBOYW1lID09PSAna2jDoWNoIGjDoG5nJykge1xyXG4gICAgaWYgKCFwYXltZW50LmN1c3RvbWVyTmFtZSAmJiBwYXltZW50LnJlY2lwaWVudE5hbWUpIHtcclxuICAgICAgdXBkYXRlcy5jdXN0b21lck5hbWUgPSBwYXltZW50LnJlY2lwaWVudE5hbWU7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXltZW50LmN1c3RvbWVyU3lzdGVtSWQgJiYgcGF5bWVudC5yZWNpcGllbnRTeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLmN1c3RvbWVyU3lzdGVtSWQgPSBwYXltZW50LnJlY2lwaWVudFN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBtdXRhdGVkID8geyAuLi5wYXltZW50LCAuLi51cGRhdGVzIH0gOiBwYXltZW50O1xyXG59O1xyXG5cclxuY29uc3QgYmFja2ZpbGxQYXltZW50TWV0YWRhdGEgPSAocGF5bWVudHM6IFBheW1lbnRbXSk6IFBheW1lbnRbXSA9PiB7XHJcbiAgbGV0IG11dGF0ZWQgPSBmYWxzZTtcclxuICBjb25zdCB1cGRhdGVkID0gcGF5bWVudHMubWFwKHBheW1lbnQgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGVuc3VyZVBheW1lbnRNZXRhZGF0YShwYXltZW50KTtcclxuICAgIGlmIChub3JtYWxpemVkICE9PSBwYXltZW50KSB7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG11dGF0ZWQgPyB1cGRhdGVkIDogcGF5bWVudHM7XHJcbn07XHJcblxyXG5jb25zdCBpbml0aWFsUGF5bWVudHM6IFBheW1lbnRbXSA9IFtdOyAvLyBEYXRhYmFzZSBpcyBzb3VyY2Ugb2YgdHJ1dGhcclxuXHJcbmxldCBzeXN0ZW1JZENvdW50ZXIgPSBnZXRNYXhTeXN0ZW1JZENvdW50ZXIoaW5pdGlhbFBheW1lbnRzLCBTWVNURU1fSURfUFJFRklYKTtcclxubGV0IGJ1c2luZXNzSWRDb3VudGVyID0gZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIoaW5pdGlhbFBheW1lbnRzLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG5cclxuY29uc3QgZ2V0TmV4dFN5c3RlbUlkID0gKCk6IFN5c3RlbUlkID0+IHtcclxuICBzeXN0ZW1JZENvdW50ZXIgKz0gMTtcclxuICByZXR1cm4gYXNTeXN0ZW1JZChnZW5lcmF0ZVN5c3RlbUlkKFBBWU1FTlRfRU5USVRZLCBzeXN0ZW1JZENvdW50ZXIpKTtcclxufTtcclxuXHJcbmNvbnN0IGVuc3VyZVBheW1lbnRCdXNpbmVzc0lkID0gKHBheW1lbnRzOiBQYXltZW50W10sIHByb3ZpZGVkPzogQnVzaW5lc3NJZCB8IHN0cmluZyk6IEJ1c2luZXNzSWQgPT4ge1xyXG4gIGlmIChwcm92aWRlZCAmJiBgJHtwcm92aWRlZH1gLnRyaW0oKS5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gYCR7cHJvdmlkZWR9YC50cmltKCkudG9VcHBlckNhc2UoKTtcclxuICAgIGNvbnN0IHBhcnNlZENvdW50ZXIgPSBleHRyYWN0Q291bnRlckZyb21CdXNpbmVzc0lkKG5vcm1hbGl6ZWQsIEJVU0lORVNTX0lEX1BSRUZJWCk7XHJcbiAgICBpZiAocGFyc2VkQ291bnRlciA+IGJ1c2luZXNzSWRDb3VudGVyKSB7XHJcbiAgICAgIGJ1c2luZXNzSWRDb3VudGVyID0gcGFyc2VkQ291bnRlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBhc0J1c2luZXNzSWQobm9ybWFsaXplZCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBleGlzdGluZ0lkcyA9IHBheW1lbnRzLm1hcChwYXltZW50ID0+IHBheW1lbnQuaWQgYXMgc3RyaW5nKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgY29uc3QgeyBuZXh0SWQsIHVwZGF0ZWRDb3VudGVyIH0gPSBmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQoXHJcbiAgICBCVVNJTkVTU19JRF9QUkVGSVgsXHJcbiAgICBleGlzdGluZ0lkcyxcclxuICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgQlVTSU5FU1NfSURfRElHSVRTXHJcbiAgKTtcclxuICBidXNpbmVzc0lkQ291bnRlciA9IHVwZGF0ZWRDb3VudGVyO1xyXG4gIHJldHVybiBhc0J1c2luZXNzSWQobmV4dElkKTtcclxufTtcclxuXHJcbmNvbnN0IHJlY29uY2lsZUxpbmtlZERvY3VtZW50cyA9IChwYXltZW50OiBQYXltZW50KTogUGF5bWVudCA9PiB7XHJcbiAgaWYgKCFwYXltZW50Lm9yaWdpbmFsRG9jdW1lbnRJZCkge1xyXG4gICAgcmV0dXJuIHBheW1lbnQ7XHJcbiAgfVxyXG5cclxuICBjb25zdCBub3JtYWxpemVkRG9jSWQgPSBwYXltZW50Lm9yaWdpbmFsRG9jdW1lbnRJZC50b1VwcGVyQ2FzZSgpO1xyXG4gIGNvbnN0IG5leHRQYXltZW50ID0geyAuLi5wYXltZW50IH07XHJcblxyXG4gIGlmICghbmV4dFBheW1lbnQucHVyY2hhc2VPcmRlclN5c3RlbUlkICYmIG5vcm1hbGl6ZWREb2NJZC5zdGFydHNXaXRoKFBVUkNIQVNFX09SREVSX1NZU1RFTV9QUkVGSVgpKSB7XHJcbiAgICBuZXh0UGF5bWVudC5wdXJjaGFzZU9yZGVyU3lzdGVtSWQgPSBhc1N5c3RlbUlkKHBheW1lbnQub3JpZ2luYWxEb2N1bWVudElkKTtcclxuICB9XHJcblxyXG4gIGlmICghbmV4dFBheW1lbnQucHVyY2hhc2VPcmRlcklkICYmIG5vcm1hbGl6ZWREb2NJZC5zdGFydHNXaXRoKFBVUkNIQVNFX09SREVSX0JVU0lORVNTX1BSRUZJWCkpIHtcclxuICAgIG5leHRQYXltZW50LnB1cmNoYXNlT3JkZXJJZCA9IGFzQnVzaW5lc3NJZChwYXltZW50Lm9yaWdpbmFsRG9jdW1lbnRJZCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV4dFBheW1lbnQ7XHJcbn07XHJcblxyXG5jb25zdCBidWlsZFBheW1lbnQgPSAoaW5wdXQ6IFBheW1lbnRJbnB1dCwgZXhpc3RpbmdQYXltZW50czogUGF5bWVudFtdKTogUGF5bWVudCA9PiB7XHJcbiAgY29uc3Qgc3lzdGVtSWQgPSBnZXROZXh0U3lzdGVtSWQoKTtcclxuICBjb25zdCBpZCA9IGVuc3VyZVBheW1lbnRCdXNpbmVzc0lkKGV4aXN0aW5nUGF5bWVudHMsIGlucHV0LmlkKTtcclxuICBjb25zdCBiYXNlUGF5bWVudDogUGF5bWVudCA9IHtcclxuICAgIC4uLmlucHV0LFxyXG4gICAgc3lzdGVtSWQsXHJcbiAgICBpZCxcclxuICAgIGNyZWF0ZWRBdDogaW5wdXQuY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIHN0YXR1czogbm9ybWFsaXplUGF5bWVudFN0YXR1cyhpbnB1dC5zdGF0dXMpLFxyXG4gIH07XHJcblxyXG4gIHJldHVybiByZWNvbmNpbGVMaW5rZWREb2N1bWVudHMoYmFzZVBheW1lbnQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVBheW1lbnRTdG9yZSA9IGNyZWF0ZTxQYXltZW50U3RvcmU+KCkoXHJcbiAgKHNldCwgZ2V0KSA9PiAoe1xyXG4gICAgICBkYXRhOiBpbml0aWFsUGF5bWVudHMsXHJcbiAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICBzeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcclxuICAgICAgXHJcbiAgICAgIGFkZDogKGl0ZW0pID0+IHtcclxuICAgICAgICBsZXQgY3JlYXRlZFBheW1lbnQ6IFBheW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBzZXQoc3RhdGUgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbmV3UGF5bWVudCA9IGJ1aWxkUGF5bWVudChpdGVtLCBzdGF0ZS5kYXRhKTtcclxuICAgICAgICAgIGNyZWF0ZWRQYXltZW50ID0gbmV3UGF5bWVudDtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCBuZXdQYXltZW50XSxcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlcixcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gU3luYyB0byBBUElcclxuICAgICAgICBpZiAoY3JlYXRlZFBheW1lbnQpIHtcclxuICAgICAgICAgIHN5bmNUb0FQSSgnY3JlYXRlJywgY3JlYXRlZFBheW1lbnQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlZFBheW1lbnQhO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgYWRkTXVsdGlwbGU6IChpdGVtcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQ6IFBheW1lbnRbXSA9IFtdO1xyXG4gICAgICAgIHNldChzdGF0ZSA9PiB7XHJcbiAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gWy4uLnN0YXRlLmRhdGEsIC4uLmNyZWF0ZWRdO1xyXG4gICAgICAgICAgICBjb25zdCBwYXltZW50ID0gYnVpbGRQYXltZW50KGl0ZW0sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjcmVhdGVkLnB1c2gocGF5bWVudCk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBbLi4uc3RhdGUuZGF0YSwgLi4uY3JlYXRlZF0sXHJcbiAgICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFN5bmMgYWxsIHRvIEFQSVxyXG4gICAgICAgIGNyZWF0ZWQuZm9yRWFjaChwYXltZW50ID0+IHtcclxuICAgICAgICAgIHN5bmNUb0FQSSgnY3JlYXRlJywgcGF5bWVudCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICB1cGRhdGU6IChzeXN0ZW1JZCwgaXRlbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSByZWNvbmNpbGVMaW5rZWREb2N1bWVudHMoe1xyXG4gICAgICAgICAgLi4uaXRlbSxcclxuICAgICAgICAgIHN5c3RlbUlkLFxyXG4gICAgICAgICAgc3RhdHVzOiBub3JtYWxpemVQYXltZW50U3RhdHVzKGl0ZW0uc3RhdHVzKSxcclxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xyXG4gICAgICAgICAgZGF0YTogc3RhdGUuZGF0YS5tYXAocGF5bWVudCA9PlxyXG4gICAgICAgICAgICBwYXltZW50LnN5c3RlbUlkID09PSBzeXN0ZW1JZCA/IHVwZGF0ZWQgOiBwYXltZW50XHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIFN5bmMgdG8gQVBJXHJcbiAgICAgICAgc3luY1RvQVBJKCd1cGRhdGUnLCB1cGRhdGVkKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHJlbW92ZTogKHN5c3RlbUlkKSA9PiB7XHJcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XHJcbiAgICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLmZpbHRlcihwYXltZW50ID0+IHBheW1lbnQuc3lzdGVtSWQgIT09IHN5c3RlbUlkKSxcclxuICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgc3lzdGVtSWRDb3VudGVyLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIHN5bmNUb0FQSSgnZGVsZXRlJywgeyBzeXN0ZW1JZCB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGZpbmRCeUlkOiAoc3lzdGVtSWQpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YS5maW5kKHBheW1lbnQgPT4gcGF5bWVudC5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQpO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgZ2V0QWN0aXZlOiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldCgpLmRhdGEuZmlsdGVyKHBheW1lbnQgPT4gcGF5bWVudC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGNhbmNlbDogKHN5c3RlbUlkOiBTeXN0ZW1JZCwgcmVhc29uPzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF5bWVudCA9IGdldCgpLmZpbmRCeUlkKHN5c3RlbUlkKTtcclxuICAgICAgICBpZiAocGF5bWVudCAmJiBwYXltZW50LnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpIHtcclxuICAgICAgICAgIGNvbnN0IGhpc3RvcnlFbnRyeSA9IGNyZWF0ZUhpc3RvcnlFbnRyeShcclxuICAgICAgICAgICAgJ2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICAgIGDEkMOjIGjhu6d5IHBoaeG6v3UgY2hpJHtyZWFzb24gPyBgOiAke3JlYXNvbn1gIDogJyd9YCxcclxuICAgICAgICAgICAgeyBvbGRWYWx1ZTogJ0hvw6BuIHRow6BuaCcsIG5ld1ZhbHVlOiAnxJDDoyBo4buneScsIG5vdGU6IHJlYXNvbiB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBnZXQoKS51cGRhdGUoc3lzdGVtSWQsIHtcclxuICAgICAgICAgICAgLi4ucGF5bWVudCxcclxuICAgICAgICAgICAgc3RhdHVzOiAnY2FuY2VsbGVkJyxcclxuICAgICAgICAgICAgY2FuY2VsbGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgYWN0aXZpdHlIaXN0b3J5OiBbLi4uKHBheW1lbnQuYWN0aXZpdHlIaXN0b3J5IHx8IFtdKSwgaGlzdG9yeUVudHJ5XSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGxvYWRGcm9tQVBJOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIE5PVEU6IFVzZSBSZWFjdCBRdWVyeSBob29rcyBmb3IgcGFnaW5hdGVkIGRhdGEuIFRoaXMgb25seSBsb2FkcyBpbml0aWFsIGJhdGNoLlxyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wYXltZW50cz9saW1pdD0zMCcpO1xyXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuO1xyXG4gICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIGNvbnN0IGFwaURhdGEgPSBqc29uLmRhdGEgfHwgW107XHJcbiAgICAgICAgICBpZiAoYXBpRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBiYWNrZmlsbFBheW1lbnRNZXRhZGF0YShhcGlEYXRhLm1hcChub3JtYWxpemVQYXltZW50KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRTeXN0ZW1Db3VudGVyID0gZ2V0TWF4U3lzdGVtSWRDb3VudGVyKG5vcm1hbGl6ZWQsIFNZU1RFTV9JRF9QUkVGSVgpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0QnVzaW5lc3NDb3VudGVyID0gZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIobm9ybWFsaXplZCwgQlVTSU5FU1NfSURfUFJFRklYKTtcclxuICAgICAgICAgICAgc3lzdGVtSWRDb3VudGVyID0gbmV4dFN5c3RlbUNvdW50ZXI7XHJcbiAgICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyID0gbmV4dEJ1c2luZXNzQ291bnRlcjtcclxuICAgICAgICAgICAgc2V0KHsgXHJcbiAgICAgICAgICAgICAgZGF0YTogbm9ybWFsaXplZCwgXHJcbiAgICAgICAgICAgICAgc3lzdGVtSWRDb3VudGVyLCBcclxuICAgICAgICAgICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXQoeyBpbml0aWFsaXplZDogdHJ1ZSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1BheW1lbnRzIEFQSV0gbG9hZEZyb21BUEkgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJleHRyYWN0Q291bnRlckZyb21CdXNpbmVzc0lkIiwiZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkIiwiZ2VuZXJhdGVTeXN0ZW1JZCIsImdldE1heEJ1c2luZXNzSWRDb3VudGVyIiwiZ2V0TWF4U3lzdGVtSWRDb3VudGVyIiwiYXNCdXNpbmVzc0lkIiwiYXNTeXN0ZW1JZCIsInBpY2tBY2NvdW50IiwicGlja1BheW1lbnRNZXRob2QiLCJwaWNrUGF5bWVudFR5cGUiLCJwaWNrVGFyZ2V0R3JvdXAiLCJ1c2VFbXBsb3llZVN0b3JlIiwiZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCIsInN5bmNUb0FQSSIsImFjdGlvbiIsImRhdGEiLCJlbmRwb2ludCIsInN5c3RlbUlkIiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsIm9rIiwiY29uc29sZSIsImVycm9yIiwidGV4dCIsImdldEN1cnJlbnRVc2VySW5mbyIsImN1cnJlbnRVc2VyU3lzdGVtSWQiLCJlbXBsb3llZSIsImdldFN0YXRlIiwiZmluZCIsImUiLCJuYW1lIiwiZnVsbE5hbWUiLCJhdmF0YXIiLCJhdmF0YXJVcmwiLCJjcmVhdGVIaXN0b3J5RW50cnkiLCJkZXNjcmlwdGlvbiIsIm1ldGFkYXRhIiwiaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwidGltZXN0YW1wIiwiRGF0ZSIsInVzZXIiLCJQQVlNRU5UX0VOVElUWSIsIlNZU1RFTV9JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9ESUdJVFMiLCJQVVJDSEFTRV9PUkRFUl9TWVNURU1fUFJFRklYIiwiUFVSQ0hBU0VfT1JERVJfQlVTSU5FU1NfUFJFRklYIiwibm9ybWFsaXplUGF5bWVudFN0YXR1cyIsInN0YXR1cyIsIm5vcm1hbGl6ZVBheW1lbnQiLCJwYXltZW50IiwiZW5zdXJlUGF5bWVudE1ldGFkYXRhIiwibXV0YXRlZCIsInVwZGF0ZXMiLCJ0YXJnZXRHcm91cCIsInJlY2lwaWVudFR5cGVTeXN0ZW1JZCIsInJlY2lwaWVudFR5cGVOYW1lIiwicGF5bWVudE1ldGhvZCIsInBheW1lbnRNZXRob2RTeXN0ZW1JZCIsInBheW1lbnRNZXRob2ROYW1lIiwiYWNjb3VudCIsImFjY291bnRTeXN0ZW1JZCIsImJyYW5jaFN5c3RlbUlkIiwicGF5bWVudFR5cGUiLCJwYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCIsInBheW1lbnRSZWNlaXB0VHlwZU5hbWUiLCJub3JtYWxpemVkR3JvdXBOYW1lIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiY3VzdG9tZXJOYW1lIiwicmVjaXBpZW50TmFtZSIsImN1c3RvbWVyU3lzdGVtSWQiLCJyZWNpcGllbnRTeXN0ZW1JZCIsImJhY2tmaWxsUGF5bWVudE1ldGFkYXRhIiwicGF5bWVudHMiLCJ1cGRhdGVkIiwibWFwIiwibm9ybWFsaXplZCIsImluaXRpYWxQYXltZW50cyIsInN5c3RlbUlkQ291bnRlciIsImJ1c2luZXNzSWRDb3VudGVyIiwiZ2V0TmV4dFN5c3RlbUlkIiwiZW5zdXJlUGF5bWVudEJ1c2luZXNzSWQiLCJwcm92aWRlZCIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwicGFyc2VkQ291bnRlciIsImV4aXN0aW5nSWRzIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm5leHRJZCIsInVwZGF0ZWRDb3VudGVyIiwicmVjb25jaWxlTGlua2VkRG9jdW1lbnRzIiwib3JpZ2luYWxEb2N1bWVudElkIiwibm9ybWFsaXplZERvY0lkIiwibmV4dFBheW1lbnQiLCJwdXJjaGFzZU9yZGVyU3lzdGVtSWQiLCJzdGFydHNXaXRoIiwicHVyY2hhc2VPcmRlcklkIiwiYnVpbGRQYXltZW50IiwiaW5wdXQiLCJleGlzdGluZ1BheW1lbnRzIiwiYmFzZVBheW1lbnQiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInVzZVBheW1lbnRTdG9yZSIsInNldCIsImdldCIsImluaXRpYWxpemVkIiwiYWRkIiwiaXRlbSIsImNyZWF0ZWRQYXltZW50Iiwic3RhdGUiLCJuZXdQYXltZW50IiwiY2F0Y2giLCJhZGRNdWx0aXBsZSIsIml0ZW1zIiwiY3JlYXRlZCIsImZvckVhY2giLCJjb250ZXh0IiwicHVzaCIsInVwZGF0ZSIsInVwZGF0ZWRBdCIsInJlbW92ZSIsImZpbmRCeUlkIiwiZ2V0QWN0aXZlIiwiY2FuY2VsIiwicmVhc29uIiwiaGlzdG9yeUVudHJ5Iiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIm5vdGUiLCJjYW5jZWxsZWRBdCIsImFjdGl2aXR5SGlzdG9yeSIsImxvYWRGcm9tQVBJIiwianNvbiIsImFwaURhdGEiLCJuZXh0U3lzdGVtQ291bnRlciIsIm5leHRCdXNpbmVzc0NvdW50ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/payments/store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./features/receipts/store.ts":
/*!************************************!*\
  !*** ./features/receipts/store.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useReceiptStore: () => (/* binding */ useReceiptStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _lib_id_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/id-utils */ \"(app-pages-browser)/./lib/id-utils.ts\");\n/* harmony import */ var _lib_id_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/id-types */ \"(app-pages-browser)/./lib/id-types.ts\");\n/* harmony import */ var _features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/features/finance/document-lookups */ \"(app-pages-browser)/./features/finance/document-lookups.ts\");\n/* harmony import */ var _employees_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../employees/store */ \"(app-pages-browser)/./features/employees/store.ts\");\n/* harmony import */ var _contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../contexts/auth-context */ \"(app-pages-browser)/./contexts/auth-context.tsx\");\n\n\n\n\n// REMOVED: import { data as initialData } from './data'; // Mock data no longer used - database is source of truth\n\n\n\n// API sync helpers\nasync function syncToAPI(action, data) {\n    try {\n        const endpoint = action === 'create' ? '/api/receipts' : `/api/receipts/${data.systemId}`;\n        const method = action === 'create' ? 'POST' : action === 'update' ? 'PATCH' : 'DELETE';\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: action !== 'delete' ? JSON.stringify(data) : undefined\n        });\n        if (!response.ok) {\n            console.error(`[Receipts API] ${action} failed:`, await response.text());\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error(`[Receipts API] ${action} error:`, error);\n        return false;\n    }\n}\n// Helper to get current user info\nconst getCurrentUserInfo = ()=>{\n    const currentUserSystemId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.() || 'SYSTEM';\n    const employee = _employees_store__WEBPACK_IMPORTED_MODULE_3__.useEmployeeStore.getState().data.find((e)=>e.systemId === currentUserSystemId);\n    return {\n        systemId: currentUserSystemId,\n        name: employee?.fullName || 'Hệ thống',\n        avatar: employee?.avatarUrl\n    };\n};\n// Helper to create history entry\nconst createHistoryEntry = (action, description, metadata)=>({\n        id: crypto.randomUUID(),\n        action,\n        timestamp: new Date(),\n        user: getCurrentUserInfo(),\n        description,\n        metadata\n    });\nconst SYSTEM_AUTHOR = (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)('SYSTEM');\nconst getCurrentReceiptAuthor = ()=>{\n    const userId = (0,_contexts_auth_context__WEBPACK_IMPORTED_MODULE_4__.getCurrentUserSystemId)?.();\n    return userId ? (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)(userId) : SYSTEM_AUTHOR;\n};\nconst RECEIPT_ENTITY = 'receipts';\nconst SYSTEM_ID_PREFIX = 'RECEIPT';\nconst BUSINESS_ID_PREFIX = 'PT';\nconst BUSINESS_ID_DIGITS = 6;\nconst normalizeReceiptStatus = (status)=>status === 'cancelled' ? 'cancelled' : 'completed';\nconst ensureReceiptMetadata = (receipt)=>{\n    let mutated = false;\n    const updates = {};\n    const targetGroup = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickTargetGroup)({\n        systemId: receipt.payerTypeSystemId,\n        name: receipt.payerTypeName\n    });\n    if (targetGroup) {\n        if (receipt.payerTypeSystemId !== targetGroup.systemId) {\n            updates.payerTypeSystemId = targetGroup.systemId;\n            mutated = true;\n        }\n        if (receipt.payerTypeName !== targetGroup.name) {\n            updates.payerTypeName = targetGroup.name;\n            mutated = true;\n        }\n    }\n    const paymentMethod = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickPaymentMethod)({\n        systemId: receipt.paymentMethodSystemId,\n        name: receipt.paymentMethodName\n    });\n    if (paymentMethod) {\n        if (receipt.paymentMethodSystemId !== paymentMethod.systemId) {\n            updates.paymentMethodSystemId = paymentMethod.systemId;\n            mutated = true;\n        }\n        if (receipt.paymentMethodName !== paymentMethod.name) {\n            updates.paymentMethodName = paymentMethod.name;\n            mutated = true;\n        }\n    }\n    const account = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickAccount)({\n        accountSystemId: receipt.accountSystemId,\n        branchSystemId: receipt.branchSystemId,\n        paymentMethodName: paymentMethod?.name ?? receipt.paymentMethodName\n    });\n    if (account && receipt.accountSystemId !== account.systemId) {\n        updates.accountSystemId = account.systemId;\n        mutated = true;\n    }\n    const receiptType = (0,_features_finance_document_lookups__WEBPACK_IMPORTED_MODULE_2__.pickReceiptType)({\n        systemId: receipt.paymentReceiptTypeSystemId,\n        name: receipt.paymentReceiptTypeName\n    });\n    if (receiptType) {\n        if (receipt.paymentReceiptTypeSystemId !== receiptType.systemId) {\n            updates.paymentReceiptTypeSystemId = receiptType.systemId;\n            mutated = true;\n        }\n        if (receipt.paymentReceiptTypeName !== receiptType.name) {\n            updates.paymentReceiptTypeName = receiptType.name;\n            mutated = true;\n        }\n    }\n    if (!receipt.customerName && receipt.payerName) {\n        updates.customerName = receipt.payerName;\n        mutated = true;\n    }\n    if (!receipt.customerSystemId && receipt.payerSystemId) {\n        updates.customerSystemId = receipt.payerSystemId;\n        mutated = true;\n    }\n    return mutated ? {\n        ...receipt,\n        ...updates\n    } : receipt;\n};\nconst backfillReceiptMetadata = (receipts)=>{\n    let mutated = false;\n    const updated = receipts.map((receipt)=>{\n        const normalized = ensureReceiptMetadata(receipt);\n        if (normalized !== receipt) {\n            mutated = true;\n        }\n        return normalized;\n    });\n    return mutated ? updated : receipts;\n};\nconst initialReceipts = []; // Database is source of truth\nlet systemIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(initialReceipts, SYSTEM_ID_PREFIX);\nlet businessIdCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(initialReceipts, BUSINESS_ID_PREFIX);\nconst getNextSystemId = ()=>{\n    systemIdCounter += 1;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asSystemId)((0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.generateSystemId)(RECEIPT_ENTITY, systemIdCounter));\n};\nconst ensureReceiptBusinessId = (receipts, provided)=>{\n    if (provided && `${provided}`.trim().length > 0) {\n        const normalized = `${provided}`.trim().toUpperCase();\n        const parsedCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.extractCounterFromBusinessId)(normalized, BUSINESS_ID_PREFIX);\n        if (parsedCounter > businessIdCounter) {\n            businessIdCounter = parsedCounter;\n        }\n        return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(normalized);\n    }\n    const existingIds = receipts.map((receipt)=>receipt.id).filter(Boolean);\n    const { nextId, updatedCounter } = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.findNextAvailableBusinessId)(BUSINESS_ID_PREFIX, existingIds, businessIdCounter, BUSINESS_ID_DIGITS);\n    businessIdCounter = updatedCounter;\n    return (0,_lib_id_types__WEBPACK_IMPORTED_MODULE_1__.asBusinessId)(nextId);\n};\nconst useReceiptStore = (0,zustand__WEBPACK_IMPORTED_MODULE_5__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_6__.subscribeWithSelector)((set, get)=>({\n        data: initialReceipts,\n        businessIdCounter,\n        systemIdCounter,\n        initialized: false,\n        add: (item)=>{\n            let createdReceipt = null;\n            set((state)=>{\n                const systemId = getNextSystemId();\n                const id = ensureReceiptBusinessId(state.data, item.id);\n                const createdBy = item.createdBy ?? getCurrentReceiptAuthor();\n                const newReceipt = {\n                    ...item,\n                    systemId,\n                    id,\n                    createdBy,\n                    createdAt: item.createdAt || new Date().toISOString(),\n                    status: normalizeReceiptStatus(item.status),\n                    orderAllocations: item.orderAllocations ?? []\n                };\n                const normalizedReceipt = ensureReceiptMetadata(newReceipt);\n                createdReceipt = normalizedReceipt;\n                return {\n                    data: [\n                        ...state.data,\n                        normalizedReceipt\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync to API\n            if (createdReceipt) {\n                syncToAPI('create', createdReceipt).catch(console.error);\n            }\n            return createdReceipt;\n        },\n        addMultiple: (items)=>{\n            const created = [];\n            set((state)=>{\n                items.forEach((item)=>{\n                    const context = [\n                        ...state.data,\n                        ...created\n                    ];\n                    const systemId = getNextSystemId();\n                    const id = ensureReceiptBusinessId(context, item.id);\n                    const createdBy = item.createdBy ?? getCurrentReceiptAuthor();\n                    const newReceipt = {\n                        ...item,\n                        systemId,\n                        id,\n                        createdBy,\n                        createdAt: item.createdAt || new Date().toISOString(),\n                        status: normalizeReceiptStatus(item.status),\n                        orderAllocations: item.orderAllocations ?? []\n                    };\n                    created.push(ensureReceiptMetadata(newReceipt));\n                });\n                return {\n                    data: [\n                        ...state.data,\n                        ...created\n                    ],\n                    businessIdCounter,\n                    systemIdCounter\n                };\n            });\n            // Sync all to API\n            created.forEach((receipt)=>{\n                syncToAPI('create', receipt).catch(console.error);\n            });\n        },\n        update: (systemId, item)=>{\n            const updated = {\n                ...item,\n                status: normalizeReceiptStatus(item.status),\n                updatedAt: new Date().toISOString()\n            };\n            set((state)=>({\n                    data: state.data.map((r)=>r.systemId === systemId ? updated : r),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('update', updated).catch(console.error);\n        },\n        remove: (systemId)=>{\n            set((state)=>({\n                    data: state.data.filter((r)=>r.systemId !== systemId),\n                    businessIdCounter,\n                    systemIdCounter\n                }));\n            // Sync to API\n            syncToAPI('delete', {\n                systemId\n            }).catch(console.error);\n        },\n        findById: (systemId)=>{\n            return get().data.find((r)=>r.systemId === systemId);\n        },\n        getActive: ()=>{\n            return get().data.filter((r)=>r.status !== 'cancelled');\n        },\n        cancel: (systemId, reason)=>{\n            const receipt = get().findById(systemId);\n            if (receipt && receipt.status !== 'cancelled') {\n                const historyEntry = createHistoryEntry('cancelled', `Đã hủy phiếu thu${reason ? `: ${reason}` : ''}`, {\n                    oldValue: 'Hoàn thành',\n                    newValue: 'Đã hủy',\n                    note: reason\n                });\n                get().update(systemId, {\n                    ...receipt,\n                    status: 'cancelled',\n                    cancelledAt: new Date().toISOString(),\n                    activityHistory: [\n                        ...receipt.activityHistory || [],\n                        historyEntry\n                    ]\n                });\n            }\n        },\n        loadFromAPI: async ()=>{\n            try {\n                // NOTE: Use React Query hooks for paginated data. This only loads initial batch.\n                const response = await fetch('/api/receipts?limit=30');\n                if (!response.ok) return;\n                const json = await response.json();\n                const apiData = json.data || [];\n                if (apiData.length > 0) {\n                    const normalized = backfillReceiptMetadata(apiData.map((receipt)=>({\n                            ...receipt,\n                            status: normalizeReceiptStatus(receipt.status)\n                        })));\n                    const nextSystemCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxSystemIdCounter)(normalized, SYSTEM_ID_PREFIX);\n                    const nextBusinessCounter = (0,_lib_id_utils__WEBPACK_IMPORTED_MODULE_0__.getMaxBusinessIdCounter)(normalized, BUSINESS_ID_PREFIX);\n                    systemIdCounter = nextSystemCounter;\n                    businessIdCounter = nextBusinessCounter;\n                    set({\n                        data: normalized,\n                        systemIdCounter,\n                        businessIdCounter,\n                        initialized: true\n                    });\n                } else {\n                    set({\n                        initialized: true\n                    });\n                }\n            } catch (error) {\n                console.error('[Receipts API] loadFromAPI error:', error);\n            }\n        }\n    })));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3JlY2VpcHRzL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzBCO0FBVW5DO0FBQ2tFO0FBQzFGLG1IQUFtSDtBQUNJO0FBQ2pFO0FBQ2U7QUFFckUsbUJBQW1CO0FBQ25CLGVBQWVlLFVBQVVDLE1BQXNDLEVBQUVDLElBQVM7SUFDeEUsSUFBSTtRQUNGLE1BQU1DLFdBQVdGLFdBQVcsV0FBVyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUVDLEtBQUtFLFFBQVEsRUFBRTtRQUN6RixNQUFNQyxTQUFTSixXQUFXLFdBQVcsU0FBU0EsV0FBVyxXQUFXLFVBQVU7UUFFOUUsTUFBTUssV0FBVyxNQUFNQyxNQUFNSixVQUFVO1lBQ3JDRTtZQUNBRyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTVIsV0FBVyxXQUFXUyxLQUFLQyxTQUFTLENBQUNULFFBQVFVO1FBQ3JEO1FBRUEsSUFBSSxDQUFDTixTQUFTTyxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLGVBQWUsRUFBRWQsT0FBTyxRQUFRLENBQUMsRUFBRSxNQUFNSyxTQUFTVSxJQUFJO1lBQ3JFLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVCxFQUFFLE9BQU9ELE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFZCxPQUFPLE9BQU8sQ0FBQyxFQUFFYztRQUNqRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLGtDQUFrQztBQUNsQyxNQUFNRSxxQkFBcUI7SUFDekIsTUFBTUMsc0JBQXNCbkIsOEVBQXNCQSxRQUFRO0lBQzFELE1BQU1vQixXQUFXckIsOERBQWdCQSxDQUFDc0IsUUFBUSxHQUFHbEIsSUFBSSxDQUFDbUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbEIsUUFBUSxLQUFLYztJQUMzRSxPQUFPO1FBQ0xkLFVBQVVjO1FBQ1ZLLE1BQU1KLFVBQVVLLFlBQVk7UUFDNUJDLFFB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QUFpRjtnQkFDakYsTUFBTWxILFdBQVcsTUFBTUMsTUFBTTtnQkFDN0IsSUFBSSxDQUFDRCxTQUFTTyxFQUFFLEVBQUU7Z0JBQ2xCLE1BQU00RyxPQUFPLE1BQU1uSCxTQUFTbUgsSUFBSTtnQkFDaEMsTUFBTUMsVUFBVUQsS0FBS3ZILElBQUksSUFBSSxFQUFFO2dCQUMvQixJQUFJd0gsUUFBUTdDLE1BQU0sR0FBRyxHQUFHO29CQUN0QixNQUFNUixhQUFhSix3QkFBd0J5RCxRQUFRdEQsR0FBRyxDQUFDLENBQUN0QixVQUFzQjs0QkFDNUUsR0FBR0EsT0FBTzs0QkFDVkYsUUFBUUQsdUJBQXVCRyxRQUFRRixNQUFNO3dCQUMvQztvQkFDQSxNQUFNK0Usb0JBQW9Cckksb0VBQXFCQSxDQUFDK0UsWUFBWTdCO29CQUM1RCxNQUFNb0Ysc0JBQXNCdkksc0VBQXVCQSxDQUFDZ0YsWUFBWTVCO29CQUNoRThCLGtCQUFrQm9EO29CQUNsQm5ELG9CQUFvQm9EO29CQUNwQnRDLElBQUk7d0JBQ0ZwRixNQUFNbUU7d0JBQ05FO3dCQUNBQzt3QkFDQWdCLGFBQWE7b0JBQ2Y7Z0JBQ0YsT0FBTztvQkFDTEYsSUFBSTt3QkFBRUUsYUFBYTtvQkFBSztnQkFDMUI7WUFDRixFQUFFLE9BQU96RSxPQUFPO2dCQUNkRCxRQUFRQyxLQUFLLENBQUMscUNBQXFDQTtZQUNyRDtRQUNGO0lBQ0YsS0FFRiIsInNvdXJjZXMiOlsiRDpcXGhybTJcXGZlYXR1cmVzXFxyZWNlaXB0c1xcc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHN1YnNjcmliZVdpdGhTZWxlY3RvciB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XHJcbmltcG9ydCB0eXBlIHsgUmVjZWlwdCB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgdHlwZSB7IEhpc3RvcnlFbnRyeSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQWN0aXZpdHlIaXN0b3J5JztcclxuaW1wb3J0IHsgXHJcbiAgZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkLCBcclxuICBnZW5lcmF0ZVN5c3RlbUlkLCBcclxuICBnZXRNYXhCdXNpbmVzc0lkQ291bnRlciwgXHJcbiAgZ2V0TWF4U3lzdGVtSWRDb3VudGVyLFxyXG4gIGV4dHJhY3RDb3VudGVyRnJvbUJ1c2luZXNzSWQsXHJcbiAgdHlwZSBFbnRpdHlUeXBlIFxyXG59IGZyb20gJ0AvbGliL2lkLXV0aWxzJztcclxuaW1wb3J0IHsgYXNTeXN0ZW1JZCwgYXNCdXNpbmVzc0lkLCB0eXBlIEJ1c2luZXNzSWQsIHR5cGUgU3lzdGVtSWQgfSBmcm9tICdAL2xpYi9pZC10eXBlcyc7XHJcbi8vIFJFTU9WRUQ6IGltcG9ydCB7IGRhdGEgYXMgaW5pdGlhbERhdGEgfSBmcm9tICcuL2RhdGEnOyAvLyBNb2NrIGRhdGEgbm8gbG9uZ2VyIHVzZWQgLSBkYXRhYmFzZSBpcyBzb3VyY2Ugb2YgdHJ1dGhcclxuaW1wb3J0IHsgcGlja0FjY291bnQsIHBpY2tQYXltZW50TWV0aG9kLCBwaWNrUmVjZWlwdFR5cGUsIHBpY2tUYXJnZXRHcm91cCB9IGZyb20gJ0AvZmVhdHVyZXMvZmluYW5jZS9kb2N1bWVudC1sb29rdXBzJztcclxuaW1wb3J0IHsgdXNlRW1wbG95ZWVTdG9yZSB9IGZyb20gJy4uL2VtcGxveWVlcy9zdG9yZSc7XHJcbmltcG9ydCB7IGdldEN1cnJlbnRVc2VyU3lzdGVtSWQgfSBmcm9tICcuLi8uLi9jb250ZXh0cy9hdXRoLWNvbnRleHQnO1xyXG5cclxuLy8gQVBJIHN5bmMgaGVscGVyc1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jVG9BUEkoYWN0aW9uOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIGRhdGE6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnL2FwaS9yZWNlaXB0cycgOiBgL2FwaS9yZWNlaXB0cy8ke2RhdGEuc3lzdGVtSWR9YDtcclxuICAgIGNvbnN0IG1ldGhvZCA9IGFjdGlvbiA9PT0gJ2NyZWF0ZScgPyAnUE9TVCcgOiBhY3Rpb24gPT09ICd1cGRhdGUnID8gJ1BBVENIJyA6ICdERUxFVEUnO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XHJcbiAgICAgIG1ldGhvZCxcclxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgIGJvZHk6IGFjdGlvbiAhPT0gJ2RlbGV0ZScgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtSZWNlaXB0cyBBUEldICR7YWN0aW9ufSBmYWlsZWQ6YCwgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFtSZWNlaXB0cyBBUEldICR7YWN0aW9ufSBlcnJvcjpgLCBlcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gZ2V0IGN1cnJlbnQgdXNlciBpbmZvXHJcbmNvbnN0IGdldEN1cnJlbnRVc2VySW5mbyA9ICgpID0+IHtcclxuICBjb25zdCBjdXJyZW50VXNlclN5c3RlbUlkID0gZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZD8uKCkgfHwgJ1NZU1RFTSc7XHJcbiAgY29uc3QgZW1wbG95ZWUgPSB1c2VFbXBsb3llZVN0b3JlLmdldFN0YXRlKCkuZGF0YS5maW5kKGUgPT4gZS5zeXN0ZW1JZCA9PT0gY3VycmVudFVzZXJTeXN0ZW1JZCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5c3RlbUlkOiBjdXJyZW50VXNlclN5c3RlbUlkLFxyXG4gICAgbmFtZTogZW1wbG95ZWU/LmZ1bGxOYW1lIHx8ICdI4buHIHRo4buRbmcnLFxyXG4gICAgYXZhdGFyOiBlbXBsb3llZT8uYXZhdGFyVXJsLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGhpc3RvcnkgZW50cnlcclxuY29uc3QgY3JlYXRlSGlzdG9yeUVudHJ5ID0gKFxyXG4gIGFjdGlvbjogSGlzdG9yeUVudHJ5WydhY3Rpb24nXSxcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gIG1ldGFkYXRhPzogSGlzdG9yeUVudHJ5WydtZXRhZGF0YSddXHJcbik6IEhpc3RvcnlFbnRyeSA9PiAoe1xyXG4gIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gIGFjdGlvbixcclxuICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgdXNlcjogZ2V0Q3VycmVudFVzZXJJbmZvKCksXHJcbiAgZGVzY3JpcHRpb24sXHJcbiAgbWV0YWRhdGEsXHJcbn0pO1xyXG5cclxuY29uc3QgU1lTVEVNX0FVVEhPUiA9IGFzU3lzdGVtSWQoJ1NZU1RFTScpO1xyXG5jb25zdCBnZXRDdXJyZW50UmVjZWlwdEF1dGhvciA9ICgpOiBTeXN0ZW1JZCA9PiB7XHJcbiAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZD8uKCk7XHJcbiAgcmV0dXJuIHVzZXJJZCA/IGFzU3lzdGVtSWQodXNlcklkKSA6IFNZU1RFTV9BVVRIT1I7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZWNlaXB0SW5wdXQgPSBPbWl0PFJlY2VpcHQsICdzeXN0ZW1JZCcgfCAnaWQnPiAmIHsgaWQ/OiBCdXNpbmVzc0lkIH07XHJcblxyXG5pbnRlcmZhY2UgUmVjZWlwdFN0b3JlIHtcclxuICBkYXRhOiBSZWNlaXB0W107XHJcbiAgYnVzaW5lc3NJZENvdW50ZXI6IG51bWJlcjtcclxuICBzeXN0ZW1JZENvdW50ZXI6IG51bWJlcjtcclxuICBpbml0aWFsaXplZDogYm9vbGVhbjtcclxuICBhZGQ6IChpdGVtOiBSZWNlaXB0SW5wdXQpID0+IFJlY2VpcHQ7XHJcbiAgYWRkTXVsdGlwbGU6IChpdGVtczogUmVjZWlwdElucHV0W10pID0+IHZvaWQ7XHJcbiAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBSZWNlaXB0KSA9PiB2b2lkO1xyXG4gIHJlbW92ZTogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gdm9pZDtcclxuICBmaW5kQnlJZDogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4gUmVjZWlwdCB8IHVuZGVmaW5lZDtcclxuICBnZXRBY3RpdmU6ICgpID0+IFJlY2VpcHRbXTtcclxuICBjYW5jZWw6IChzeXN0ZW1JZDogU3lzdGVtSWQsIHJlYXNvbj86IHN0cmluZykgPT4gdm9pZDtcclxuICBsb2FkRnJvbUFQSTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuY29uc3QgUkVDRUlQVF9FTlRJVFk6IEVudGl0eVR5cGUgPSAncmVjZWlwdHMnO1xyXG5jb25zdCBTWVNURU1fSURfUFJFRklYID0gJ1JFQ0VJUFQnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9QUkVGSVggPSAnUFQnO1xyXG5jb25zdCBCVVNJTkVTU19JRF9ESUdJVFMgPSA2O1xyXG5cclxuY29uc3Qgbm9ybWFsaXplUmVjZWlwdFN0YXR1cyA9IChzdGF0dXM/OiBSZWNlaXB0WydzdGF0dXMnXSk6IFJlY2VpcHRbJ3N0YXR1cyddID0+XHJcbiAgc3RhdHVzID09PSAnY2FuY2VsbGVkJyA/ICdjYW5jZWxsZWQnIDogJ2NvbXBsZXRlZCc7XHJcblxyXG5jb25zdCBlbnN1cmVSZWNlaXB0TWV0YWRhdGEgPSAocmVjZWlwdDogUmVjZWlwdCk6IFJlY2VpcHQgPT4ge1xyXG4gIGxldCBtdXRhdGVkID0gZmFsc2U7XHJcbiAgY29uc3QgdXBkYXRlczogUGFydGlhbDxSZWNlaXB0PiA9IHt9O1xyXG5cclxuICBjb25zdCB0YXJnZXRHcm91cCA9IHBpY2tUYXJnZXRHcm91cCh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXllclR5cGVTeXN0ZW1JZCxcclxuICAgIG5hbWU6IHJlY2VpcHQucGF5ZXJUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAodGFyZ2V0R3JvdXApIHtcclxuICAgIGlmIChyZWNlaXB0LnBheWVyVHlwZVN5c3RlbUlkICE9PSB0YXJnZXRHcm91cC5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnBheWVyVHlwZVN5c3RlbUlkID0gdGFyZ2V0R3JvdXAuc3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY2VpcHQucGF5ZXJUeXBlTmFtZSAhPT0gdGFyZ2V0R3JvdXAubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnBheWVyVHlwZU5hbWUgPSB0YXJnZXRHcm91cC5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHBheW1lbnRNZXRob2QgPSBwaWNrUGF5bWVudE1ldGhvZCh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXltZW50TWV0aG9kU3lzdGVtSWQsXHJcbiAgICBuYW1lOiByZWNlaXB0LnBheW1lbnRNZXRob2ROYW1lLFxyXG4gIH0pO1xyXG4gIGlmIChwYXltZW50TWV0aG9kKSB7XHJcbiAgICBpZiAocmVjZWlwdC5wYXltZW50TWV0aG9kU3lzdGVtSWQgIT09IHBheW1lbnRNZXRob2Quc3lzdGVtSWQpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kU3lzdGVtSWQgPSBwYXltZW50TWV0aG9kLnN5c3RlbUlkO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChyZWNlaXB0LnBheW1lbnRNZXRob2ROYW1lICE9PSBwYXltZW50TWV0aG9kLm5hbWUpIHtcclxuICAgICAgdXBkYXRlcy5wYXltZW50TWV0aG9kTmFtZSA9IHBheW1lbnRNZXRob2QubmFtZTtcclxuICAgICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhY2NvdW50ID0gcGlja0FjY291bnQoe1xyXG4gICAgYWNjb3VudFN5c3RlbUlkOiByZWNlaXB0LmFjY291bnRTeXN0ZW1JZCxcclxuICAgIGJyYW5jaFN5c3RlbUlkOiByZWNlaXB0LmJyYW5jaFN5c3RlbUlkLFxyXG4gICAgcGF5bWVudE1ldGhvZE5hbWU6IHBheW1lbnRNZXRob2Q/Lm5hbWUgPz8gcmVjZWlwdC5wYXltZW50TWV0aG9kTmFtZSxcclxuICB9KTtcclxuICBpZiAoYWNjb3VudCAmJiByZWNlaXB0LmFjY291bnRTeXN0ZW1JZCAhPT0gYWNjb3VudC5zeXN0ZW1JZCkge1xyXG4gICAgdXBkYXRlcy5hY2NvdW50U3lzdGVtSWQgPSBhY2NvdW50LnN5c3RlbUlkO1xyXG4gICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZWNlaXB0VHlwZSA9IHBpY2tSZWNlaXB0VHlwZSh7XHJcbiAgICBzeXN0ZW1JZDogcmVjZWlwdC5wYXltZW50UmVjZWlwdFR5cGVTeXN0ZW1JZCxcclxuICAgIG5hbWU6IHJlY2VpcHQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSxcclxuICB9KTtcclxuICBpZiAocmVjZWlwdFR5cGUpIHtcclxuICAgIGlmIChyZWNlaXB0LnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkICE9PSByZWNlaXB0VHlwZS5zeXN0ZW1JZCkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkID0gcmVjZWlwdFR5cGUuc3lzdGVtSWQ7XHJcbiAgICAgIG11dGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY2VpcHQucGF5bWVudFJlY2VpcHRUeXBlTmFtZSAhPT0gcmVjZWlwdFR5cGUubmFtZSkge1xyXG4gICAgICB1cGRhdGVzLnBheW1lbnRSZWNlaXB0VHlwZU5hbWUgPSByZWNlaXB0VHlwZS5uYW1lO1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghcmVjZWlwdC5jdXN0b21lck5hbWUgJiYgcmVjZWlwdC5wYXllck5hbWUpIHtcclxuICAgIHVwZGF0ZXMuY3VzdG9tZXJOYW1lID0gcmVjZWlwdC5wYXllck5hbWU7XHJcbiAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICghcmVjZWlwdC5jdXN0b21lclN5c3RlbUlkICYmIHJlY2VpcHQucGF5ZXJTeXN0ZW1JZCkge1xyXG4gICAgdXBkYXRlcy5jdXN0b21lclN5c3RlbUlkID0gcmVjZWlwdC5wYXllclN5c3RlbUlkO1xyXG4gICAgbXV0YXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbXV0YXRlZCA/IHsgLi4ucmVjZWlwdCwgLi4udXBkYXRlcyB9IDogcmVjZWlwdDtcclxufTtcclxuXHJcbmNvbnN0IGJhY2tmaWxsUmVjZWlwdE1ldGFkYXRhID0gKHJlY2VpcHRzOiBSZWNlaXB0W10pOiBSZWNlaXB0W10gPT4ge1xyXG4gIGxldCBtdXRhdGVkID0gZmFsc2U7XHJcbiAgY29uc3QgdXBkYXRlZCA9IHJlY2VpcHRzLm1hcChyZWNlaXB0ID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBlbnN1cmVSZWNlaXB0TWV0YWRhdGEocmVjZWlwdCk7XHJcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gcmVjZWlwdCkge1xyXG4gICAgICBtdXRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gIH0pO1xyXG4gIHJldHVybiBtdXRhdGVkID8gdXBkYXRlZCA6IHJlY2VpcHRzO1xyXG59O1xyXG5cclxuY29uc3QgaW5pdGlhbFJlY2VpcHRzOiBSZWNlaXB0W10gPSBbXTsgLy8gRGF0YWJhc2UgaXMgc291cmNlIG9mIHRydXRoXHJcblxyXG5sZXQgc3lzdGVtSWRDb3VudGVyID0gZ2V0TWF4U3lzdGVtSWRDb3VudGVyKGluaXRpYWxSZWNlaXB0cywgU1lTVEVNX0lEX1BSRUZJWCk7XHJcbmxldCBidXNpbmVzc0lkQ291bnRlciA9IGdldE1heEJ1c2luZXNzSWRDb3VudGVyKGluaXRpYWxSZWNlaXB0cywgQlVTSU5FU1NfSURfUFJFRklYKTtcclxuXHJcbmNvbnN0IGdldE5leHRTeXN0ZW1JZCA9ICgpOiBTeXN0ZW1JZCA9PiB7XHJcbiAgc3lzdGVtSWRDb3VudGVyICs9IDE7XHJcbiAgcmV0dXJuIGFzU3lzdGVtSWQoZ2VuZXJhdGVTeXN0ZW1JZChSRUNFSVBUX0VOVElUWSwgc3lzdGVtSWRDb3VudGVyKSk7XHJcbn07XHJcblxyXG5jb25zdCBlbnN1cmVSZWNlaXB0QnVzaW5lc3NJZCA9IChyZWNlaXB0czogUmVjZWlwdFtdLCBwcm92aWRlZD86IEJ1c2luZXNzSWQgfCBzdHJpbmcpOiBCdXNpbmVzc0lkID0+IHtcclxuICBpZiAocHJvdmlkZWQgJiYgYCR7cHJvdmlkZWR9YC50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGAke3Byb3ZpZGVkfWAudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCBwYXJzZWRDb3VudGVyID0gZXh0cmFjdENvdW50ZXJGcm9tQnVzaW5lc3NJZChub3JtYWxpemVkLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG4gICAgaWYgKHBhcnNlZENvdW50ZXIgPiBidXNpbmVzc0lkQ291bnRlcikge1xyXG4gICAgICBidXNpbmVzc0lkQ291bnRlciA9IHBhcnNlZENvdW50ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXNCdXNpbmVzc0lkKG5vcm1hbGl6ZWQpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSByZWNlaXB0cy5tYXAocmVjZWlwdCA9PiByZWNlaXB0LmlkIGFzIHN0cmluZykuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIGNvbnN0IHsgbmV4dElkLCB1cGRhdGVkQ291bnRlciB9ID0gZmluZE5leHRBdmFpbGFibGVCdXNpbmVzc0lkKFxyXG4gICAgQlVTSU5FU1NfSURfUFJFRklYLFxyXG4gICAgZXhpc3RpbmdJZHMsXHJcbiAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgIEJVU0lORVNTX0lEX0RJR0lUU1xyXG4gICk7XHJcbiAgYnVzaW5lc3NJZENvdW50ZXIgPSB1cGRhdGVkQ291bnRlcjtcclxuICByZXR1cm4gYXNCdXNpbmVzc0lkKG5leHRJZCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlUmVjZWlwdFN0b3JlID0gY3JlYXRlPFJlY2VpcHRTdG9yZT4oKShcclxuICBzdWJzY3JpYmVXaXRoU2VsZWN0b3IoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIGRhdGE6IGluaXRpYWxSZWNlaXB0cyxcclxuICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgIHN5c3RlbUlkQ291bnRlcixcclxuICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICBcclxuICAgICAgYWRkOiAoaXRlbTogUmVjZWlwdElucHV0KTogUmVjZWlwdCA9PiB7XHJcbiAgICAgICAgbGV0IGNyZWF0ZWRSZWNlaXB0OiBSZWNlaXB0IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgc2V0KHN0YXRlID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN5c3RlbUlkID0gZ2V0TmV4dFN5c3RlbUlkKCk7XHJcbiAgICAgICAgICBjb25zdCBpZCA9IGVuc3VyZVJlY2VpcHRCdXNpbmVzc0lkKHN0YXRlLmRhdGEsIGl0ZW0uaWQpO1xyXG4gICAgICAgICAgY29uc3QgY3JlYXRlZEJ5ID0gaXRlbS5jcmVhdGVkQnkgPz8gZ2V0Q3VycmVudFJlY2VpcHRBdXRob3IoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgbmV3UmVjZWlwdDogUmVjZWlwdCA9IHsgXHJcbiAgICAgICAgICAgIC4uLml0ZW0sIFxyXG4gICAgICAgICAgICBzeXN0ZW1JZCwgXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBjcmVhdGVkQnksXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogaXRlbS5jcmVhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVJlY2VpcHRTdGF0dXMoaXRlbS5zdGF0dXMpLFxyXG4gICAgICAgICAgICBvcmRlckFsbG9jYXRpb25zOiBpdGVtLm9yZGVyQWxsb2NhdGlvbnMgPz8gW10sXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWNlaXB0ID0gZW5zdXJlUmVjZWlwdE1ldGFkYXRhKG5ld1JlY2VpcHQpO1xyXG4gICAgICAgICAgY3JlYXRlZFJlY2VpcHQgPSBub3JtYWxpemVkUmVjZWlwdDtcclxuXHJcbiAgICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgICAgZGF0YTogWy4uLnN0YXRlLmRhdGEsIG5vcm1hbGl6ZWRSZWNlaXB0XSxcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIGlmIChjcmVhdGVkUmVjZWlwdCkge1xyXG4gICAgICAgICAgc3luY1RvQVBJKCdjcmVhdGUnLCBjcmVhdGVkUmVjZWlwdCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVkUmVjZWlwdCE7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBhZGRNdWx0aXBsZTogKGl0ZW1zOiBSZWNlaXB0SW5wdXRbXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZWQ6IFJlY2VpcHRbXSA9IFtdO1xyXG4gICAgICAgIHNldChzdGF0ZSA9PiB7XHJcbiAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gWy4uLnN0YXRlLmRhdGEsIC4uLmNyZWF0ZWRdO1xyXG4gICAgICAgICAgICBjb25zdCBzeXN0ZW1JZCA9IGdldE5leHRTeXN0ZW1JZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGVuc3VyZVJlY2VpcHRCdXNpbmVzc0lkKGNvbnRleHQsIGl0ZW0uaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQnkgPSBpdGVtLmNyZWF0ZWRCeSA/PyBnZXRDdXJyZW50UmVjZWlwdEF1dGhvcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbmV3UmVjZWlwdDogUmVjZWlwdCA9IHsgXHJcbiAgICAgICAgICAgICAgLi4uaXRlbSwgXHJcbiAgICAgICAgICAgICAgc3lzdGVtSWQsIFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRCeSxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGl0ZW0uY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBzdGF0dXM6IG5vcm1hbGl6ZVJlY2VpcHRTdGF0dXMoaXRlbS5zdGF0dXMpLFxyXG4gICAgICAgICAgICAgIG9yZGVyQWxsb2NhdGlvbnM6IGl0ZW0ub3JkZXJBbGxvY2F0aW9ucyA/PyBbXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3JlYXRlZC5wdXNoKGVuc3VyZVJlY2VpcHRNZXRhZGF0YShuZXdSZWNlaXB0KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICAgIGRhdGE6IFsuLi5zdGF0ZS5kYXRhLCAuLi5jcmVhdGVkXSxcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTeW5jIGFsbCB0byBBUElcclxuICAgICAgICBjcmVhdGVkLmZvckVhY2gocmVjZWlwdCA9PiB7XHJcbiAgICAgICAgICBzeW5jVG9BUEkoJ2NyZWF0ZScsIHJlY2VpcHQpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgdXBkYXRlOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCBpdGVtOiBSZWNlaXB0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4uaXRlbSwgc3RhdHVzOiBub3JtYWxpemVSZWNlaXB0U3RhdHVzKGl0ZW0uc3RhdHVzKSwgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcclxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEubWFwKHIgPT4gci5zeXN0ZW1JZCA9PT0gc3lzdGVtSWQgPyB1cGRhdGVkIDogciksXHJcbiAgICAgICAgICBidXNpbmVzc0lkQ291bnRlcixcclxuICAgICAgICAgIHN5c3RlbUlkQ291bnRlclxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBTeW5jIHRvIEFQSVxyXG4gICAgICAgIHN5bmNUb0FQSSgndXBkYXRlJywgdXBkYXRlZCkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICByZW1vdmU6IChzeXN0ZW1JZDogU3lzdGVtSWQpID0+IHtcclxuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcclxuICAgICAgICAgIGRhdGE6IHN0YXRlLmRhdGEuZmlsdGVyKHIgPT4gci5zeXN0ZW1JZCAhPT0gc3lzdGVtSWQpLFxyXG4gICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIsXHJcbiAgICAgICAgICBzeXN0ZW1JZENvdW50ZXJcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLy8gU3luYyB0byBBUElcclxuICAgICAgICBzeW5jVG9BUEkoJ2RlbGV0ZScsIHsgc3lzdGVtSWQgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBmaW5kQnlJZDogKHN5c3RlbUlkOiBTeXN0ZW1JZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBnZXQoKS5kYXRhLmZpbmQociA9PiByLnN5c3RlbUlkID09PSBzeXN0ZW1JZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBnZXRBY3RpdmU6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YS5maWx0ZXIociA9PiByLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgY2FuY2VsOiAoc3lzdGVtSWQ6IFN5c3RlbUlkLCByZWFzb24/OiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCByZWNlaXB0ID0gZ2V0KCkuZmluZEJ5SWQoc3lzdGVtSWQpO1xyXG4gICAgICAgIGlmIChyZWNlaXB0ICYmIHJlY2VpcHQuc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgY29uc3QgaGlzdG9yeUVudHJ5ID0gY3JlYXRlSGlzdG9yeUVudHJ5KFxyXG4gICAgICAgICAgICAnY2FuY2VsbGVkJyxcclxuICAgICAgICAgICAgYMSQw6MgaOG7p3kgcGhp4bq/dSB0aHUke3JlYXNvbiA/IGA6ICR7cmVhc29ufWAgOiAnJ31gLFxyXG4gICAgICAgICAgICB7IG9sZFZhbHVlOiAnSG/DoG4gdGjDoG5oJywgbmV3VmFsdWU6ICfEkMOjIGjhu6d5Jywgbm90ZTogcmVhc29uIH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGdldCgpLnVwZGF0ZShzeXN0ZW1JZCwge1xyXG4gICAgICAgICAgICAuLi5yZWNlaXB0LFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgICAgICBjYW5jZWxsZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICBhY3Rpdml0eUhpc3Rvcnk6IFsuLi4ocmVjZWlwdC5hY3Rpdml0eUhpc3RvcnkgfHwgW10pLCBoaXN0b3J5RW50cnldLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgbG9hZEZyb21BUEk6IGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gTk9URTogVXNlIFJlYWN0IFF1ZXJ5IGhvb2tzIGZvciBwYWdpbmF0ZWQgZGF0YS4gVGhpcyBvbmx5IGxvYWRzIGluaXRpYWwgYmF0Y2guXHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3JlY2VpcHRzP2xpbWl0PTMwJyk7XHJcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm47XHJcbiAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgY29uc3QgYXBpRGF0YSA9IGpzb24uZGF0YSB8fCBbXTtcclxuICAgICAgICAgIGlmIChhcGlEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGJhY2tmaWxsUmVjZWlwdE1ldGFkYXRhKGFwaURhdGEubWFwKChyZWNlaXB0OiBSZWNlaXB0KSA9PiAoe1xyXG4gICAgICAgICAgICAgIC4uLnJlY2VpcHQsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBub3JtYWxpemVSZWNlaXB0U3RhdHVzKHJlY2VpcHQuc3RhdHVzKSxcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFN5c3RlbUNvdW50ZXIgPSBnZXRNYXhTeXN0ZW1JZENvdW50ZXIobm9ybWFsaXplZCwgU1lTVEVNX0lEX1BSRUZJWCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRCdXNpbmVzc0NvdW50ZXIgPSBnZXRNYXhCdXNpbmVzc0lkQ291bnRlcihub3JtYWxpemVkLCBCVVNJTkVTU19JRF9QUkVGSVgpO1xyXG4gICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIgPSBuZXh0U3lzdGVtQ291bnRlcjtcclxuICAgICAgICAgICAgYnVzaW5lc3NJZENvdW50ZXIgPSBuZXh0QnVzaW5lc3NDb3VudGVyO1xyXG4gICAgICAgICAgICBzZXQoeyBcclxuICAgICAgICAgICAgICBkYXRhOiBub3JtYWxpemVkLCBcclxuICAgICAgICAgICAgICBzeXN0ZW1JZENvdW50ZXIsIFxyXG4gICAgICAgICAgICAgIGJ1c2luZXNzSWRDb3VudGVyLFxyXG4gICAgICAgICAgICAgIGluaXRpYWxpemVkOiB0cnVlIFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldCh7IGluaXRpYWxpemVkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUmVjZWlwdHMgQVBJXSBsb2FkRnJvbUFQSSBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSlcclxuICApXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3IiLCJmaW5kTmV4dEF2YWlsYWJsZUJ1c2luZXNzSWQiLCJnZW5lcmF0ZVN5c3RlbUlkIiwiZ2V0TWF4QnVzaW5lc3NJZENvdW50ZXIiLCJnZXRNYXhTeXN0ZW1JZENvdW50ZXIiLCJleHRyYWN0Q291bnRlckZyb21CdXNpbmVzc0lkIiwiYXNTeXN0ZW1JZCIsImFzQnVzaW5lc3NJZCIsInBpY2tBY2NvdW50IiwicGlja1BheW1lbnRNZXRob2QiLCJwaWNrUmVjZWlwdFR5cGUiLCJwaWNrVGFyZ2V0R3JvdXAiLCJ1c2VFbXBsb3llZVN0b3JlIiwiZ2V0Q3VycmVudFVzZXJTeXN0ZW1JZCIsInN5bmNUb0FQSSIsImFjdGlvbiIsImRhdGEiLCJlbmRwb2ludCIsInN5c3RlbUlkIiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsIm9rIiwiY29uc29sZSIsImVycm9yIiwidGV4dCIsImdldEN1cnJlbnRVc2VySW5mbyIsImN1cnJlbnRVc2VyU3lzdGVtSWQiLCJlbXBsb3llZSIsImdldFN0YXRlIiwiZmluZCIsImUiLCJuYW1lIiwiZnVsbE5hbWUiLCJhdmF0YXIiLCJhdmF0YXJVcmwiLCJjcmVhdGVIaXN0b3J5RW50cnkiLCJkZXNjcmlwdGlvbiIsIm1ldGFkYXRhIiwiaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwidGltZXN0YW1wIiwiRGF0ZSIsInVzZXIiLCJTWVNURU1fQVVUSE9SIiwiZ2V0Q3VycmVudFJlY2VpcHRBdXRob3IiLCJ1c2VySWQiLCJSRUNFSVBUX0VOVElUWSIsIlNZU1RFTV9JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9QUkVGSVgiLCJCVVNJTkVTU19JRF9ESUdJVFMiLCJub3JtYWxpemVSZWNlaXB0U3RhdHVzIiwic3RhdHVzIiwiZW5zdXJlUmVjZWlwdE1ldGFkYXRhIiwicmVjZWlwdCIsIm11dGF0ZWQiLCJ1cGRhdGVzIiwidGFyZ2V0R3JvdXAiLCJwYXllclR5cGVTeXN0ZW1JZCIsInBheWVyVHlwZU5hbWUiLCJwYXltZW50TWV0aG9kIiwicGF5bWVudE1ldGhvZFN5c3RlbUlkIiwicGF5bWVudE1ldGhvZE5hbWUiLCJhY2NvdW50IiwiYWNjb3VudFN5c3RlbUlkIiwiYnJhbmNoU3lzdGVtSWQiLCJyZWNlaXB0VHlwZSIsInBheW1lbnRSZWNlaXB0VHlwZVN5c3RlbUlkIiwicGF5bWVudFJlY2VpcHRUeXBlTmFtZSIsImN1c3RvbWVyTmFtZSIsInBheWVyTmFtZSIsImN1c3RvbWVyU3lzdGVtSWQiLCJwYXllclN5c3RlbUlkIiwiYmFja2ZpbGxSZWNlaXB0TWV0YWRhdGEiLCJyZWNlaXB0cyIsInVwZGF0ZWQiLCJtYXAiLCJub3JtYWxpemVkIiwiaW5pdGlhbFJlY2VpcHRzIiwic3lzdGVtSWRDb3VudGVyIiwiYnVzaW5lc3NJZENvdW50ZXIiLCJnZXROZXh0U3lzdGVtSWQiLCJlbnN1cmVSZWNlaXB0QnVzaW5lc3NJZCIsInByb3ZpZGVkIiwidHJpbSIsImxlbmd0aCIsInRvVXBwZXJDYXNlIiwicGFyc2VkQ291bnRlciIsImV4aXN0aW5nSWRzIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm5leHRJZCIsInVwZGF0ZWRDb3VudGVyIiwidXNlUmVjZWlwdFN0b3JlIiwic2V0IiwiZ2V0IiwiaW5pdGlhbGl6ZWQiLCJhZGQiLCJpdGVtIiwiY3JlYXRlZFJlY2VpcHQiLCJzdGF0ZSIsImNyZWF0ZWRCeSIsIm5ld1JlY2VpcHQiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsIm9yZGVyQWxsb2NhdGlvbnMiLCJub3JtYWxpemVkUmVjZWlwdCIsImNhdGNoIiwiYWRkTXVsdGlwbGUiLCJpdGVtcyIsImNyZWF0ZWQiLCJmb3JFYWNoIiwiY29udGV4dCIsInB1c2giLCJ1cGRhdGUiLCJ1cGRhdGVkQXQiLCJyIiwicmVtb3ZlIiwiZmluZEJ5SWQiLCJnZXRBY3RpdmUiLCJjYW5jZWwiLCJyZWFzb24iLCJoaXN0b3J5RW50cnkiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwibm90ZSIsImNhbmNlbGxlZEF0IiwiYWN0aXZpdHlIaXN0b3J5IiwibG9hZEZyb21BUEkiLCJqc29uIiwiYXBpRGF0YSIsIm5leHRTeXN0ZW1Db3VudGVyIiwibmV4dEJ1c2luZXNzQ291bnRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/receipts/store.ts\n"));

/***/ })

});